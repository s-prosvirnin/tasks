# Алгоритмические задачи

- Ссылки
    - LeetCode Solutions

      [LeetCode Solutions](https://walkccc.me/LeetCode/)

      [https://github.com/doocs/leetcode](https://github.com/doocs/leetcode)

      [NeetCode.io](https://neetcode.io/)

    - LeetCode Roadmaps

      [NeetCode.io](https://neetcode.io/)

      [Google Sheets: Leetcode 75 Questions (NeetCode on yt)](https://docs.google.com/spreadsheets/d/1A2PaQKcdwO_lwxz9bAnxXnIQayCouZP6d-ENrBz_NXc)

      [](https://github.com/comerc/yandex/blob/main/leetcode/)

      [Grind 75 - A better Blind 75 you can customize, by the author of Blind 75](https://www.techinterviewhandbook.org/grind75)

    - Ресурсы для решения задач
        - [LeetCode](https://leetcode.com/)
        - [HackerRank](https://www.hackerrank.com/)
        - [Codeforces](https://codeforces.com/)
        - [Topcoder](https://www.topcoder.com/)
        - [Timus Online Judge](https://acm.timus.ru/)
    - Ресурсы для подготовки

      [Grokking Coding Interview Patterns in Go - Learn Interactively](https://www.educative.io/courses/grokking-coding-interview-patterns-go?utm_campaign=coding-interview&utm_source=medium&utm_medium=&utm_content=&utm_term=&eid=5082902844932096)

      [Interview Pen | System Design Track](https://interviewpen.com/tracks/system-design)


---

## Полезное

[Решения типовых задач на Go](https://www.notion.so/Go-93dee7f8c3cc4c7aa4ef9ed469deb7db?pvs=21)

[ Алгоритмы и структуры данных](https://www.notion.so/235f9a9820fb4d15b77ae4f2892dec09?pvs=21)

### Алгоритмы

[Алгоритмы](https://www.notion.so/bb827b5be5b845bea41873d0d8fea6dd?pvs=21)

- Сортировки

  [Сортировки](https://www.notion.so/e77152deb57d4e0e9b45c1a083cd00cd?pvs=21)

  [Циклическая сортировка (c****ycle sort****)](https://www.notion.so/cycle-sort-42c0623313374857a92ee92947f960dd?pvs=21)

  [Сортировка подсчетом (count sort)](https://www.notion.so/count-sort-1fba4a41d88f45d3a601d2fcd762906f?pvs=21)

  [Сортировки слиянием (merge sort)](https://www.notion.so/merge-sort-018bc67a236b46098e566e6ec8b9c158?pvs=21)


[Метод зайца и черепахи](https://www.notion.so/ff80023a0e594ca7ab5a0208c36873e9?pvs=21)

[Два указателя [draft]](https://www.notion.so/draft-278415d3ec1246ff9b5b016795685ef8?pvs=21)

[Sliding window (скользящее окно) [draft]](https://www.notion.so/Sliding-window-draft-e553bdf67d21409eafa60b0b2030fea4?pvs=21)

[Динамическое программирование](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21)

[Backtracking (поиск с возвратом)](https://www.notion.so/Backtracking-c11e4366b07a44f880d47601a133111b?pvs=21)

[Интервальное слияние [draft]](https://www.notion.so/draft-6a5e22cd67554925b062a7256e73e0f1?pvs=21)

- Деревья

  [Поиск в ширину (обход в ширину, BFS)](https://www.notion.so/BFS-f8bbec2db02f4e988f8572172b320ee8?pvs=21)

  [Поиск в глубину (обход в глубину, DFS)](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21)


[Бинарный поиск](https://www.notion.so/8aa67c33fcbe4ce6913fc300d98e87a3?pvs=21)

[Префиксная сумма [draft]](https://www.notion.so/draft-f47ce8aefd4c4e06b3583f3a5487c470?pvs=21)

## Поиск комбинаций (подмножества/subsets)

- Ссылки

  [The Technical Interview Guide to Backtracking](https://betterprogramming.pub/the-technical-interview-guide-to-backtracking-e1a03ca4abad)


### Подъем по лестнице

- Рассчитать **количество вариантов подъема** по **лестнице** если можно подниматься на ступеньку или две.

  [LeetCode: 70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs)

    - Условие

      Нужно рассчитать количество уникальных комбинаций подъема по лестнице до определенной ступеньки. Подниматься можно на одну или две ступеньки.

    - Кейсы

      `n=2; res=2`

      `n=3; res=3`

    - Решение 1: Рекурсия с мемоизацией ([динамическое программирование](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21)).

      Идем от 0 до n. Рекурсивно разветвляемся на каждой итерации. Ответом будет количество листовых узлов (количество разветвлений). Запоминаем ответ для каждой итерации и подставляем, если уже просчитывали комбинации для текущего числа.

        - Визуализация

          ![IMG_5381.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/IMG_5381.jpg)


        **Сложность: время - O(n), память - O(n)**
        
        ```go
        // Рекурсия с мемоизацией (DFS).
        // В сути у нас есть бинарное дерево комбинаций.
        // На каждом узле (ступеньке) у нас есть две комбинации (два поддерева).
        // Нужно подсчитать количество листовых узлов (количество разветвлений).
        func climbStairs(n int) int {
          // Если нашли в мапе - сразу возвращаем результат.
          if res, ok := memo[n]; ok {
              return res
          }
          // Вышли за рамки последовательности (дерева комбинаций) - выходим.
          if n < 0 {
              return 0
          }
          // Дошли до конца ветки (до листового узла) - увеличиваем счетчик.
          if n == 0 {
              return 1
          }
          // Считаем сколько раз дошли до листовых узлов в обоих поддеревьях.
          res := climbStairs(n - 1) + climbStairs(n - 2)
          // Запоминаем расчет, чтобы не дублировать.
          memo[n] = res
        
          return res
        }
        
        // Мапа, куда сохраняются результаты расчетов для чисел (мемоизация).
        // Ключ - число, значение - количество комбинаций.
        var memo map[int]int = make(map[int]int)
        ```
        
    - **Решение 2 (оптимальное): Числа Фибоначчи.**
        
        Количество шагов для каждой ступеньки вычисляется как сумма шагов для двух предшествующих ступенек.
        
        - Визуализация
            
            ![IMG_5382.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/IMG_5382.jpg)
            
        
        **Сложность: время - O(n), память - O(1)**
        
        ```go
        func climbStairs(n int) int {
        	// Сделаем массив из 2-х элементов, чтобы можно было воспользоваться остатком от деления.
          stairs := make([]int, 2)
        	// На первую ступеньку можно попасть сделав 1 шаг.
        	// На вторую ступеньку можно попасть сделав 1 или 2 шага.
          stairs[0] = 1
          stairs[1] = 2
        	// Начнем с 3-ей ступеньки.
          for i := 2; i < n; i++ {
        			// Т.к. нам нужны только две предыдущие ступеньки, мы можем хранить только два элемента в массиве.
              stairs[i%2] = stairs[0] + stairs[1]
          }
          
        	// Вычисляем нужный индекс для последнего элемента.
          return stairs[(n-1)%2]
        }
        ```


- **Минимальная стоимость подъема по лестнице** с учетом оплаты на каждой ступеньке

  [LeetCode: 746. Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs)

    - Условие

      Дан целочисленный массив `cost`. Индекс - номер ступеньки, значение - стоимость подъема на эту ступеньку. Подниматься можно либо на одну ступеньку, либо сразу на две. Найти минимально возможную стоимость подъема по лестнице с учетом множества вариантов подъема.

      Можно начать как с первой ступеньки (`cost[0]`), так и со второй (`cost[1]`).

    - Кейсы
        - `cost = [10,**15**,20]; res = 15;`

          ![746_1.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/746_1.png)


        `cost = [**1**,100,**1**,**1**,**1**,100,**1**,**1**,100,**1**]; res = 6;`
        
    - **Решение 1. [Динамическое программирование](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21) - поднимаемся вверх, учитывая прошлые две ступеньки.**
        
        Сумма, которую мальчик отдаст на N-ой ступеньке, есть сумма, которую он отдал до этого плюс стоимость самой ступеньки. «Сумма, которую он отдал до этого» зависит от того, с какой ступеньки мальчик шагает на N-ую — с (N-1)-й или с (N-2)-й. Выбирать нужно наименьшую.
        
        **Сложность: время - O(n), память - O(1).**
        
        ```go
        // Очевидно, что сумма, которую мальчик отдаст на N-ой ступеньке, есть сумма,
        // которую он отдал до этого плюс стоимость самой ступеньки.
        // «Сумма, которую он отдал до этого» зависит от того, с какой ступеньки мальчик шагает на N-ую —
        // с (N-1)-й или с (N-2)-й. Выбирать нужно наименьшую.
        func minCostClimbingStairs(cost []int) int {
        		// Начинаем со второй ступеньки беря минимальную суммы с прошлых двух ступенек.
            count := len(cost) - 1
            for i := 2; i <= count; i++ {
                cost[i] += int(math.Min(float64(cost[i-1]), float64(cost[i-2])))
            }
            return int(math.Min(float64(cost[count]), float64(cost[count - 1])))
        }
        ```
        
    - Решение 2. [Динамическое программирование](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21) - табуляция. TODO.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        
        ```
        
    - Решение 3. [Динамическое программирование](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21) - рекурсия + мемоизация. TODO.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        
        ```

- Рассчитать **вероятность подъема по лестнице**, если с каждой ступеньки можно преодолевать ограниченное количество ступенек (прыжки).

  [LeetCode: 55. Jump Game](https://leetcode.com/problems/jump-game)

    - Условие

      Дан массив `nums`.

      Нужно рассчитать вероятность подъема до конца лестницы с первой ступеньки, если на каждой ступеньке задано максимальное количество ступенек, через которые можно шагнуть. Т.е. каждый элемент массива это ступенька.
        
      ---

      Каждое число в массиве (элемент массива) это максимальное количество следующих элементов, которые можно пропустить. Нужно проверить, можно ли добраться до конца массива.
        
      ---

      Каждый элемент массива это максимальная дистанция прыжка.

    - Кейсы

      `nums = [2,3,1,1,4]; res = true;` - индексы: 0→1→4

      `nums = [3,2,1,0,4]; res = false;` - мы навсегда остановимся на 4-м элементе.

      `nums = [1,2,0,1]; res = true;`

    - **Решение 1 (оптимальное): Жадный алгоритм.**
        - Устанавливаем максимум (максимальный индекс ступеньки) на который можем прийти с текущей ступеньки.
        - Если со следующей ступеньки можем пойти выше текущего максимума - переопределяем максимум.
        - Если максимум меньше чем индекс текущей ступеньки, то мы никак не можем прийти на эту ступеньку.
        - Пример

            ```
            indexes = 0 1 2 3 4   max   расчет  проверка
             values = 3 2 1 0 4    0     max    ступеньки
            -------------------   ---   ------  ---------
                      3            3     0+3      0<=0 +
            						2          3     1+2      1<=3 +
            							1        3     2+1      2<=3 +
            								0      3     3+0      3<=3 +
            									4    -     4+4      **4<=4 -**
            -------------------   ---   ------  ---------
            ****indexes = 0 1 2 3     max   расчет  проверка
             values = 1 2 0 1      0     max    ступеньки
            -------------------   ---   ------  ---------
                      3            1     0+1      0<=0 +
            						2          3     1+2      1<=3 +
            							1        3     2+0      2<=3 +
            								0      4     3+1      **3<=3 +**
            ```


        **Сложность: время - O(n), память - O(1)**
        
        ```go
        // Жадный алгоритм - сверяем максимум. 
        func canJump(nums []int) bool {
            // Максимальный индекс ступеньки до которой мы можем подняться.
            maxIdx := 0
            for i := 0; i < len(nums); i++ {
                // Если текущий индекс ступеньки больше чем максимальный,
                // то мы не можем подняться на текущую ступеньку - выходим.
                if i > maxIdx {
                    return false
                }
                // С текущей ступеньки мы можем подняться на максимум nums[i] ступенек.
                if i + nums[i] > maxIdx {
                    // Если с текущей ступеньки можем подняться больше,
                    // чем с какой-то прошлой, то переопределяем максимум.
                    maxIdx = i + nums[i]
                }
            }
            // Сюда пришли, когда прошли все ступеньки.
            return true
        }
        ```
        
    - Решение 2 (объемное, не самое быстрое): Рекурсия с мемоизацией ([динамическое программирование](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21)). TODO.
        - Визуализация
            
            `nums = [**2**, **4**, 2, 1, 0, **2**, 0];` - индексы: 0→1→5→end;
            
            ![IMG_5465.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/IMG_5465.jpg)
            
        
        **Сложность: время - O(n^2), память - O(n)**
        
        ```go
        
        ```
        
    - Решение 3 (объемное, не самое быстрое): Табуляция ([динамическое программирование](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21)). TODO.
        
        **Сложность: время - O(n^2), память - O(n)**
        
        ```go
        
        ```

- Найти все возможные **комбинации** чисел в **массиве** если все элементы **уникальны**.

  [LeetCode 78: Subsets](https://leetcode.com/problems/subsets/)

  [TODO: решить через [backtracking](https://www.notion.so/Backtracking-c11e4366b07a44f880d47601a133111b?pvs=21) (рекурсию)]

    - Решения

      Количество подмножеств будет $2^n$, т.к. для каждого элемента нам нужно удвоить комбинации, которые были сформированы на элементах до текущего. Т.е. ко всем прошлым комбинациям добавить текущее число.

      [Subsets](https://yuminlee2.medium.com/subsets-a62b3a48f7aa)

    - Решение 1 (простое, оптимальное). Итеративно добавляем каждое число в каждую комбинацию предыдущих чисел. ([Динамическое программирование](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21) - табуляция)

      [TODO: сделать понятную визуализацию]

        - Визуализация

          ![1__T9LrTPKmhTu0X6ShYsdSQ.webp](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/1__T9LrTPKmhTu0X6ShYsdSQ.webp)


        **Сложность: время - O(n*2^n), память - O(1)**. На leetcode память указана в **O(n*2^n)**, но, кажется, что дополнительная память уходит только на `comb`, которая переопределяется каждый раз.
        
        ```go
        func subsets(nums []int) [][]int {
            // Результирующий массив. Сразу добавим пустой массив в качестве первой комбинации.
            res := [][]int{make([]int, 0)}
            for _, num := range nums {
                // Для каждой сгенерированной комбинации создаем дубль и добавляем в него текущее число.
                // Начинаем с 1-цы, т.к. уже есть пустая комбинация.
                // Итерируемся до текущей длины результирующего массива, т.к. внутри цикла мы в него добавляем комбинации и расширяем его.
                for i , resCount := 1, len(res); i < resCount; i++ {
                    // nums=[1,2,3]; num=3; res=[[],[1],[2],[1,2]] 
                    comb := append([]int{num}, res[i]...)
                    res = append(res, comb)
                    // res=[[],[1],[2],[1,2],[1,3]]
                }
                // Добавляем текущее число.
                res = append(res, []int{num})
            }
        
            return res
        }
        ```
        
    - Решение 2 (объемное, оптимальное). [Backtracking](https://www.notion.so/Backtracking-c11e4366b07a44f880d47601a133111b?pvs=21). TODO.
        
        **Сложность: время - O(n*2^n), память - O(n).**
        
        ```go
        
        ```
        
    - Решение 3. Lexicographic (Binary Sorted) Subsets. TODO.
        
        **Сложность: время - O(n*2^n), память - O(n*2^n).**
        
        ```go
        
        ```

- Найти все возможные **комбинации** из `k` чисел, если числа находятся в диапазоне от 1 до `n`.

  [TODO: глубже разобраться и лучше описать с примером]

  [TODO: описать сложность]

  [LeetCode 77. Combinations](https://leetcode.com/problems/combinations/)

    - Решение 1 (оптимальное). [Backtracking](https://www.notion.so/Backtracking-c11e4366b07a44f880d47601a133111b?pvs=21).
        - Визуализация

          ![2.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/2.png)


        **Сложность: время - ???, память - ???.** [TODO: описать сложность]
        
        ```go
        // Backtracing.
        func combine(n int, k int) [][]int {
            // Результирующий массив с комбинациями.
        	var res [][]int
            // Массив с текущими комбинациями.
        	combinations := make([]int, 0, k)
            // Рекурсивная функция для формирования комбинаций.
        	var backtrack func(startNum int)
        	backtrack = func(startNum int) {
                // Если количество комбинаций дошло до k, записываем комбинации в результат.
        		if len(combinations) == k {
                    // Копируем текущий слайс и добавляем в результат,
                    // т.к. слайс сверху меняется в каждой рекурсии.
        			combinationsTemp := make([]int, len(combinations))
        			copy(combinationsTemp, combinations)
        			res = append(res, combinationsTemp)
        
        			return
        		}
                // Оптимизация, чтобы не ходить в числа, для которых уже есть комбинации.
                // Например, [1,2,3,4]:
                // Когда придем в 4-ку, для 4-ки уже все комбинации созданы.
                // Когда придем в 3-ку, для 3-ки останется только одна комбинация.
                // Для каждого числа при полном переборе (с повторами) нужно k комбинаций.
                // Для текущего числа нужно вычесть из k количество уже созданных комбинаций.
                needCombSize := k - len(combinations)
                // Остаток чисел для обхода.
                remainNums := n - startNum + 1
                // Максимальное число, до которого итерируемся в данный момент.
                maxNum := startNum + remainNums - needCombSize
                // Вызываем рекурсию от текущего числа.
        		for num := startNum; num <= maxNum; num++ {
                    // Добавляем текущее число в комбинацию.
        			combinations = append(combinations, num)
                    fmt.Println(startNum, num, maxNum, combinations)
                    // Вызываем рекурсию для следующего числа.
        			backtrack(num + 1)
                    // Удаляем текущее число из комбинации, иначе потащим его в верхнюю рекурсию.
        			combinations = combinations[:len(combinations) - 1]
        		}
        
        	}
        
        	backtrack(1)
        
        	return res
        }
        ```
        
    - Решение 2 (неоптимальное). [Поиск в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21).
        - Визуализация
            
            ![1.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/1.png)
            
        
        **Сложность: время - ???, память - ???.**
        
        ```go
        
        ```


- **Минимальное** количество **монет** для выдачи (**размена**) суммы.

  [LeetCode: 322. Coin Change](https://leetcode.com/problems/coin-change)

  Т.к. массив монет неотсортирован и большие монеты могут не подойти для размена, то нам нужно составить все возможные комбинации.

    - Условие

      Дан массив доступных монет и сумма, которую нужно разменять. Вернуть **минимальное** количество монет, которые можно выдать. Каждую монету можно использовать сколь угодно раз.

    - Кейсы

      `coins=[8,6,7]; amount=13; res=2 ([6,7])`

    - Решение 1. Мемоизация через рекурсию (BFS, [динамическое программирование](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21)).

      Рекурсия - для каждой монеты вызываем рекурсивную функцию с уменьшенной суммой. Запоминаем количество монет, которое вернула рекурсия, чтобы не дублировать вызовы.

        - Визуализация

          ![IMG_5375 2.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/IMG_5375_2.jpg)


        ```go
        // Рекурсия с мемоизацией.
        func coinChange(coins []int, amount int) int {
            // Почему-то надо вернуть 0 при нулевой сумме.
            if amount == 0 {
                return 0
            }
            res := coinChangeRecur(coins, amount, make(map[int]int))
            // Максимальный int вернется, когда не подобрали.
            if res == math.MaxInt {
                return -1
            }
        
            return res
        }
        
        // Рекурсивно подбираем все доступные варианты размена с запоминанием уже подобранных в memo.
        func coinChangeRecur(coins []int, remains int, memo map[int]int) int {
        		// memo: ключ - сумма, значение - минимальное количество подобранных монет для этой суммы.
            // Нулевой остаток - подобрали комбинацию.
            if remains == 0 {
                return 0
            }
            // Отрицательный остаток - монета больше чем нужно (пропускаем).
            if remains < 0 {
                return math.MaxInt
            }
            // Если уже подобрали для этой суммы - возвращаем (мемоизация).
            if res, ok := memo[remains]; ok {
                return res
            }
            // Минимальная комбинация. Максимальный int будет когда ничего не подобрали.
            minRes := math.MaxInt
            for _, coin := range coins {
                // Монета больше чем сумма - пропускаем.
                if coin > remains {
                    continue
                }
                // Для каждой монеты вызываем рекурсию с остатком.
                res := coinChangeRecur(coins, remains - coin, memo)
                // Подменяем минимальную комбинацию, если необходимо.
                // Добавляем единицу как счетчик использованных монет.
                if res < minRes {
                    minRes = res + 1
                }
            }
            // Запоминаем подобранный вариант для текущей суммы, чтобы не дублировать подсчеты.
            memo[remains] = minRes
        
            return minRes
        }
        ```
        
    - Решение 2. Табуляция. TODO.
    - Неоптимальные решения
        
        Полный перебор через рекурсию (рекурсия без мемоизации).


- **Минимальное количество квадратов чисел** на которые можно **разделить число**.

  [LeetCode: 279. Perfect Squares](https://leetcode.com/problems/perfect-squares/)

  [TODO: решить более оптимально]

    - Условие

      Дано число `n`, нужно разделить его на сумму квадратов меньших чисел. На выходе нужно получить минимальное количество квадратов чисел на которые можно разделить входящее число.

    - Кейсы

      `n=12; res=3 (4+4+4)`

      `n=12; res=2 (9+4)`

      `n=7; res=4 (4+1+1+1)`

      `n=20; res=2 (16+4)`

    - Решение 1 (не оптимальное). [DP: рекурсия с мемоизацией](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21).
        - Визуализация

          ![красный узел - корень;
          синий - узлы, в которые заходим для расчета;
          серый - узлы, в которые зашли, но ветка не результативная (ветка 1,1,4,1 с минимальным количеством квадратов)
          незакрашенные узлы - для них значения уже расчитаны, берем из `memo`](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/IMG_5391_(1).jpg)

          красный узел - корень;
          синий - узлы, в которые заходим для расчета;
          серый - узлы, в которые зашли, но ветка не результативная (ветка 1,1,4,1 с минимальным количеством квадратов)
          незакрашенные узлы - для них значения уже расчитаны, берем из `memo`


        **Сложность: время - ???, память - ???.**
        
        ```go
        func numSquares(n int) int {
            // Массив с квадратами чисел, которые можно использовать.
            var squaresNums []int
            // Последний квадрат не должен превышать входящее число.
            for i := 1; i * i <= n; i++ {
                squaresNums = append(squaresNums, i * i)
            }
        
            // Мапа мемоизации. Будем складывать в нее расчитанные значения.
            // Ключ - число для которого производился расчет, значение - количество квадратных чисел.
            memo := make(map[int]int)
            // Если число 0, то дошли до конца.
            memo[0] = 0
        
            // Рекурсия.
            var numSquaresRec func (n int) int
            numSquaresRec = func(n int) int {
                // Если уже рассчитывали - выходим.
                if res, ok := memo[n]; ok {
                    return res
                }
                // Рассчитываем для каждого квадратного числа рекурсивно.
                for _, sqNum := range squaresNums {
                    // Квадрат больше искомого числа - выходим.
                    if sqNum > n {
                        break
                    }
                    resTmp := numSquaresRec(n - sqNum)
                    // Если еще не рассчитывали такое число, либо расчет меньше чем сохраненный.
                    if memo[n] == 0 || resTmp < memo[n] {
                        memo[n] = resTmp + 1
                    }
                }
        
                return memo[n]
            }
            
            return numSquaresRec(n)
        }
        ```


- Можно ли **разбить строку на слова из набора**

  [LeetCode: 139. Word Break](https://leetcode.com/problems/word-break/)

  [TODO: решить другими способами]

    - Условие

      Дана строка и массив слов. Вернуть `true` если строку можно разбить на слова. Одно слово можно использовать несколько раз для разбивки.

    - Кейсы

      `s="catsanddog"; wordDict=["cat","cats","an","and","dog","dogs"]; res=true`

      `s="catsandog"; wordDict=["cats","and","sand","dog","dogs"]; res=false`

      `s=""aaaaaaaaaaaaaaaab""; wordDict=["aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa"]; res=false`

    - Решение 1: Рекурсия с мемоизацией ([динамическое программирование](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21)).
        - Сложность

          Время: - O(m*m*k). Где m - количество слов, k - средняя длина слова.

          Память - O(n).


        ```go
        func wordBreak(s string, wordDict []string) bool {
            // Мемоизация - сохраняем результат поиска в подстроке.
        		// Возможно, в каких-то случаях массив будет более эффективен.
            // Ключ - индекс в строке, с которого начинается подстрока.
            // Значение - результат (0: не расчитано, 1: можно разбить на слова, -1: нельзя) 
            memo = make(map[int]int, len(s))
        
            return wordBreakRecur(s, wordDict, 0)
        }
        
        // Рекурсия.
        func wordBreakRecur(letters string, words []string, startIdx int) bool {
            // Если расчет уже был, то возвращаем результат.
            if memo[startIdx] != 0 {
                return memo[startIdx] == 1
            }
            // Бежим по словам и ищем слово от текущего индекса в строке.
            // Если слово нашлось, вызываем рекурсию для оставшейся строки.
            for _, word := range words {
                // Индекс подстроки за минусом текущего слова.
                nextWordIdx := startIdx + len(word)
                // Если мы в рамках строки и слово нашлось:
                if nextWordIdx <= len(letters) && letters[startIdx:nextWordIdx] == word {
                    // Если дошли до конца строки - выходим.
                    if nextWordIdx == len(letters) {
                        return true
                    }
                    // Выходим и сохраняем результат, если слова в подстроке нашлись.
                    res := wordBreakRecur(letters, words, nextWordIdx)
                    if res {
                        memo[startIdx] = 1
                        return true
                    }
                }
            }
        
            // Сохраняем результат, что ничего не нашлось
            memo[startIdx] = -1
            return false
        }
        
        var memo map[int]int
        ```
        
    - Решение 2: Табуляция.

- Найти уникальные комбинации чисел дающих в сумме целевое число.

  [LeetCode: 39. Combination Sum](https://leetcode.com/problems/combination-sum/)

    - Условие

      Дано целевое число и массив кандидатов. Вернуть все возможные уникальные комбинации из массива кандидатов так, чтобы в сумме каждая комбинация давала целевое число.

      Кандидат в комбинации может использовать сколько угодно раз.

      Порядок кандидатов не важен.

    - Кейсы

      `candidates = [2,3,6,7]; target = 7; res =``[2,2,3],[7]]`

      `candidates = [2,3,5], target = 8; res =` `[[2,2,2,2],[2,3,3],[3,5]]`

    - Решение 1: [Backtracking](https://www.notion.so/Backtracking-c11e4366b07a44f880d47601a133111b?pvs=21).

      Чтобы избавится от кандидатов - с каждым шагом вглубь итерируемся только по не использованным кандидатам (но включаем текущего кандидата, т.к. одного кандидата можно использовать несколько раз).

      Когда искомая сумма равна нулю (нашли ветку с искомой комбинацией) - возвращаемся, и на каждом шаге рекурсии добавляем текущего кандидата в каждую комбинацию.

        - Визуализация

          ![IMG_5394.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/IMG_5394.jpg)

        - **Сложность**

          Время: - O(n^(t/m + 1)).

          Память: - O(t/m).

          n - количество кандидатов, t - целевое число, m - миниамальное число из кандидатов.


        ```go
        // Backtracking.
        func combinationSum(candidates []int, target int) [][]int {
            return combinationSumRecur(target, candidates, 0)
        }
        
        // Рекурсия.
        func combinationSumRecur(target int, candidates []int, candIdx int) [][]int {
            // Комбинации для текущего числа.
            var res [][]int
            // Чтобы избавится от дублей в каждой рекурсии итерируемся только по оставшимся кандидатам (передаем candIdx).
            for i := candIdx; i < len(candidates); i++ {
                // Если кандидат больше целевой суммы - продолжаем
                if candidates[i] > target {
                    continue
                }
                // Нашли комбинацию - добавляем результат.
                if target == candidates[i] {
                    res = append(res, []int{candidates[i]})
                    continue
                }
                // Рекурсивно ищем в оставшейся сумме с оставшимися кандидатами.
                candCombinations := combinationSumRecur(
                    target - candidates[i],
                    candidates,
                    i,
                )
                // Добавляем каждую комбинацию в результат (плюсуя текущего кандидата).
                for _, candComb := range candCombinations {
                    candComb = append(candComb, candidates[i])
                    res = append(res, candComb)
                }
            }
        
            return res
        }
        ```


- Найти количество уникальных **комбинаций** маршрута от левого верхнего угла **поля (матрицы)** до правого нижнего при возможных движениях или вниз или вправо.

  [LeetCode: 62. Unique Paths](https://leetcode.com/problems/unique-paths)

  [TODO: решить табуляцией.]

    - Условие

      Даны два числа задающих размеры клеточного поля (матрицы). Нужно вернуть количество уникальных комбинаций маршрута от левого верхнего угла поля до правого нижнего. Двигаться можно либо вниз на одну клетку, либо вправо на одну клетку.

    - Кейсы

      `m = 4; n = 6; res = 56;`

      `m = 2; n = 7; res = 7;`

    - Решение 1: [DP: рекурсия с мемоизацией](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21).

      Сложность: время: - O(n*m), память -  O(n*m).

        ```go
        // Рекурсия с мемоизацией.
        func uniquePaths(m int, n int) int {
            // Если уже рассчитывали для этой клетки, то выходим.
            if comb, ok := memo[[2]int{m, n}]; ok {
                return comb
            }
            // Дошли до конечной клетки (правой нижней), значит нашли комбинацию.
            if m == 1 && n == 1 {
                return 1
            }
            // Вышли за рамки поля.
            if m == 0 || n == 0 {
                return 0
            }
            // Движемся вниз.
            down := uniquePaths(m - 1, n)
            // Движемся вправо.
            right := uniquePaths(m, n - 1)
            // Для текущей клетки количество комбинаций будет как сумма комбинаций двух ветвей.
            memo[[2]int{m, n}] = down + right
        
            return down + right
        }
        
        // Мемоизация.
        // Ключ - расположение клетки (m,n), значение - количество комбинаций для этой клетки.
        var memo map[[2]int]int = make(map[[2]int]int)
        ```

    - Объяснения решений

      [Youtube: Задача из Собеседования в Google на Динамическое Программирование: Количество Уникальных Путей](https://www.youtube.com/watch?v=GhiRlhPlJ9Q)


- Найти **минимальную сумму** элементов по **маршрутам** от левого верхнего угла **матрицы** до правого нижнего при возможных **движениях или вниз или вправо**.

  [LeetCode: 64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum)

    - Условие

      Дана матрица. Нужно составить маршрут от левого верхнего угла матрицы до правого нижнего так, чтобы сумма элементов по маршруту была минимальна. Двигаться можно либо вниз на одну клетку, либо вправо на одну клетку.

    - Кейсы

      `grid = [[1,3,1],[1,5,1],[4,2,1]]; res = 7;`

      ![minpath.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/minpath.jpg)

      `grid = [[1,2,3],[4,5,6]]; res = 12;`

    - Решение 1: [DP: рекурсия с мемоизацией](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21).

      **Сложность: время: - O(n*m), память -  O(n*m).** Т.к. мы используем мемоизацию, мы обрабатываем каждый путь один раз.

        ```go
        func minPathSum(grid [][]int) int {
            // Сохраняем просчитанную суммы для конкретного элемента (мемоизация).
            memo = make(map[[2]int]int)
        
            return minPathSumRecur(grid, 0, 0)
        }
        
        // Рекурсия для вычисления суммы элементов по маршруту от текущего элемента.
        func minPathSumRecur(grid [][]int, row int, col int) int {
            // Если уже вычисляли - выходим.
            if sum, ok := memo[[2]int{row, col}]; ok {
                return sum
            }
        
            // Дошли до правого нижнего узла.
            if row == len(grid) - 1 && col == len(grid[0]) - 1 {
                return grid[row][col]
            }
        
            // Сумма элементов по маршруту вниз.
            // Расчитываем только если не вышли за рамки.
            downSum := math.MaxInt
            if row + 1 < len(grid) {
                downSum = minPathSumRecur(grid, row + 1, col)
            }
            // Сумма элементов по маршруту вправо.
            // Расчитываем только если не вышли за рамки.
            rightSum := math.MaxInt
            if col + 1 < len(grid[0]) {
                rightSum = minPathSumRecur(grid, row, col + 1)
            }
            
            // Выбираем минимальную сумму.
            resSum := downSum
            if rightSum < downSum {
                resSum = rightSum
            }
            // Добавляем к сумме текущий элемент.
            resSum += grid[row][col]
            // Сохраняем результат.
            memo[[2]int{row, col}] = resSum
        
            return resSum
        }
        
        var memo map[[2]int]int
        ```

    - Решение 2: [Динамическое программирование](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21).

      Для каждой ячейки вычисляем минимальное значение из предыдущих ячеек, складываем его с текущим и обновляем значение в текущей ячейке.

      Для ячеек в первой строке и в первом столбце суммируем с предыдущим значением.

        - Визуализация

          `grid = [[1,2,3],[4,5,6]];`

          |  | j=0 | j=1 | j=2 |
                      | --- | --- | --- | --- |
          | i=0 | 1 | 2 | 3 |
          | i=1 | 4 | 5 | 6 |

          |  |                    j=0 |                      j=1 |                      j=2 |
                      | --- | --- | --- | --- |
          | i=0 | 1 | =val+[i][j-1]
            =2+1=3 | =val+[i][j-1]
            =3+3=6 |
          |
            i=1 | =val+[i-1][j]
            =4+1=5 | =min(val+[i-1][j],val+[i-1][j])
            =min(5+3,5+5)=8 | =min(val+[i-1][j],val+[i-1][j])
            =min(6+3,5+5)=12 |

      **Сложность: время: - O(n*m), память -  O(1).**

        ```go
        // Динамическое программирование.
        func minPathSum(grid [][]int) int {
            rowsNum := len(grid)
            colsNum := len(grid[0])
        	for row := 0; row < rowsNum; row++ {
        		for col := 0; col < colsNum; col++ {
        			switch {
                        // Для первой колонки складываем текущее значение и предыдущее значение в колонке.
        			case row != 0 && col == 0:
        				grid[row][col] += grid[row - 1][col]
                        // Для первой строки складываем текущее значение и предыдущее значение в строке.
        			case row == 0 && col != 0:
        				grid[row][col] += grid[row][col - 1]
                        // Для остальных ячеек складываем текущее значение с минимальным значением в предыдущей колонке или в предыдущей строке.
        			case row != 0 && col != 0:
        				grid[row][col] = min(
        					grid[row][col] + grid[row - 1][col],
        					grid[row][col] + grid[row][col - 1],
        				)
        			}
        
        		}
        	}
        	return grid[rowsNum - 1][colsNum - 1]
        }
        
        func min(a, b int) int {
        	if a < b {
        		return a
        	}
        	return b
        }
        ```

- Найти **количество комбинаций кодирования числа в буквы**

  [LeetCode: 91. Decode Ways](https://leetcode.com/problems/decode-ways)

  [TODO: решить другими способами.]

    - Условие

      Дано число. Вернуть количество комбинаций как можно декодировать число в буквы.

      Маппинг буквы в число:

      `1 -> A
      2 -> B
      ...
      26 -> Z`

    - Кейсы

      `s = "12"; res = 2;` `12` можно декодировать как `AB` (1,2) или `L` (12).

      `s = "226"; res = 3;` `226` можно декодировать как `BZ` (2,26) или `VF` (22,6) или `BBF` (2,2,6).

      `s = "06"; res = 0;` лидерующий ноль нельзя отбросить.

      `s = "12211321"; res = 26;`

    - Решение 1: [DP: рекурсия с мемоизацией](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21).

      Сложность: время: - O(n), память -  O(n).

        ```go
        // По факту нам нужно вычислить количество раз когда мы дойдем до конца строки разными способами.
        func numDecodings(s string) int {
            // Сохраняем результаты. Ключ - подстрока, значение количество комбинаций.
            memo = make(map[string]int)
        
            return numDecodingsRecur(s)
        }
        
        // Рекусия.
        func numDecodingsRecur(s string) int {
            // Если уже вычислили - возвращаем.
            if comb, ok := memo[s]; ok {
                return comb
            }
            // Дошли до конца строки - +1 комбинация.
            if len(s) == 0 {
                return 1
            }
            // Если перед числом есть лидирующий ноль, то пропускаем комбинацию,
            // ноль актуален только в рамках десяток.
            if s[0] == '0' {
                return 0
            }
            // Комбинации для числа до 9.
            comb := numDecodingsRecur(s[1:])
            // Комбинации для числа от 10 до 26.
            if len(s) >= 2 && (s[0] == '1' || (s[0] == '2' && s[1] <= '6')) {
                comb += numDecodingsRecur(s[2:])
            }
            // Сохраняем расчет.
            memo[s] = comb
        
            return comb
        }
        
        var memo map[string]int
        ```


- Найти **подмассив с максимальной суммой** элементов в неотсортированном массиве

  [LeetCode: 53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)

    - Условие

      Дан массив с неотсортированными числами. Найти подстроку с максимальной суммой элементов и вернуть максимальную сумму элементов в этой подстроке.

    - Кейсы

      `nums = [-2,1,-3,4,-1,2,1,-5,4]; res = 6;`  - подмассив `[4,-1,2,1]`

      `nums = [1]; res = 1;`

      `nums = [5,4,-1,7,8]; res = 23;` - подмассив `[5,4,-1,7,8]`

    - Решение 1 (оптимальное): [Алгоритм Кадана](https://www.notion.so/draft-ab0fdbfb04f240ac9f3e97118dfe6692?pvs=21) ([динамическое программирование](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21)).
        - Визуализация

          ![IMG_5420.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/IMG_5420.jpg)


        Считаем **[префиксную сумму](https://www.notion.so/draft-f47ce8aefd4c4e06b3583f3a5487c470?pvs=21)**, но на каждом элементе сравниваем ее с текущим элементом. Если элемент больше префиксной суммы, то заменяем префиксную сумму текущим элементом.
        Т.е. логично, что если сумма предыдущих элементов меньше чем текущий элемент, то максимальная сумма будет равна текущему элементу.
        
        **Сложность: время: - O(n), память -  O(1).**
        
        ```go
        func maxSubArray(nums []int) int {
            // Максимальную сумму сразу установим в значение первого элемента,
            // т.к. по условию должен быть хотя бы один элемент.
            // Так же это решает кейс nums=[-1].
            maxSum := nums[0]
            // Текущая сумма.
            curSum := nums[0]
            // Начнем со второго элемента, первый уже обработан.
            for i := 1; i < len(nums); i++ {
                // Увеличиваем текущую сумму.
                curSum += nums[i]
                // Если значение элемента больше текущей суммы, то максимальная сумма будет
                // равна значению текущего элемента.
                if nums[i] > curSum {
                    curSum = nums[i]
                }
                // Подменяем максимальную сумму, если необходимо.
                if curSum > maxSum {
                    maxSum = curSum
                }
            }
        
            return maxSum
        }
        ```
        
    - Решение 2: Рекурсия (TODO).

- Найти **все пути** от корня до листьев **бинарного дерева** когда **сумма всех узлов** по пути будет равна заданному числу

  [LeetCode: 113. Path Sum II](https://leetcode.com/problems/path-sum-ii)

    - Условие

      Дано [бинарное дерево](https://www.notion.so/325fbdebbd614bf8b78bcf91892c74b5?pvs=21) в виде [связного списка](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21). Найти все пути от корня до листьев когда сумма всех узлов по пути будет равна заданному числу.

    - Кейсы
        - `root = [5,4,8,11,null,13,4,7,2,null,null,5,1]; targetSum = 22; res = [[5,4,11,2],[5,8,4,5]];`

          `5 + 4 + 11 + 2 = 22`
          `5 + 8 + 4 + 5 = 22`

          ![pathsumii1.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/pathsumii1.jpg)

        - `root = [1,2,3]; targetSum = 5; res = [];`

          ![pathsum2.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/pathsum2.jpg)

    - Решение 1 (объемное). [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) через стэк, реализованный связным списком.

      **Сложность: время - O(n^2), память - O(n).**

        ```go
        func pathSum(root *TreeNode, targetSum int) [][]int {
            // Пустое дерево сложно обработать в основном алгоритме.
            if root == nil {
                return nil
            }
            // Стэк для хранения узлов на обработку.
            stack := []nodeWrap{{node: root, sum: root.Val, values: []int{root.Val}}}
            // Результирующий массив.
            var res [][]int
            // Пока в стэке есть узлы.
            for len(stack) > 0 {
                // Получаем текущий (обрабатываемый узел) из стэка.
                node := stack[len(stack) - 1]
                // Уменьшаем стэк.
                stack = stack[:len(stack) - 1]
                // Если текущий узел листовой нужно проверить сумму значений до корня.
                isLeaf := true
                // Левый узел.
                if node.node.Left != nil {
                    // Копируем слайс, иначе при обработке правого узла мы подменим последний элемент у левого узла (массив под слайсом один).
                    values := make([]int, len(node.values))
                    copy(values, node.values)
                    // Добавляем в стэк.
                    stack = append(
                        stack,
                        nodeWrap{
                            node: node.node.Left,
                            sum: node.sum + node.node.Left.Val,
                            values: append(values, node.node.Left.Val),
                        },
                    )
                    isLeaf = false
                }
                if node.node.Right != nil {
                    values := make([]int, len(node.values))
                    copy(values, node.values)
                    // Добавляем в стэк.
                    stack = append(
                        stack,
                        nodeWrap{
                            node: node.node.Right,
                            sum: node.sum + node.node.Right.Val,
                            values: append(values, node.node.Right.Val),
                        },
                    )
                    isLeaf = false
                }
                // Если узел листовой, добавляем в результирующий массив значения всех узлов до корня.
                if isLeaf && node.sum == targetSum {
                    res = append(res, node.values)
                }
            }
        
            return res
        }
        
        // Обертка для узла.
        type nodeWrap struct {
            node *TreeNode
            // Сумма значений всех родительских узлов до корня.
            sum int
            // Массив значений всех родительских узлов до корня.
            values []int
        }
        
        /**
         * Definition for a binary tree node.
         * type TreeNode struct {
         *     Val int
         *     Left *TreeNode
         *     Right *TreeNode
         * }
         */
        ```

    - **Решение 2 (простое). Обход в глубину через рекурсию.**

      **Сложность: время - O(n^2), память - O(n).**

        ```go
        // Обход в глубину через рекурсию.
        func pathSum(root *TreeNode, targetSum int) [][]int {
            // Результирующий двумерный массив значений узлов - массив путей.
            var res [][]int
            // Отдельно обработаем пустое дерево.
            if root == nil {
                return res
            }
            // Остаток искомой суммы для текущего поддерева за вычетом каждого узла в пути.
            sumResidue := targetSum
            // Если дошли до листа.
            if root.Left == nil && root.Right == nil {
                // Если остаток искомой суммы совпадает со значением элемента,
                // то мы нашли искомую ветку (путь) - добавляем в результирующий массив.
                if sumResidue == root.Val {
                    return append(res, []int{ root.Val })
                }
                return res
            }
            // Остаток искомой суммы для поддеревьев.
            sumResidue -= root.Val
            // Вызываем рекурсию для обоих поддеревьев.
            // Т.к. результирующий массив в рекурсии двумерный (массив путей), нам нужно к каждому пути добавить текущее значение узла.
            // Если в каких-то дочерних узлах (в каких-то путях) сумма не сошлась,
            // то у нас будет не будет этих путей.
            // Левое поддерево.
            subtreePaths := pathSum(root.Left, sumResidue)
            for _, path := range subtreePaths {
                res = append(res, append([]int{ root.Val}, path... ))
            }
            // Правое поддерево.
            subtreePaths = pathSum(root.Right, sumResidue)
            for _, path := range subtreePaths {
                res = append(res, append([]int{ root.Val}, path... ))
            }
        
            return res
        }
        
        /**
         * Definition for a binary tree node.
         * type TreeNode struct {
         *     Val int
         *     Left *TreeNode
         *     Right *TreeNode
         * }
         */
        ```


- Найти количество **всех возможные** подмассивов, чтобы **сумма** чисел в подмассиве была равна `k`

  [LeetCode: 560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k)

    - Условие

      Дан массив целых чисел `nums` и целое число `k`. Найти все возможные подмассивы, такие что сумма чисел каждого подмассива равна `k`.

    - Кейсы

      `nums = [1,1,1], k = 2; res = 2;`

      `nums = [1,2,3], k = 3; res = 2;`

      `nums = [1,2,-3,3,5,1,1,1], k = 3; res = 4;`

    - Решение 1 (оптимальное). [Префиксная сумма](https://www.notion.so/draft-f47ce8aefd4c4e06b3583f3a5487c470?pvs=21) и [хэш-таблица](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21).
        - Примеры

          `nums = [1,2,-3,3,5,1,1,1], k = 3;`

          `nums=[**1**,2,-3,3,5,1,1,1], sum=1, res=0, sumToCount=[0=>1,1=>1];` - `1-3=-2`

          `nums=[1,**2**,-3,3,5,1,1,1], sum=3, **res=1**, sumToCount=[0=>1,1=>1,**3=>1**];` - `3-3=**0**`

          `nums=[1,2,**-3**,3,5,1,1,1], sum=0, res=1, sumToCount=[**0=>2**,1=>1,3=>1];` - `0-3=-3`

          `nums=[1,2,-3,**3**,5,1,1,1], sum=3, **res=3**, sumToCount=[0=>2,1=>1,**3=>2**];` - `3-3=**0**`

          `nums=[1,2,-3,3,**5**,1,1,1], sum=8, res=3, sumToCount=[0=>2,1=>1,3=>2,**8=>1**];` - `8-3=5`

          `nums=[1,2,-3,3,5,**1**,1,1], sum=9, res=3, sumToCount=[0=>2,1=>1,3=>2,8=>1,**9=>1**];` - `9-3=6`

          `nums=[1,2,-3,3,5,1,**1**,1], sum=10, res=3, sumToCount=[0=>2,1=>1,3=>2,8=>1,9=>1,**10=>1**];` - `10-3=7`

          `nums=[1,2,-3,3,5,1,1,**1**], sum=11, **res=4**, sumToCount=[0=>2,1=>1,3=>2,8=>1,9=>1,10=>1,**11=>1**];` - `11-3=**8**`


        **Сложность: время - O(n), память - O(n).**
        
        ```go
        func subarraySum(nums []int, k int) int {
            // Мапа с суммами. Ключ - сумма, значение - повторяемость этой суммы.
            // Сразу добавим сумму, когда sum-k=0, чтобы не делать лишний if.
            sumToCount := map[int]int{0: 1}
            // Текущая префиксная сумма
            sum := 0
            // Результирующее количество подмассивов.
            res := 0
        
            for _, num := range nums {
                // Увеличиваем префиксную сумму.
                sum += num
                // Если уже встречалась недостающая нам сумма, то добавляем ее повторяемость.
                res += sumToCount[sum-k]
                // Увеличиваем повторяемость для текущей суммы.
                sumToCount[sum]++
            }
            
            return res
        }
        ```
        
    - Решение 2. Перебор.
        
        **Сложность: время - O(n^2), память - O(1).**
        
        ```go
        func subarraySum(nums []int, k int) int {
            // Результирующая сумма
            res := 0
            // Для каждого числа перебираем подмассивы от этого числа до конца массива.
            for i, _ := range nums {
                // Текущая сумма элементов во вложенном цикле.
                sum := 0
                // Начинаем с текущего числа и перебираем все возможные подмассивы до конца массива.
                for j := i; j < len(nums); j++ {
                    sum += nums[j]
                    // Если суммы совпадают увеличиваем счетчик.
                    if sum == k {
                        res++
                    }
                }
            }
        
            return res
        }
        ```


- Найти **сумму минимальных чисел** во всех возможных **подмассивах**

  [LeetCode: 907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums)

  [TODO: решить через монотонный стек.]

    - Условие


    - Кейсы
        
        `arr = [3,1,2,4]; res = 17;`  - подмассивы: `[3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]`, минимумы подмассивов: `3, 1, 2, 4, 1, 1, 2, 1, 1, 1`
        
        `arr = [11,81,94,43,3]; res = 444;`
        
    - Решение 1 (долгое): Полный перебор.
        
        **Сложность: время: - ???, память -  ???.**
        
        ```go
        func sumSubarrayMins1(arr []int) int {
            sum := 0
            totalMin := 0
            for pos1, num := range arr {
                // запоминаем минимум
                currentMin := num
                // бежим по оставшимся числам справа, т.к. для всех чисел слева мы уже просуммировали минимумы
                for pos2 := pos1; pos2 < len(arr); pos2++ {
                    // с каждой итерацией приращиваем массив для текущего числа (num)
                    // формируем минимум на основе текущего минимума и очередного числа
                    // потому как левая часть массива не меняется, минимум для нее уже известен
                    // таким образом мы не вычисляем минимум для всего массива каждый раз
                    if arr[pos2] < currentMin {
                        currentMin = arr[pos2]
                    }
                    // суммируем минимум
                    sum += currentMin
                    sum %= 1000000007
                }
                // вычисляем минимум для всех элементов массива отдельно
                if num < totalMin {
                    totalMin = num
                }
            }
            sum += totalMin
            sum %= 1000000007
            
            return sum
        }
        ```

- Найти все **комбинации** маппинга **числа** на **буквы** как на **телефоне**

  [LeetCode: 17. Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number)

    - Условие

      Дано число в виде строки `digits`. Вернуть количество комбинаций как можно смаппить число в буквы.

        - Маппинг буквы в число

          `'2': "abc",`

          `'3': "def",`

          `'4': "ghi",`

          `'5': "jkl",`

          `'6': "mno",`

          `'7': "pqrs",`

          `'8': "tuv",`

          `'9': "wxyz",`

          ![1200px-telephone-keypad2svg.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/1200px-telephone-keypad2svg.png)

    - Кейсы

      `s = "12"; res = 2;` `12` можно декодировать как `AB` (1,2) или `L` (12).

      `s = "226"; res = 3;` `226` можно декодировать как `BZ` (2,26) или `VF` (22,6) или `BBF` (2,2,6).

      `s = "06"; res = 0;` лидерующий ноль нельзя отбросить.

      `s = "12211321"; res = 26;`

    - **Решение 1: Backtracking.**

      **Сложность: время: - O(4^n*n), память -  O(n).** 4 потому что это максимальное количество букв на число (числа `7`, `9`).

        ```go
        // Рекурсия с перебором комбинаций.
        func letterCombinations(digits string) []string {
            // Если цифр нет - выходим.
            if len(digits) == 0 {
                return nil
            }
            // Результирующий массив комбинаций.
            var res []string
            // Текущие буквы, соответствующие первой цифре из массива цифр.
            curLetters := digitToLetter[digits[0]]
            // Рекурсивно сформированные комбинации для последующих цифр.
            var nestedLetters []string
            if len(digits) > 1 {
                nestedLetters = letterCombinations(digits[1:])
            }
            // Для каждой буквы, соответствующей текущей цифре.
            for i := 0; i < len(curLetters); i++ {        
                // Если есть рекурсивные комбинации, то они обогащаются текущей буквой.
                for j := 0; j < len(nestedLetters); j++ {
                    res = append(res, string(curLetters[i]) + nestedLetters[j])
                }
                // Если нет рекурсивных комбинаций, каждая текущая буква будет комбинацией.
                if len(nestedLetters) == 0 {
                    res = append(res, string(curLetters[i]))
                }
            }
        
            return res
        }
        
        // Маппинг цифры на буквы.
        var digitToLetter = map[byte]string{
            '2': "abc",
            '3': "def",
            '4': "ghi",
            '5': "jkl",
            '6': "mno",
            '7': "pqrs",
            '8': "tuv",
            '9': "wxyz",
        }
        ```


- Вычислить **общее время обработки** массива **задач** на `**k` обработчиках** не учитывая порядок задач

  [LeetCode: 1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/)

  [TODO: решить (сложное решение)]

    - Условие

      Дан целочисленный неотсортированный массив `jobs` и целочисленное `k`. В `jobs` хранится время, необходимое для обработки каждой задачи. Количество работников задано в `workers`. Одна задача может обрабатываться одним работником. Задачи могут обрабатываться в любом порядке. Т.е. любую задачу можно назначить любому работнику. Нужно найти минимальное время необходимое для обработки всех задач параллельно.

      `1 <= k <= len(jobs) <= 12`

    - Кейсы

      `jobs = [1,1,1,1,1], k = 1; res = 5;`

      `jobs = [2,2,1,2,1], k = 2; res = 4;`

      `jobs = [5, 4, 2, 7, 8, 2, 6], k = 3; res = 13;`

      `jobs = [1, 2, 4, 7, 8], k = 2; res = 13;`

      `jobs = [5], k = 2; res = 5;`

      `jobs = [], k = 2; res = 0;`

    - Особенности решений
        - Ссылки

          [Youtube: Happy Coding: LeetCode 1723. Find Minimum Time to Finish All Jobs](https://www.youtube.com/watch?v=Be4s1gRx7Vc)

          [1723. Find Minimum Time to Finish All Jobs - LeetCode Solutions](https://walkccc.me/LeetCode/problems/1723/)

          [https://github.com/doocs/leetcode/blob/main/solution/1700-1799/1723.Find Minimum Time to Finish All Jobs/Solution.go](https://github.com/doocs/leetcode/blob/main/solution/1700-1799/1723.Find%20Minimum%20Time%20to%20Finish%20All%20Jobs/Solution.go)


        В сути нам нужно найти все комбинации и вычислить из них минимальную по общему времени. Если количество задач и работников не может превышать `12`, то максимальное количество комбинаций - `12^12`. Поэтому, нам нужно на этапе обхода комбинаций отбросить как можно больше ветвей.
        
    - Решение 1. TODO.
        
        **Сложность: время - ???, память - ???.**
        
        ```go
        
        ```


- Найти **все возможные палиндромы подстрок** в строке

  [LeetCode: 131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning)

    - Условие

      Дано строка `s`. Найти все возможные подстроки, которые являются палиндромами.

      Строка `s` состоит из английских букв в нижнем регистре.

    - Кейсы

      `s = "aab"; res = [["a","a","b"],["aa","b"]];`

      `s = "a"; res = [["a"]];`

    - Решение 1 (быстрое): [Backtracking](https://www.notion.so/Backtracking-c11e4366b07a44f880d47601a133111b?pvs=21).

      [TODO: кажется, если прокидывать результирующий массив в рекурсии будет быстрее.]

        - Визуализация

          ![time_complexity.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/time_complexity.png)


        **Сложность: Время - O(n*n^2), память O(n).**
        
        ```go
        // Backtracking.
        // TODO: кажется, если прокидывать результирующий массив в рекурсии будет быстрее.
        func partition(s string) [][]string {
            // Если букв в строке не осталось, то точно палиндром.
            if len(s) == 0 {
                return [][]string{{}}
            }
            // Если одна буква в строке, то точно палиндром.
            if len(s) == 1 {
                return [][]string{{s}}
            }
            // Результирующий массив с палиндромами.
            res := make([][]string, 0, len(s))
            // Бежим по строке (строка на каждой рекурсии уменьшается слева)
            for i := 0; i < len(s); i++ {
                // Кандидат для палиндрома
                // Начинаем с первой буквы, на каждой итерации добавляем букву справа.
                candidate := s[:i+1]
                // Если кандидат палиндром:
                if isPalindrome(candidate) {
                    // Вызываем рекурсию для строки уменьшенной слева.
                    palindromsSets := partition(s[i+1:])
                    for _, palindroms := range palindromsSets {
                        // Добавляем к палиндромам из рекурсии текущий палиндром.
                        palindromsWithCandidate := append([]string{candidate}, palindroms...)
                        // Добавляем набор палиндромов в результирующий массив.
                        res = append(res, palindromsWithCandidate)
                    }
                }
            }
            
            return res
        }
        // Является ли строка палиндромом.
        func isPalindrome(s string) bool {
            // Левый бегунок бежит с начала строки, правый с конца.
            leftIdx, rightIdx := 0, len(s)-1
            // Пока бегунки не встретятся.
            for leftIdx < rightIdx {
                // Сравниваем буквы.
                if s[leftIdx] != s[rightIdx]{
                    return false;
                }
                // Увеличиваем бегунки.
                leftIdx++
                rightIdx--
            }
            // Если дошли сюда - буквы симметричны.
            return true;
        }
        ```
        
    - Решение 2 (быстрое): [Backtracking](https://www.notion.so/Backtracking-c11e4366b07a44f880d47601a133111b?pvs=21) + [динамическое программирование](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21). TODO.
        
        **Сложность: Время - O(n*n^2), память O(n).**
        
        ```go
        
        ```


- Сгенерировать **все возможные** **правильные скобочные последовательности** с учетом максимальной длины последовательности

  [LeetCode: 22. Generate Parentheses](https://leetcode.com/problems/generate-parentheses)

    - Условие

      Дано число `n` - максимальное количество пар скобочек. Необходимо сгенерировать все возможные правильные скобочные последовательности с длиной `n * 2`.

    - Кейсы

      `n = 3; res = ["((()))","(()())","(())()","()(())","()()()"];`

      `n = 1; res = ["()"];`

    - **Решение 1 (простое, быстрое). [Backtracking](https://www.notion.so/Backtracking-c11e4366b07a44f880d47601a133111b?pvs=21).**

      В рекурсии есть счетчики: количество открытых скобок, количество скобок для закрытия, количество проставленных скобок всего. Рассматриваем два случая. Можем поставить закрытую скобку если у нас есть хоть одна открытая. Можем поставить закрытую, если счетчик скобок для закрытия не больше n. Достигаем дна, когда количество проставленных скобок = `n*2`.

        - Пример

          `n = 2`

          ![5.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/5.png)


        **Сложность: время - O(4^n/sqrt(n)), память - O(n).**
        
        ```go
        // Backtracing
        func generateParenthesis(n int) []string {
        	return backtracking([]byte{}, n * 2, 0, 0)
        }
        
        // brackets - текущий массив байт скобочек
        // maxCount - максимальное количество скобочек (n * 2)
        // openedCount - количество открытых скобочек
        // toCloseCount - количество скобочек, которые надо закрыть
        func backtracking(brackets []byte, maxCount int, openedCount int, toCloseCount int) []string {
        	// Достигли передела длины - возвращаем текущую послежовательность.
        	if len(brackets) == maxCount {
        		return []string{string(brackets)}
        	}
        	var res []string
        	// Чтобы поставить закрытую, нужно, чтобы была хоть одна открытая.
        	if openedCount > 0 {
        		brackets = append(brackets, ')')
        		// количество закрытых не изменилось
        		for _, recurRes := range backtracking(brackets, maxCount, openedCount - 1, toCloseCount) {
        			res = append(res, recurRes)
        		}
        		// Убираем последнюю добавленную открытую скобку, чтобы не копировать массив.
        		brackets = brackets[:len(brackets) - 1]
        	}
        	// Чтобы поставить открытую, нужно, чтобы количество открытых не превышало максимум открытых-закрытых.
        	if toCloseCount < maxCount / 2 {
        		brackets = append(brackets, '(')
        		for _, recurRes := range backtracking(brackets, maxCount, openedCount + 1, toCloseCount + 1) {
        			res = append(res, recurRes)
        		}
        		// Убираем последнюю добавленную открытую скобку, чтобы не копировать массив.
        		brackets = brackets[:len(brackets) - 1]
        	}
        
        	return res
        }
        ```
        
    - Решение 2. Разделяй и властвуй. TODO
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        
        ```


## Связные списки

- Смержить два отсортированных односвязных списка

  [LeetCode: 21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)

    - Условие

      Даны два отсортированных односвязных списка. Вернуть список, в котором будут отсортированы элементы из входящих списков.

    - Кейсы

      `list1 = [1,2,4], list2 = [1,3,4]; res =` `[1,1,2,3,4,4]`

    - Решение 1 (оптимальное): Итерируемся по обоим спискам одновременно и сравниваем элементы.

      Сложность: Время - O(n+m), память O(1).

        ```go
        func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
            // Результирующий список (стартовый узел). Первый узел общего списка.
            var resList *ListNode
            // Текущий узел общего списка (по нему итерируемся).
            var curList *ListNode
            // Пока оба входящих списка не пустые.
            for list1 != nil || list2 != nil {
                // Если второй список закончился, либо первый элемент меньше второго.
                if list2 == nil || (list1 != nil && list1.Val < list2.Val) {
                    // Добавляем первый узел в текущий список и итерируем первый узел.
                    if curList != nil {
                        curList.Next = list1
                    }
                    curList = list1
                    list1 = list1.Next
                } else {
                    // Добавляем второй узел в текущий список и итерируем второй узел.
                    if curList != nil {
                        curList.Next = list2
                    }
                    curList = list2
                    list2 = list2.Next
                }
                // Назначаем начало результирующего списка.
                if resList == nil {
                    resList = curList
                }
            }
        
            return resList
        }
        
        /**
         * Definition for singly-linked list.
         * type ListNode struct {
         *     Val int
         *     Next *ListNode
         * }
         */
        ```

    - Решение 2: Рекурсия.

      Сложность: Время - O(n+m), память O(n+m).

        ```go
        func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
            // Если первый список пуст, возвращаем элемент второго списка.
        	if l1 == nil {
        		return l2
        	}
            // Если второй список пуст, возвращаем элемент первого списка.
        	if l2 == nil {
        		return l1
        	}
            // Если элемент первого списка меньше.
            // Переходим к другому элементу первого списка.
            // Возвращаем элемент первого списка.
        	if l1.Val < l2.Val {
        		l1.Next = mergeTwoLists(l1.Next, l2)
        		return l1
        	}
            // Если элемент второго списка меньше.
            // Переходим к другому элементу второго списка.
            // Возвращаем элемент второго списка.
        	l2.Next = mergeTwoLists(l1, l2.Next)
        	return l2
        }
        
        /**
         * Definition for singly-linked list.
         * type ListNode struct {
         *     Val int
         *     Next *ListNode
         * }
         */
        ```


- **Сложить два числа** представленных в виде **связных списков**

  [LeetCode: 2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers)

    - Условие

      Даны два неотсортированных односвязных списка. Каждый элемент списка это цифра (0-9). Каждый список играет роль числа, голова списка это наименьший разряд (перевернутое число). Необходимо сложить числа, которыми являются списки в новый список.

      (3←4←2)+(4←6←5)=8←0←7

    - Кейсы
        - `l1 = [2,4,3]; l2 = [5,6,4]; res = [7,0,8];` - `342 + 465 = 807`

          ![addtwonumber1.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/addtwonumber1.jpg)


        `l1 = [0]; l2 = [0]; res = [0];`
        
        `l1 = [9,9,9,9,9,9,9]; l2 = [9,9,9,9]; res = [8,9,9,9,0,0,0,1]`
        
    - Решение 1: Сложение столбиком в цикле.
        - Визуализация
            
            ![2_add_two_numbers.svg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/2_add_two_numbers.svg)
            
        
        **Сложность: Время - O(max(n,m)), память O(1).**
        
        ```go
        // Сложение столбиком.
        func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
            // Цифра, которая переносится в старший разряд при сумме большей 9
            // (когда получаются две цифры). Назовем переносимый десяток.
            highDigit := 0
            // Результирующий список (начало).
            var l3 *ListNode
            // Ссылка на предыдущий элемент, чтобы можно было назначить ссылку на следующий.
            var l3Prev *ListNode
            // Пока хотя бы один из списков не пустой, либо остался переносимый десяток. 
            for l1 != nil || l2 != nil || highDigit > 0 {
                // Значение из первого списка, если он не пустой.
                val1 := 0
                if l1 != nil {
                    val1 = l1.Val
                    // Передвигаем бегунок - список больше не понадобится.
                    l1 = l1.Next
                }
                // Значение из второго списка, если он не пустой.
                val2 := 0
                if l2 != nil {
                    val2 = l2.Val
                    // Передвигаем бегунок - список больше не понадобится.
                    l2 = l2.Next
                }
                // Сумма двух цифр из обоих списков и переносимого остатка.
                sum := val1 + val2 + highDigit
                // Вычисляем текущую цифру (без переносимого остатка).
                curDigit := sum % 10
                // Если есть переносимый остаток - переопределяем его, если нет - обнуляем.
                if sum >= 10 {
                    highDigit = (sum - curDigit) / 10
                } else {
                    highDigit = 0
                }
                // Формируем текущую ноду.
                l3Cur := &ListNode{Val: curDigit}
                // Если это первая итерация - заполняем начало списка и предыдущий узел.
                if l3 == nil {
                    l3 = l3Cur
                    l3Prev = l3Cur
                } else {
                    // Заполняем ссылку на текущий узел из предыдущего узла
                    // и подменяем предыдущий узел.
                    l3Prev.Next = l3Cur
                    l3Prev = l3Cur
                }
            }
        
            return l3
        }
        
        /**
         * Definition for singly-linked list.
         * type ListNode struct {
         *     Val int
         *     Next *ListNode
         * }
         */
        ```
        
    - Решение 2: Сложение столбиком через рекурсию. TODO.
    - **Усложнение: списки это числа в прямом порядке.**
        
        [https://leetcode.com/problems/add-two-numbers-ii/](https://leetcode.com/problems/add-two-numbers-ii/)
        
        (3→4→2)+(4→6→5)=8→0→7
        
        Необходимо сначала развернуть списки.

- Удалить n-ый узел с конца односвязного списка.

  [LeetCode: 19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list)

    - Условие

      Дан односвязный список. Нужно удалить n-ый узел с конца списка.

    - Кейсы
        - `list = [1,2,3,4,5]; n = 2; res = [1,2,3,5];`

          ![remove_ex1.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/remove_ex1.jpg)


        `list = [1]; n = 1; res = [];`
        
        `list = [1,2]; n = 1; res = [1];`
        
        `list = [1,2]; n = 2; res = [2];`
        
    - Решение 1 (оптимальное): Два указателя.
        
        Чтобы добраться с конца списка до узла end-n нужно сделать столько же итераций, как добираться до узла start+n с начала списка.
        
        - Визуализация
            
            ![IMG_5418.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/IMG_5418.jpg)
            
        
        **Сложность: Время - O(l), память O(1), где l - количество узлов в списке.**
        
        ```go
        func removeNthFromEnd(head *ListNode, n int) *ListNode {
            // Фейковый узел, который стоит до корневого узла.
            // Нужен для кейса: head = [1,2]; n = 2; res = [2]
            // Т.е. этот узел нужен, когда нужно убрать корневой узел.
            fake := &ListNode{Next: head}
            // Правый указатель, сначала добирается до start+n узла.
            right := fake
            // Нам нужно
            for i := 0; i < n; i ++ {
                right = right.Next
            }
            // Левый указатель, добирается сначала до end-n узла.
            left := fake
            for right != nil && right.Next != nil {
                right = right.Next
                left = left.Next
            }
            // Убираем end-n узел.
            left.Next = left.Next.Next
        
            return fake.Next
        }
        
        /**
         * Definition for singly-linked list.
         * type ListNode struct {
         *     Val int
         *     Next *ListNode
         * }
         */
        ```

- Является ли **список** **закольцованным**

  [LeetCode: 141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)

    - Условие

      Дан односвязный список. Нужно проверить, является ли список закольцованным.

    - Кейсы
        - `head = [3,2,0,-4]; res = true;`

          ![circularlinkedlist.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/circularlinkedlist.png)

        - `head = [1,2]; res = true;`

          ![circularlinkedlist_test2.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/circularlinkedlist_test2.png)


        `head = [1]; res = false;`
        
    - Решение 1 (оптимальное): [Метод черепахи и зайца](https://www.notion.so/ff80023a0e594ca7ab5a0208c36873e9?pvs=21).
        
        **Сложность: Время - O(n), память O(1).**
        
        ```go
        func hasCycle(head *ListNode) bool {
            // Если список пустой или нет второго узла - выходим.
            if head == nil || head.Next == nil {
                return false
            }
            // Медленный (черепаха) и быстрый (заяц) указатели.
            slow := head
            fast := head
            for {
                // Если медленный или быстрый дошел до конца - выходим.
                if fast.Next == nil || fast.Next.Next == nil || slow.Next == nil {
                    return false
                }
                // Перемещаем медленный на один узел, быстрый на два узла.
                fast = fast.Next.Next
                slow = slow.Next
                // Быстрый догнал медленного - есть кольцо.
                if slow == fast {
                    return true
                }
            }
        }
        
        type ListNode struct {
        	Val int
        	Next *ListNode
        }
        ```
        
    - Решение 2: [Хэш-таблица](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21). TODO.
        
        **Сложность: Время - O(n), память O(n).**
        
        ```go
        
        ```


- **Развернуть односвязный список**

  [LeetCode: 206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)

    - Условие

      Дан односвязный список. Вернуть развернутый список.

      ![rev1ex1.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/rev1ex1.jpg)

    - Кейсы
        - `head = [1,2,3,4,5]; res = [5,4,3,2,1];`

          ![rev1ex1.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/rev1ex1%201.jpg)

        - `head = [1,2]; res = [2,1];`

          ![rev1ex2.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/rev1ex2.jpg)


        `head = []; res = [];`
        
    - Решение 1 (оптимальное): Цикл.
        
        Итеративно разворачиваем текущий список. Меняем ссылку следующего узла на предыдущий узел.
        
        **Сложность: Время - O(n), память O(1).**
        
        ```go
        func reverseList(head *ListNode) *ListNode {
            // Пустой список легче обработать сразу
            if head == nil {
                return nil
            }
        
            // Текущий обрабатываемый узел.
            cur := head.Next
            // Предыдущий узел.
            prev := head
            // Начинаем сразу со второго узла в качестве текущего,
            // поэтому зануляем у предыдущего (корневого) узла ссылку на второй узел.
            prev.Next = nil
            // Итерируемся, пока не достигнем конца списка.
            for cur != nil {
                // Нам нужен следующий узел, чтобы потом на него сдвинуться.
                next := cur.Next
                // У текущего узла меняем ссылку на предыдущий.
                cur.Next = prev
                // Смещаем предыдущий узел на текущий.
                prev = cur
                // Смещаем текущий узел на следующий.
                cur = next
            }
        
            return prev
        }
        
        type ListNode struct {
        		Val int
        		Next *ListNode
        }
        ```
        
    - Решение 2: Рекурсия. TODO.
        
        **Сложность: Время - O(n), память O(n).**
        
        ```go
        
        ```


- **Является** ли односвязный **список** палиндромом

  [LeetCode: 234. Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list)

    - Условие

      Дан односвязный список с числовыми значениями. Проверить, является ли список палиндромом.

    - Кейсы
        - `head = [1,2,2,1]; res = true;`

          ![pal1linked-list.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/pal1linked-list.jpg)

        - `head = [1,2]; res = false;`

          ![pal2linked-list.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/pal2linked-list.jpg)

    - Решение 1 (оптимальное): Найти середину, развернуть половину списка и сравнить [двумя указателями](https://www.notion.so/draft-278415d3ec1246ff9b5b016795685ef8?pvs=21).
        - находим середину с помощью [метода черепахи и зайца](https://www.notion.so/ff80023a0e594ca7ab5a0208c36873e9?pvs=21)
        - разворачиваем половину списка
        - теперь мы можем идти с двух концов к середине и сравнивать элементы

      **Сложность: Время - O(n), память O(1).**

        ```go
        // 1. Методом черепахи и зайца добираемся до середины списка.
        // 2. С середины до конца разворачиваем список.
        // 3. Идем с обоих концов к середине и сравниваем поэлементно.
        func isPalindrome(head *ListNode) bool {
            // Медленный бегунок (черепаха).
            slowN := head
            // Быстрый бегунок (заяц).
            fastN := head
        
            // Пока не дошли до конца списка быстрым бегунком.
            // Тут два кейса: четное и нечетное количество узлов.
            // Если четное, то середина (медленный бегунок) будет на среднем узле.
            // Если нечетное, то медленный бегунок будет на правом серединном узле.
            for fastN.Next != nil {
                // Сначала перемещаем медленный.
                slowN = slowN.Next
                // Перемещаем быстрый на 2 узла.
                fastN = fastN.Next
                if fastN.Next == nil {
                    break
                }
                fastN = fastN.Next
                // можно сразу перескакивать: fast = fast.Next.Next
            }
        
            // Ссылка на предыдущий узел.
            var prevN *ListNode
            // Средний узел должен ссылаться на nil, чтобы потом понять, что дошли до середины.
            // Проходимся от середины и до конца списка
            // инвертируя каждую ссылку с правого узла на левый.
            for {
                next := slowN.Next
                slowN.Next = prevN
                prevN = slowN
                if next == nil {
                    break
                }
                slowN = next
            }
        
            // Левый крайний узел.
            leftN := head
            // Правый крайний узел.
            rightN := slowN
            // Проходимся от краев списка к середине и сверяем значение двух зеркальных узлов.
            for rightN != nil {
                // Если значения зеркальных узлов разные - это не палиндром.
                if leftN.Val != rightN.Val {
                    return false
                }
                leftN = leftN.Next
                rightN = rightN.Next
            }
        
            return true
        }
        
        type ListNode struct {
        		Val int
        		Next *ListNode
        }
        ```

    - Решение 2: Создать из списка массив и сравнить [двумя указателями](https://www.notion.so/draft-278415d3ec1246ff9b5b016795685ef8?pvs=21). TODO.

      **Сложность: Время - O(n), память O(n).**

        ```go
        
        ```

    - Решение 3: Рекурсия. TODO.

      **Сложность: Время - O(n), память O(n).**

        ```go
        
        ```

- Преобразовать **связный список**, чтобы **элементы** **с начала и конца чередовались**

  [LeetCode: 143. Reorder List](https://leetcode.com/problems/reorder-list)

    - Условие

      Дан односвязный список. Нужно преобразовать его так, чтобы узлы с начала и конца чередовались между собой.

      `L0 → L1 → … → Ln - 1 → Ln` ⇒ `L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …`

      Необходимо решить задачу изменением порядка узлов, а не изменением значений в узлах.

    - Кейсы
        - `head = [1,2,3,4]; res = [1,4,2,3];`

          ![reorder1linked-list.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/reorder1linked-list.jpg)

        - `head = [1,2,3,4,5]; res = [1,5,2,4,3];`

          ![reorder2-linked-list.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/reorder2-linked-list.jpg)

    - Решение 1 (оптимальное): Разворот второй половины + два указателя с начала и с конца к середине.
        - Визуализация

          ![overview.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/overview.png)


        **Сложность: Время - O(n), память O(1).**
        
        ```go
        // Развернем правую половину списка.
        // Пойдем двумя указателями с начала и с конца к середине.
        // Будем чередовать узлы с начала и с конца.
        func reorderList(head *ListNode)  {
            // Проверим, что список не пустой.
            if head == nil || head.Next == nil {
                return
            }
            // Найдем середину списка. slow должен стать серединой.
            slow, fast := head, head
            for fast != nil && fast.Next != nil {
                // Медленный двигается на 1 узел, быстрый на 2 узла.
                slow = slow.Next
                fast = fast.Next.Next
            }
            // Развернем вторую половину списка.
            // Переименуем slow для удобства.
            cur := slow
            // Предыдущий узел.
            var prev *ListNode
            // Пока не дойдем от середины до конца.
            for cur != nil {
                // **Меняем атомарно.**
                // Теперь текущий ссылается на предыдущий.
                // Предыдущий становится текущим.
                // Текущий становится следующим.
                cur.Next, prev, cur = prev, cur, cur.Next
            }
            // Чередуем элементы.
            first := head
            // Предыдущий из последней операции это последний узел, т.к. cur стал =null.
            last := prev
            // Пока не дойдем до середины с конца.
            for last.Next != nil {
                // **Меняем атомарно.**
                // Следующий с начала теперь указывает на текущий с конца.
                // Текущий указатель с начала перемещается на следующий узел с начала.
                first.Next, first = last, first.Next
                // **Меняем атомарно.**
                // Следующий с конца теперь указывает на текущий с начала.
                // Текущий указатель с конца перемещается на следующий узел с конца.
                last.Next, last = first, last.Next
            }
        }
        
        type ListNode struct {
        	Val int
        	Next *ListNode
        }
        ```

- **Слить k отсортированных связных списка**

  [LeetCode: 23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists)

    - Условие

      Дан массив односвязных отсортированных списка `lists`. Нужно слить эти списки в один. Результирующий список должен быть так же отсортирован.

    - Кейсы

      `lists = [[1,4,5],[1,3,4],[2,6]]; res = [1,1,2,3,4,4,5,6];`

      `lists = []; res = [];`

      `lists = [[]]; res = [];`

    - **Решение 1 (оптимальное): Минимальная куча + слияние списков поэлементно.**
        - Куча будет всегда размером с количество списков.
        - Будем брать из кучи минимальный узел и добавлять в нее следующий узел из списка с текущим минимальным.
        - Т.е. алгоритм схож с алгоритмом слияния отсортированных массивов.
        - С помощью кучи сравниваем текущие узлы всех списков и выбираем их них минимальный.

      **Сложность: Время - O(n*log(k)), память O(n)**, n - количество элементов во всех списках, k - количество списков.

        ```go
        // Используем минимальную кучу.
        // Куча будет всегда размером с количество списков.
        // Будем брать из кучи минимальный узел и добавлять в нее следующий узел из списка с текущим минимальным.
        // Т.е. алгоритм схож с алгоритмом слияния отсортированных массивов.
        // С помощью кучи сравниваем текущие узлы всех списков и выбираем их них минимальный.
        func mergeKLists(lists []*ListNode) *ListNode {
        	// Заполняем массив узлов из начальных узлов всех списков.
        	// Т.е. если 3 списка, то len(pq) =3.
        	pq := make(PQ, 0)
        	for _, node := range lists {
        		if node != nil {
        			pq = append(pq, node)
        		}
        	}
        	// Если все списки пустые - выходим.
        	if len(pq) == 0 {
        		return nil
        	}
        	// Превращаем массив в кучу.
        	heap.Init(&pq)
        
        	// Текущий узел для поиска.
        	node := &ListNode{}
        	// Указатель на пустой узел, который будет указывать на начало списка.
        	fakeHead := node
        	// Пока в куче есть элементы.
        	for len(pq) > 0 {
        		// Достаем минимальный элемент из кучи.
        		// Он будет выбираться только из минимальных элементов всех списков.
        		// Т.к. куча всегда будет размером с количество списков.
        		minEl := heap.Pop(&pq)
        		nextNode := minEl.(*ListNode)
        		// Устанавливаем указатель с текущего узла на следующий элемент.
        		node.Next = nextNode
        		// Если список, в котором содержится следующий узел не закончился,
        		// то добавляем следующий узел из этого списка в кучу.
        		if nextNode.Next != nil {
        			heap.Push(&pq, nextNode.Next)
        		}
        		// Переставляем текущий указатель на следующий элемент.
        		node = nextNode
        	}
        	// Следующий за фейковым указателем - начало результирующего списка.
        	return fakeHead.Next
        }
        
        // Минимальная куча, реализует интерфейс container/heap.
        type PQ []*ListNode
        
        func (pq PQ) Len() int {
        	return len(pq)
        }
        
        func (pq PQ) Swap(a, b int) {
        	pq[a], pq[b] = pq[b], pq[a]
        }
        
        func (pq PQ) Less(a, b int) bool {
        	return pq[a].Val < pq[b].Val
        }
        
        func (pq *PQ) Push(nodeInterface interface{}) {
        	node := nodeInterface.(*ListNode)
        	*pq = append(*pq, node)
        }
        
        func (pq *PQ) Pop() interface{} {
        	old := *pq
        	lastNode := old[len(*pq)-1]
        	*pq = old[:len(*pq)-1]
        	return lastNode
        }
        
        type ListNode struct {
        	Val int
        	Next *ListNode
        }
        ```

    - Есть еще несколько решений.

## Массивы

### Поиск искомой суммы нескольких элементов в массиве

- Найти в **несортированном** массиве **сумму двух элементов** равную целевому числу

  [LeetCode: 1. Two Sum](https://leetcode.com/problems/two-sum/)

    - Условие

      Дан массив **несортированных** целых чисел и целое число. Нужно найти **сумму двух чисел** в массиве, равную входящему целому числу.

    - Кейсы

      `nums = [2,7,11,15]; target = 9; res = [0,1];` - `nums[0] + nums[1] == 9`

      `nums = [3,2,4]; target = 6; res = [1,2];`

      `nums = [3,3]; target = 6; res = [0,1];`

    - Решение 1 (оптимальное). [Хэш-таблица](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21) + 1 перебор массива.

      **Сложность: время - O(n), память - O(n).**

        ```go
        func twoSum(nums []int, target int) []int {
            // Мапа для поиска второго слагаемого.
            // Ключ - число, значение - индекс этого числа.
            numToIdx := make(map[int]int)
            for i, n := range nums {
                // Искомое второе слагаемое.
                search := target - n
                // Если второе слагаемое нашли - выходим.
                searchIdx, ok := numToIdx[search]
                if ok {
                    return []int{searchIdx, i}
                }
                // Кладем текущее число в мапу.
                // Не заботимся о том, что можем затереть существующее число,
                // т.к. в задаче указано, что решение может быть только одно.
                numToIdx[n] = i
            }
        
            return nil
        }
        ```

- Найти в **отсортированном** массиве **сумму двух элементов** равную целевому числу

  [LeetCode: 167. Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)

    - Условие

      Дан массив **сортированных** целых чисел и целое число. Нужно найти **сумму двух чисел** в массиве, равную входящему целому числу. Необходимо вернуть не индексы двух чисел, а их порядковые номера (`index + 1`). Гарантируется, что решение может быть только одно.

    - Кейсы

      `numbers = [**2**,**7**,11,15], target = 9; res = [1,2];`

      `numbers = [**2**,3,**4**], target = 6; res = [1,3];`

      `numbers = [**-1**,**0**], target = -1; res = [1,2];`

    - Решение 1 (оптимальное). [Два указателя](https://www.notion.so/draft-278415d3ec1246ff9b5b016795685ef8?pvs=21).

      Т.к. массив отсортирован, мы можем идти с концов к середине суммируя попарно элементы массива на предмет искомой суммы. Важность составляют условия по которым нужно передвигать указатели.

      Передвигаем правый бегунок когда правый элемент больше, чем разность искомой суммы и левого элемента. Т.е. сам правый элемент и все элементы справа от него (которые больше) дадут сумму больше искомой. Например, `numbers=[2,3,4,5]; target=6; left=2; right=5`. Чтобы получить сумму для правого элемента нужна `1`, но `1` уже точно не встретим. А для левого элемента справа нужно `4`. А `4` мы можем встретить слева от правого, поэтому передвигаем правый.

      **Сложность: время - O(n), память - O(1).**

        ```go
        func twoSum(numbers []int, target int) []int {
            // Левый бегунок бежит с начала.
            leftIdx := 0
            // Правый бегунок бежит с конца.
            rightIdx := len(numbers) - 1
            // Пока бегунки не встретятся.
            for leftIdx < rightIdx {
                // Если сумма элементов под бегунками равна искомой - выходим.
                if target - numbers[leftIdx] == numbers[rightIdx] {
                    return []int{leftIdx + 1, rightIdx + 1}
                }
                // Передвигаем правый бегунок когда правый элемент больше,
                // чем разность искомой суммы и левого элемента.
                if target - numbers[leftIdx] < numbers[rightIdx] {
                    rightIdx--
                } else {
                    // Левый бегунок двигаем при обратной ситуации: 
                    leftIdx++
                }
            }
        
            return nil
        }
        ```

- Найти в **отсортированном** массиве **сумму трех элементов** равную нулю

  [LeetCode: 15. 3Sum](https://leetcode.com/problems/3sum)

    - Условие

      Дан массив **сортированных** целых чисел и целое число. Нужно найти **сумму двух чисел** в массиве, равную входящему целому числу. Необходимо вернуть не индексы двух чисел, а их порядковые номера (`index + 1`). Гарантируется, что решение может быть только одно.

    - Кейсы
        - `nums = [-1,0,1,2,-1,-4]; res = [[-1,-1,2],[-1,0,1]];`

          `nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0`

          `nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0`

          `nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0`


        `nums = [0,1,1]; res = [];`
        
        `nums = [0,1,1]; res = [];`
        
        `nums=[0,0,0]; res = [[0,0,0]];`
        
        `nums=[-2,0,0,2,2];`
        
    - Решение 1 (оптимальное).  Сортировка + [два указателя](https://www.notion.so/draft-278415d3ec1246ff9b5b016795685ef8?pvs=21).
        
        **Сложность: время - O(n^2), память - O(log(n))-O(n).**
        
        ```go
        // Сортировка + два указателя.
        // Решение на основе решения задачи 167 TwoSum (Найти в отсортированном массиве сумму двух элементов равную целевому числу).
        // Сортируем массив и для каждого элемента вызываем функцию поиска суммы двух элементов.
        func threeSum(nums []int) [][]int {
            // Результирующий массив.
            var res [][]int
            // Отсортируем входящий массив.
            // Можно во время сортировки убирать дубли, тогда не нужны будут доп условия при переборе.
            sort.Ints(nums)
            // Предыдущий элемент для прописка дубликатов.
            prev := math.MinInt
            for i, num := range nums {
                // Пропускаем дубликаты.
                if num == prev {
                    continue
                }
                // Ищем оставшуюся сумму перебирая попарно два числа в оставшемся подмассиве.
                twoSum(nums[i+1:], num, &res)
                prev = num
            }
        
            return res
        }
        
        // Поиск суммы для двух чисел.
        func twoSum(nums []int, prefixNum int, res *[][]int) {
            // Левый бегунок, начинаем с начала.
            leftIdx := 0
            // Левый бегунок, начинаем с конца.
            rightIdx := len(nums) - 1
            // Искомая сумма для двух чисел.
            searchSum := 0 - prefixNum
            //Предыдущий левый элемент (для исключения дублей). 
            prevLeft := math.MinInt
            //Предыдущий правый элемент (для исключения дублей). 
            prevRight := math.MaxInt
            // Пока бегунки не встретятся
            for leftIdx < rightIdx {
                // Исключаем дубли.
                if nums[leftIdx] == prevLeft && nums[rightIdx] == prevRight {
                    leftIdx++
                    rightIdx--
                    continue
                }
                // Если левый и правый элементы равны искомой сумме, то мы нашли искомые элементы.
                if searchSum - nums[leftIdx] == nums[rightIdx] {
                    // Добавляем в результирующий массив.
                    *res = append(*res, []int{prefixNum, nums[leftIdx], nums[rightIdx]})
                    prevLeft = nums[leftIdx]
                    prevRight = nums[rightIdx]
                    leftIdx++
                    rightIdx--
                    continue
                }
                // Если правый элемент выходит за границы суммы, то двигаем правый бегунок.
                if searchSum - nums[leftIdx] < nums[rightIdx] {
                    rightIdx--
                } else {
                    // Иначе левый.
                    leftIdx++
                }
            }
        }
        ```
        
    - Решение 2. [Хэш-таблица](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21). TODO.
        
        **Сложность: время - O(n^2), память - O(n).**
        
        ```go
        
        ```
        
    - Решение 3. Еще какое-то решение. TODO.
        
        **Сложность: время - O(n^2), память - O(n).**
        
        ```go
        
        ```
        
    - Разница решений
        
        Addressing several question regarding the "No-Sort" approach. We recommend approach 1 for interviews, and approach 3 is to address a possible follow-up question (e.g. "what if you cannot sort the array"). The point here is that it's possible, though the efficiency would heavily depend on the input. If we have a very large array with many duplicates and a few matching triplets, the "No-Sort" approach would be more memory efficient.


### Разбиение массива на подмассивы

- **Разбить** строку так, чтобы в каждой **подстроке** были только **уникальные буквы**.

  [LeetCode: 763. Partition Labels](https://leetcode.com/problems/partition-labels)

    - Кейсы

      `s="caedaaebgg"; res=[1,6,1,2]` - одна буква в начале, одна буква в середине.

    - Решение 1 (оптимальное). Массив с максимальной позицией каждой буквы.

      Если у нас есть искомый подмассив, то максимальная позиция каждой буквы будет в рамках этого подмассива.

        - Визуализация

          ![763-ep161.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/763-ep161.jpg)


        ```go
        // Массив с максимальными позициями букв.
        func partitionLabels(s string) []int {
            // Массив для максимальной позиции каждой буквы (можно использовать и мапу).
            // Ключ - индекс буквы (смещаем относительно 'a'), значение - максимальная позиция.
            var letterToMaxPos [28]int
            for i, letter := range s {
                letterToMaxPos[letter - 'a'] = i
            }
            // Границы (индексы) текущего интервала.
            // -1, т.к. первый интервал должен включать первую букву.
            startIdx := -1
            endIdx := 0
            // Результирующий массив.
            var res []int
            // Если у нас есть искомый подмассив, то максимальная позиция каждой буквы будет в рамках этого интервала.
            for i, letter := range s {
                // Переопределяем максимальную позицию букв в интервале, если нужно.
                if letterToMaxPos[letter - 'a'] > endIdx {
                    endIdx = letterToMaxPos[letter - 'a']
                }
                // Если дошли до максимальной позиции всех букв, то это окончание интервала.
                if i == endIdx {
                    res = append(res, endIdx - startIdx)
                    startIdx = endIdx
                }
            }
        
            return res
        }
        
        // Кейсы:
        // s="caedaaebgg"; res=[1,6,1,2]
        ```
        
    - Неоптимальные решения
        - С помощью интервалов. Но код получится значимо больше и сложнее, чем с массивом максимальных позиций.

- **Группировка** анаграмм

  [LeetCode: 49. Group Anagrams](https://leetcode.com/problems/group-anagrams)

    - Условие

      Дан массив слов, нужно сгруппировать анаграммы из этих слов.

    - Кейсы

      `strs=["eat","tea","tan","ate","nat","bat"]; res=[["bat"],["nat","tan"],["ate","eat","tea"]]`

      `strs = [""]; res=[[""]]`

      `strs = ["a"]; res=[["a"]]`

    - Решение 1. Хэш-таблица с отсортированным словом + поиск слова в хэш-таблице.

        ```go
        func groupAnagrams(strs []string) [][]string {
            // Мапа с группировкой слов.
            // Ключ - отсортированное слово (буквенные счетчики), значение - индексы слов.
            sortedWords := make(map[[28]int][]int)
            for i, word := range strs {
                // Буквенные счетчики.
                // Ключ - буква со смещением до нуля, т.е. 'a' - 0, 'b' - 1, ...
                // Значение счетчик этой буквы в слове.
                var uniqLetters [28]int
                for _, letter := range word {
                    uniqLetters['z' - letter]++
                }
                // Добавляем индекс слова в мапу.
                // Можно сразу добавлять слова, но так будет больше расходоваться память.
                sortedWords[uniqLetters] = append(sortedWords[uniqLetters], i)
            }
        
            // Результирующий массив.
            var res [][]string
            // Для каждого уникального слова формируем анаграммы.
            for _, wordIdxs := range sortedWords {
                // Берем слова (анаграммы) по индексам и добавляем их в результирующий массив.
                var words []string
                for _, wordIdx := range wordIdxs {
                    words = append(words, strs[wordIdx])
                }
                res = append(res, words)
            }
        
            return res
        }
        ```


### Сортировка, слияние массивов

- **Отсортировать массив**

  [LeetCode: 912. Sort an Array](https://leetcode.com/problems/sort-an-array/)

    - Условие

      На входе неотсортированный массив, вернуть отсортированный массив.

    - Кейсы

      `nums = [5,2,3,1]; res = [1,2,3,5]`

    - Решение 1. Сортировка подсчетом.

      Время - O(n+k); память - O(n), где k - разница между минимальным и максимальным число в массиве.

        ```go
        // Сортировка подсчетом.
        func sortArray(nums []int) []int {
            // nums=[2,-3,-2,1,2,2,1]
            // Минимальный элемент в исходном массиве.
            min := math.MaxInt
            // Максимальный элемент в исходном массиве.
            max := math.MinInt
            // Формируем минимальный и максимальный элементы.
            for _, num := range nums {
                if num < min {
                    min = num
                }
                if num > max {
                    max = num
                }
            }
            // min=-3; max=2.
            // Формируем массив, который будет содержать повторяемость элементов исходном массива (массив повторов).
            // Индекс - число из исходном массива, значение - количество повторов этого числа (счетчик).
            // Т.к. у нас могут быть отрицательные числа в исходном массиве, то нам нужно вычислять индекс в массиве повторов, смещаяя его с учетом минимального числа из исходного массива.
            numsRange := make([]int, max - min + 1)
            for _, num := range nums {
                numsRange[num - min]++
            }
            // numsRange=[1,1,0,2,3]. Т.е. -3 встретилось 1 раз, а 2 - 3 раза.
            // Индекс для заполнения исходного массива по порядку (сортировки).
            resIdx := 0
            for i := min; i <= max; i++ {
                // Если счетчик пуст - переходим к следующему числу.
                // Если встречалось - уменьшаем его счетчик, записываем его в результирующий массив.
                for ; numsRange[i - min] > 0; numsRange[i - min]-- {
                    nums[resIdx] = i
                    resIdx++
                }
            }
            // nums=[-3,-2,1,1,2,2]
        
            return nums
        }
        ```

    - Решение 2. Сортировка слиянием через рекурсию.

      Время - O(n*log(n)); память - O(n).

        ```go
        // Сортировка слиянием через рекурсию.
        func sortArray(nums []int) []int {
            mergesort(nums, 0, len(nums))
            return nums
        }
        
        func mergesort(nums []int, startIdx, endIdx int) {
            // Дошли до конца подмассива.
            if startIdx >= endIdx - 1 {
                return
            }
            // Индекс середины подмассива, чтобы разбить текущий подмассив на два подмассива.
            midIdx := (startIdx + endIdx) / 2
            mergesort(nums, startIdx, midIdx)
            mergesort(nums, midIdx, endIdx)
            merge(nums, startIdx, endIdx, midIdx)
        }
        
        // Мержим два отсортированных подмассива in-place.
        func merge(nums []int, startIdx, endIdx, midIdx int) {
            // Новый массив, куда складываем смерженные элементы.
            // Скорее всего можно обойтись и без нового массива.
            newArr := make([]int, endIdx - startIdx)
            // Бегунок для левого подмассива.
            leftIdx := startIdx
            // Бегунок для правого подмассива.
            rightIdx := midIdx
            for i := 0; i < endIdx - startIdx; i++ {
                // Если дошли до конца правого подмассива.
                // Либо не дошли до конца левого и левый элемент меньше правого.
                // Вставляем в новый массив левый элемент, смещаем левый бегунок.
                if rightIdx == endIdx || (leftIdx < midIdx && nums[leftIdx] < nums[rightIdx]) {
                    newArr[i] = nums[leftIdx]
                    leftIdx++
                } else {
                    // Сюда пришли, когда либо дошли до конца левого подмассива.
                    // Либо когда правый элемент меньше левого.
                    // Вставляем в новый массив правый элемент, смещаем правый бегунок.
                    newArr[i] = nums[rightIdx]
                    rightIdx++
                }
            }
            // Копируем новый массив во входящий.
            copy(nums[startIdx:endIdx], newArr)
        }
        ```


- **Слить отсортированные** массивы с **дублями** используя входной массив.

  [LeetCode: 88. Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array)

    - Условие

      Даны два отсортированных массива. Нужно слить массивы в один отсортированный массив, в качестве результирующего используя первый массив. Первая часть первого массива заполнена элементами, вторая нулями.

    - Кейсы

      `nums1=[1,2,3,0,0,0]; m=3; nums2=[2,5,6]; n=3; nums1=[1,2,2,3,5,6]`

    - Решение 1 (оптимальное). Заполняем с конца сравнивая поэлементно.

      Заполняем подобно сортировке слиянием.

      **Сложность: время - O(n+m), память - O(1).**

        ```go
        func merge(nums1 []int, m int, nums2 []int, n int)  {
            // Бегунки для первого и второго массива. Бежим с конца.
            idx1 := m - 1
            idx2 := n - 1
            
            // Бегунок для заполнения первого массива результирующими значениями.
            for rIdx := len(nums1) - 1; rIdx >= 0; rIdx-- {
                // Если вышли за рамки во втором массиве
                // либо не вышли за рамки в первом и в первом элемент не меньше чем во втором.
                if idx2 < 0 || (idx1 >= 0 && nums1[idx1] >= nums2[idx2]) {
                    // Используем элемент из первого.
                    nums1[rIdx] = nums1[idx1]
                    idx1--
                } else {
                    // Используем элемент из второго.
                    nums1[rIdx] = nums2[idx2]
                    idx2--
                }
            }
        }
        ```

    - Решение 2 (долгое). Сливаем массивы и сортируем.

      **Сложность: время - O(n+m*log(n+m)), память - O(n).**


- Вернуть **средний элемент** из **двух отсортированных** массивов

  [TODO: решить бинарным поиском]

  [LeetCode: 4. Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays)

    - Условие

      Даны два отсортированных целочисленных массива `nums1`, `nums2`. Необходимо найти средний элемент этих массивов. Т.е. если бы мы смержили массивы, то нужен элемент, который стоит в середине смерженного массива. Если середина состоит из двух элементов - вернуть среднее значение этих элементов.

    - Кейсы

      `nums1 = [1,3], nums2 = [2]; res = 2.0;` - смерженный массив `[1,2,3]`;

      `nums1 = [1,2], nums2 = [3,4]; res = 2.5;` - смерженный массив `[1,2,3,4]`;

    - **Решение 1 (простое, не самое быстрое): Мержим массивы на лету до середины двумя указателями.**

      **Сложность: время - O(n + m), память - O(1).**

        ```go
        // Мержим массивы до середины.
        func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
             // Общая длина двух массивов.
             overallLen := len(nums1) + len(nums2)
             // Текущий и предыдущий смерженые элементы.
             cur, prev := 0, 0
             // Бежим по двум массивам двумя бегунками, пока не дойдем до общей середины.
             for idx1, idx2 := 0, 0; idx1 + idx2 <= overallLen / 2; {
                  // Если не вышли за рамки первого массива И
                  // ЛИБО вышли за рамки второго, ЛИБО элемент первого не больше элемента второго.
                  if idx1 < len(nums1) && (idx2 == len(nums2) || nums1[idx1] <= nums2[idx2]) {
                       // Подменяем предыдущий и текущий смерженые элементы.
                       prev = cur
                       cur = nums1[idx1]
                       // Двигаем бегунок первого массива.
                       idx1++
                  // Если не вышли за рамки второго массива И
                  // ЛИБО вышли за рамки первого, ЛИБО элемент второго меньше элемента первого.
                  } else {
                       // Подменяем предыдущий и текущий смерженые элементы.
                       prev = cur
                       cur = nums2[idx2]
                       // Двигаем бегунок второго массива.
                       idx2++
                  }
             }
             // Когда четное число элементов, нужно взять два последних смерженых элемента и
             // рассчитать их среднее значение.
             if overallLen % 2 == 0 {
                  return float64(prev + cur) / 2.0
             }
             // Когда нечетное число элементов - берем последний смерженый элемент (средний).
             return float64(cur)
        }
        ```

    - Решение 2 (сложное, быстрое): [Бинарный поиск](https://www.notion.so/8aa67c33fcbe4ce6913fc300d98e87a3?pvs=21). TODO.

      **Сложность: время - O(log(n*m)), память - O(log(n) + log(m)).**

        ```go
        
        ```


- Найти **неотсортированный подмассив в частично отсортированном массиве**

  [LeetCode: 581. Shortest Unsorted Continuous Subarray](https://leetcode.com/problems/shortest-unsorted-continuous-subarray)

  [TODO: решить более оптимально]

    - Условие

      Дан целочисленный, частично отсортированный массив `nums`. Часть массива может быть неотсортирована, необходимо найти неотсортированный подмассив и вернуть его длину.

    - Кейсы

      `nums = [2,6,4,8,10,9,15]; res = 5;` - неотсортированный подмассив: `[6, 4, 8, 10, 9];`

      `nums = [1,2,3,4]; res = 0;`

      `nums = [1]; res = 0;`

    - Решение 1 (простое, не быстрое): Сортируем в новый массив и сравниваем массивы.

      **Сложность: время - O(n*log(n)), память - O(n).**

        ```go
        // Сортируем в новый массив и сравниваем массивы.
        func findUnsortedSubarray(nums []int) int {
            if len(nums) == 0 {
                return 0
            }
            // Делаем новый отсортированный массив клонируя входящий.
            sortedNums := make([]int, len(nums))
            copy(sortedNums, nums)
            sort.Ints(sortedNums)
            // Стартовый и конечный искомые индексы неотсортированного подмассива.
            startIdx, endIdx := -1, -1
            // Ищем стартовый индекс сравнивая элементы входящего и отсортированного массивов.
            for i := 0; i < len(nums); i++ {
                // Первый несовпадающий элемент и есть начало неотсортированного массива.
                if nums[i] != sortedNums[i] {
                    startIdx = i
                    break
                }
            }
            // Ищем конечный индекс сравнивая элементы входящего и отсортированного массивов.
            for i := len(nums) - 1; i > -1; i-- {
                // Первый несовпадающий элемент с конца и есть начало неотсортированного массива.
                if nums[i] != sortedNums[i] {
                    endIdx = i
                    break
                }
            }
            // Весь входной массив отсортирован.
            if startIdx == -1 && endIdx == - 1 {
                return 0
            }
            
            return endIdx - startIdx + 1
        }
        ```

    - Решение 2 (быстрое, но не во всех случаях): [Монотонный стек](https://www.notion.so/monotonic-stack-5f453bc0d9c64a7186b10d8eb02dcc62?pvs=21). TODO.

      **Сложность: время - O(n)-O(n^2), память - O(n).**

        ```go
        
        ```

    - Решение 2 (оптимальное, без доп памяти): …. TODO.

      **Сложность: время - O(n)-O(n^2), память - O(n).**

        ```go
        
        ```


### Найти подмассив

- Найти подмассив, **сумма элементов** которого **кратна `k`** (делится **без остатка**)

  [LeetCode: 523. Continuous Subarray Sum](https://leetcode.com/problems/continuous-subarray-sum/)

    - Условие

      Дан неотсортированный массив целых чисел `nums` и целое `k`. Нужно проверить, есть ли подмассив в `nums` такой что:

        - длина подмассива больше 1
        - сумма всех чисел подмассива кратна `k` (`0` тоже кратен `k`)

      Вернуть флаг найден подмассив или нет.

    - Кейсы

      `nums = [23,**2,4**,6,7], k = 6; res = true;` - `[2,4] = 6`, `6` кратна `6`

      `nums = [**23,2,6,4,7**], k = 6; res = true;` - `[23,2,6,4,7] = 42`, `42` кратна `6`

      `nums = [23,2,6,4,7], k = 13; res = false;`

      `nums = [1,-3,4,5], k = 9; res = true;`

    - Решение 1. [Префиксная сумма](https://www.notion.so/draft-f47ce8aefd4c4e06b3583f3a5487c470?pvs=21) + [хэш-таблица](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21).
        - Итеративно формируем префиксную сумму.
        - На каждой итерации складываем остаток от деления префиксной суммы на `k` в хэш-таблицу.
        - Если такой остаток уже был, то мы нашли искомый подмассив.
        - Примеры

          Например, `nums = [23,2,6,4,7]; k = 12;`.

          `[**23**,2,6,4,7]` - `(23)%12 = 11`
          `[23,**2**,6,4,7]` - `(23+2)%12 = 1`
          `[23,2,**6**,4,7]` - `(23+2+6)%12 = 7`
          `[23,2,6,**4**,7]` - `(23+2+6+4)%12 = 11` - такой остаток уже был на первом элементе.

          Или, например, `k = 10`, текущая префиксная сумма `=35` (остаток `35%10=5`). Если мы получим на каком-то шаге сумму `45` или `55` или `65` (любую с остатком `5`), то разница между суммами будет как раз искомое `k*x` (`10*1` или `10*2` или `10*3`...).


        Сложность: время - O(len(nums)); память - O(min(len(nums),k)).
        
        ```go
        // Префиксная сумма + хэш-таблица для хранения остатков от деления.
        func checkSubarraySum(nums []int, k int) bool {
            // Формируем префиксную сумму.
            // На каждом элементе складываем остаток от деления текущей префиксной суммы
            // на искомое k в хэш-таблицу. Если такой остаток уже был на какой-то итерации,
            // то есть такой подмассив с суммой k*x.
            // Например: nums = [23,2,6,4,7]; k = 12;
            // (23)%12 = 11
            // (23+2)%12 = 1
            // (23+2+6)%12 = 7
            // (23+2+6+4)%12 = 11 - такой остаток уже был на первом элементе.
            // Если из текущей префиксной суммы вычесть префиксную сумму первого элемента, 
            // то получим k:
            // (23+2+6+4) - (23) = 12 -> 12 % 12 = 0
            // Или, например, k = 10, текущая сумма =35 (остаток %10=5)
            // Если мы получим на каком-то шаге сумму 45 или 55 или 65 (любую с остатком 5),
            // то разница между суммами будет как раз искомое k*x (10*1 или 10*2 или 10*3...).
        
            // Префиксная сумма.
            sum := 0
            // Мапа остатков (ключ - остаток от деления префиксной суммы на k).
            remains := make(map[int]int)
            // Кейсы: nums=[23,2,4,6,6];k=7   nums=[0,0];k=1
            // Кейс: находится элемент с префиксной суммой делящейся без остатка на k.
            // Для этой суммы не нужно искать такой же остаток от деления на каком-либо предыдущем шаге. Потому что искомый подмассив будет начинаться с нулевого индекса основного массива. Так же это поддерживвает условие: 0 is always a multiple of k.
            // Поэтому добавим фиктивную сумму с нулевым остатком.
            remains[0] = -1
            for i, n := range nums {
                // Увеличиваем сумму.
                sum += n
                // Если остаток от деления на k уже есть в мапе,
                // то мы почти нашли искомый результат.
                if targetIdx, ok := remains[sum % k]; ok {
                    // Проверим еще условие про длину подмассива: its length is at least two
                    if i - targetIdx >= 2 {
                        return true
                    }
                } else {
                    // Добавляем остаток от деления в мапу если такого не было.
                    remains[sum % k] = i
                }
            }
        
            return false
        }
        ```


- Найти **максимальный** подмассив, **сумма элементов** которого **равна `k`**

  [LeetCode: 325. Maximum Size Subarray Sum Equals k](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k)

    - Условие

      Дан неотсортированный массив целых чисел `nums` и целое `k`. Нужно найти подмассив с максимальным размером, сумма элементов которого равна `k`. Вернуть размер подмассива.

    - Кейсы

      `nums = [1,-1,5,-2,3], k = 3; res = 4;` - подмассив `[1, -1, 5, -2];`

      `nums = [-2,-1,2,1], k = 1; res = 2;` - подмассив `[-1, 2];`

      `nums = [1,-3,4,2,3,8], k = 9; res = 3;` - подмассив `[4, 2, 3];`

      `nums = [-2,-1,2,1], k = 1; res = 2;` - подмассив `[-1,2];`

    - **Решение 1 (оптимальное). [Префиксная сумма](https://www.notion.so/draft-f47ce8aefd4c4e06b3583f3a5487c470?pvs=21) + [хэш-таблица](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21).**
        - Итеративно формируем префиксную сумму.
        - На каждой итерации складываем префиксной сумму и индекс в хэш-таблицу.
        - Если остаток от префиксной суммы уже был, то мы нашли искомый подмассив.
        - Примеры

            ```
            nums = [1,-3,4,2,3,8], k = 9; res = 3; 
            --------------------------------------
                   Массив nums          Префиксная сумма    Проверка
            														 сумма => индекс     остатка 
            --------------------------  ----------------    --------
            | 1 | -3 | 4 | 2 | 3 | 8 |      
              0                              1 => 0         1 - 9 = -8
                   1                        -2 => 1        -2 - 9 = -11
                       2                     **2 => 2**         2 - 9 = -7
                           3                 4 => 3         4 - 9 = -5
                               4             **7 => 4**         **7 - 9 = 2** - такая префиксная сумма есть!
                                   5        15 => 5        15 - 9 = 6
            ```


        **Сложность: время - O(n); память - O(n).**


### Получить `k` элементов (`k`-тый элемент) из массива по какому-либо признаку

- Решается с помощью кучи, если речь про наибольшие k элементов.

  В Go метод `[heap.Init](https://www.notion.so/container-heap-draft-8dd36f53ed9945d691ca6d21b3f713f7?pvs=21)` позволяет сформировать кучу из массива за O(n).

    - Если это не учитывать, то в куче можно поддерживать `k` элементов (каждый раз удалять элемент), это даст сложность в O(n*log(k)) при вставке (вместо O(n*log(n))):

      ![image1.jpeg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/image1.jpeg)


- Вычислить `**k**`-тое **наибольшее число** в неотсортированном массиве

  [LeetCode: 215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array)

    - Условие

      Дан несортированный массив `nums`. Нужно вернуть `k`-тый наибольшее число в неотсортированном массиве.

      В массиве могут быть **дубли** чисел.

    - Кейсы

      `nums = [3,2,1,5,6,4], k = 2; res = 5` - в отсортированном массиве `[6,5,4,3,…]` второй элемент это `5`

      `nums = [3,2,3,1,2,4,5,5,6], k = 4; res=4`

    - Решение 1 (неоптимальное). [Сортируем](https://www.notion.so/e77152deb57d4e0e9b45c1a083cd00cd?pvs=21) и берем с конца k-тый элемент.

      Сложность: время - O(n*log(n)), память - O(n*log(n))-O(n).

    - **Решение 2. [Сортировка подсчетом](https://www.notion.so/count-sort-1fba4a41d88f45d3a601d2fcd762906f?pvs=21).**

      **Время - O(max(n) - min(n) + 1); память - O(n).**

        ```go
        // Сортировка подсчетом
        func findKthLargest(nums []int, k int) int {
            // Наименьший элемент.
            min := math.MaxInt
            // Наибольший элемент.
            max := math.MinInt
            // Вычисляем наименьший и наибольший элементы.
            for _, num := range nums {
                if num > max {
                    max = num
                }
                if num < min {
                    min = num
                }
            }
        
            // Заполняем массив со счетчиками элементов (массив повторяемости).
            // Ключ - элемент входящего массива со смещением.
            // Значение повторяемость этого элемента во входящем массиве.
            numCounts := make([]int, max - min + 1)
            for _, num := range nums {
                numCounts[num - min]++
            }
        
            // Вычисляем k-тый наибольший элемент.
            kVal := len(numCounts) - 1
            // Идем с конца массива повторяемости, т.е. с бОльшего элемента.
            for ; kVal >= 0 && k > 0; {
                // Если текущее число присутствует во входящем массиве (счетчик не пустой),
                // то нужно уменьшить счетчик и k.
                if numCounts[kVal] > 0 {
                    numCounts[kVal]--
                    k--
                } else {
                    // Если счетчик пустой, смещаемся на меньшее число.
                    kVal--
                }
            }
        
            // Результат - k-тое число из массива повторяемости с учетом смещения.
            return kVal + min
        }
        ```

    - **Решение 3. [Сортировка максимальной кучей](https://www.notion.so/heap-bbab5668199b473d957aca3403e85c2c?pvs=21).**


        - Реализация максимальной кучи через `container/heap`:
            
            ```go
            // Реализация интерфейса heap.Interface
            type MaxHeap []int
            
            func (h MaxHeap) Len() int {
            	return len(h)
            }
            
            func (h MaxHeap) Less(i, j int) bool {
            	return h[i] > h[j]
            }
            
            func (h MaxHeap) Swap(i, j int) {
            	// Если элементов осталось менбше двух, то переставлять нечего.
            	if len(h) >= 2 {
            		h[i], h[j] = h[j], h[i]
            	}
            }
            
            func (h *MaxHeap) Push(x interface{}) {
            	*h = append(*h, x.(int))
            }
            
            // Изъятие максимального элемента. Возвращает nil если элементов не осталось.
            func (h *MaxHeap) Pop() interface{} {
            	// Обработка предпоследнего оставшегося элемента (len=2).
            	if len(*h) == 1 {
            	  last := (*h)[0]
            	  (*h) = nil
            	  return last
            	}
            	// Обработка последнего оставшегося элемента (len=1).
            	if len(*h) == 0 {
            	  return nil
            	}
            	// Вынимаем последний элемент и уменьшаем кучу.
            	old := *h
            	n := len(old)
            	x := old[n-1]
            	*h = old[:n-1]
            	return x
            }
            
            // Формирование кучи из массива путем инициализации. O(n)
            func buildHeapByInit(array []int) *MaxHeap {
            	mHeap := &MaxHeap{}
            	*mHeap = array
            	heap.Init(mHeap)
            	return mHeap
            }
            
            // Формирование кучи из массива путем вставки поэлементно. O(nlogn)
            func buildHeapByPush(array []int) *MaxHeap {
            	mHeap := &MaxHeap{}
            	for _, num := range array {
            		// O(logn)
            		heap.Push(mHeap, num)
            	}
            	return mHeap
            }
            
            // Работа с кучей:
            func main() {
            	arrayForInit := []int{9, 31, 40, 22, 10, 15, 1, 25, 91}
            
            	// Инициализация кучи.
            	mHeap := buildHeapByInit(arrayForInit)
            
            	// Достаем минимальный элемент и сразу удалем его. // O(logn)
            	// Нужно проверять на количество или на nil.
            	elementToRemove := heap.Pop(mHeap)
            	// Преобразуем элемент к int (возвращается тип *any*).
            	if elementToRemove != nil {
            		fmt.Println(elementToRemove.(int))
            	}
            
            	// Меняем значение с 15 на 50 по индексу 2 (нужно вычислять индекс).
            	(*mHeap)[2] = 50
            	// Перестраиваем кучу, чтобы она была сбалансированной. // O(logn)
            	heap.Fix(mHeap, 2)
            	
            	// Удаляем элемент по индексу 4. // O(logn)
            	heap.Remove(mHeap, 4)
            	fmt.Println("Current min heap after remove element in index 4: ", *mHeap)
            }
            ```
            
        
        **Время - O(n*log(k)); память - O(k).**
        
        ```go
        // Сортировка максимальной кучей.
        func findKthLargest(nums []int, k int) int {
            // Формируем максимальную кучу.
            maxHeap := buildHeapByInit(nums)
            // Результат (значение k-того элемента)
            res := 0
            // Достаем k-тый максимальный элемент из кучи.
            for ; k > 0; k-- {
                res = heap.Pop(maxHeap).(int)
            }
        
            return res
        }
        
        // Формирование кучи из массива путем инициализации. O(n)
        func buildHeapByInit(array []int) *MaxHeap {
        	mHeap := &MaxHeap{}
        	*mHeap = array
        	heap.Init(mHeap)
        	return mHeap
        }
        
        // Реализация интерфейса heap.Interface
        type MaxHeap []int
        
        func (h MaxHeap) Len() int {
        	return len(h)
        }
        
        func (h MaxHeap) Less(i, j int) bool {
        	return h[i] > h[j]
        }
        
        func (h MaxHeap) Swap(i, j int) {
        	// Если элементов осталось менбше двух, то переставлять нечего (**если k может быть больше len(nums)**).
        	if len(h) >= 2 {
        		h[i], h[j] = h[j], h[i]
        	}
        }
        
        func (h *MaxHeap) Push(x interface{}) {
        	*h = append(*h, x.(int))
        }
        
        func (h *MaxHeap) Pop() interface{} {
        	// Обработки предпоследнего и последнего элементов (**когда k может быть больше len(nums)**)**.**
        	// Обработка предпоследнего оставшегося элемента (len=2).
        	if len(*h) == 1 {
        	  last := (*h)[0]
        	  (*h) = nil
        	  return last
        	}
        	// Обработка последнего оставшегося элемента (len=1).
        	if len(*h) == 0 {
        	  return nil
        	}
        	old := *h
        	n := len(old)
        	x := old[n-1]
        	*h = old[:n-1]
        	return x
        }
        ```
        
    - Решение 4. Quickselect. TODO.

- Найти `**k**` наиболее **часто встречающихся слов** в массиве.

  [LeetCode: 692. Top K Frequent Words](https://leetcode.com/problems/top-k-frequent-words)

    - Условие

      Дан несортированный массив слов. Нужно вернуть k наиболее часто встречаемых слов в массиве.

      Возвращаемые слова должны быть отсортированы по частотности. Если есть слова с одинаковой частотностью, то отсортировать их по словам в лексиграфическом порядке.

    - Кейсы

      `words = ["i","love","leetcode","i","love","coding"]; k = 2; res = ["i","love"];`

      `words = ["the","day","is","sunny","the","the","the","sunny","is","is"]; k = 4; res =`  `["the","is","sunny","day"];`

    - Решение 1 (оптимальное). [Хэш-таблица](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21) + [максимальная куча](https://www.notion.so/heap-bbab5668199b473d957aca3403e85c2c?pvs=21).

      **Сложность: время - O(n + k*log(n)), память - O(n).**

        ```go
        // Мапа + куча.
        func topKFrequent(words []string, k int) []string {
            // Мапа для частотности слов.
            // Ключ - слово, значение - повторяемость слова (частотность)
            wordsFreq := make(map[string]int)
            for _, word := range words {
                wordsFreq[word]++
            }
            // Формируем максимальную кучу на основе частотности слов.
            maxHeap := buildHeap(wordsFreq)
        
            // Результирующий массив наиболее встречаемых слов.
            res := make([]string, 0, k)
            // Достаем из кучи слова отсортированные по частотности.
            for ; k > 0 && maxHeap.Len() > 0; k-- {
        				// O(k*log(n))
                res = append(res, heap.Pop(maxHeap).(wordWrap).word)
            }
        
            return res
        }
        
        // Элемент кучи.
        type wordWrap struct {
            freq int // частотность (повторяемость) слова
            word string // слово
        }
        
        // Формирование кучи из массива O(n).
        func buildHeap(wordsFreq map[string]int) *MaxHeap {
            mHeap := make(MaxHeap, 0, len(wordsFreq))
            for word, freq := range wordsFreq {
                mHeap = append(mHeap, wordWrap{freq: freq, word: word})
            }
            // Если сортировать кучу через Init, то будет O(n),
            // если через heap.Push(), то - O(n*log(n)).
            heap.Init(&mHeap)
        
            return &mHeap
        }
        
        // Реализация интерфейса heap.Interface
        type MaxHeap []wordWrap
        
        func (h *MaxHeap) Len() int {
        	return len(*h)
        }
        
        func (h *MaxHeap) Less(i, j int) bool {
            if (*h)[i].freq > (*h)[j].freq {
                return true
            }
            // Если частотность слов одинаковая - сортируем в лексиграфическом порядке.
            if (*h)[i].freq == (*h)[j].freq {
                return (*h)[i].word < (*h)[j].word
            }
        
        	return false
        }
        
        func (h *MaxHeap) Swap(i, j int) {
            // Если элементов осталось менбше двух, то переставлять нечего.
            if len(*h) >= 2 {
        	    (*h)[i], (*h)[j] = (*h)[j], (*h)[i]
            }
        }
        
        func (h *MaxHeap) Push(x interface{}) {
        	*h = append(*h, x.(wordWrap))
        }
        
        // Изъятие максимального элемента. Возвращает nil если элементов не осталось.
        // O(k*log(n))
        func (h *MaxHeap) Pop() interface{} {
        	// Обработка предпоследнего оставшегося элемента (len=2).
        	if len(*h) == 1 {
        	  last := (*h)[0]
        	  (*h) = nil
        	  return last
        	}
        	// Обработка последнего оставшегося элемента (len=1).
        	if len(*h) == 0 {
        	  return nil
        	}
        	// Вынимаем последний элемент и уменьшаем кучу.
        	old := *h
        	n := len(old)
        	last := old[n-1]
        	*h = old[:n-1]
        	return last
        }
        ```

    - Решение 2 (неоптимальное). Мапа + сортировка.

      Сложность: время - O(n*log(n)), память - O(n).

        ```go
        // Мапа + сортировка.
        func topKFrequent(words []string, k int) []string {
            // Мапа с частотностью слов.
            wordsFreq := make(map[string]int, len(words))
            for _, word := range words {
                wordsFreq[word]++
            }
            
            // Массив для сортировки.
            wordsRes := make([]string, 0, len(words))
            for word := range wordsFreq {
                wordsRes = append(wordsRes, word)
            }
            
            // Сортиуем массив на основе частотности.
            sort.Slice(wordsRes, func(i, j int) bool {
                if wordsFreq[wordsRes[i]] > wordsFreq[wordsRes[j]] {
                    return true
                }
                if wordsFreq[wordsRes[i]] == wordsFreq[wordsRes[j]] {
                    return wordsRes[i] < wordsRes[j]
                }
                
                return false
            })
            
            return wordsRes[:k]
        }
        ```


- Найти `**k**` наиболее **часто встречающихся чисел** в массиве.

  [LeetCode: 347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements)

    - Условие

      Дан несортированный массив чисел `nums`. Нужно вернуть **`k` наиболее часто встречаемых чисел в массиве**.

    - Кейсы

      `nums = [1,1,1,2,2,3], k = 2; res = [1,2];`

      `[1], k = 1; res = [1];`

    - **Решение 1 (оптимальное). [Хэш-таблица](https://www.notion.so/Map-6770d8cb3ec248f0ab1e3ec6b84d054f?pvs=21) + [максимальная куча](https://www.notion.so/heap-bbab5668199b473d957aca3403e85c2c?pvs=21).**
        - Заполняем мапу для повторяемости чисел.
        - Формируем из мапы максимальную кучу.
        - Выбираем из кучи k первых максимальных элементов.

      Так же можно формировать кучу поддерживая в ней только `k` элементов (удалять лишние элементы).

      **Сложность: время - O(n + k*log(n)), память - O(n).**

        ```go
        // Хэш-таблица + куча.
        func topKFrequent(nums []int, k int) []int {
        	// Мапа для числа и его повторяемости.
        	// Ключ - число, значение - повторяемость числа (счетчик)
        	numToFreq := make(map[int]int)
        	for _, num := range nums {
        		numToFreq[num]++
        	}
        	// Строим максимальную кучу из мапы. Из кучи мы сможем брать максимальный элемент.
        	freqToNum := buildHeap(numToFreq)
        	// Результирующий массив.
        	res := make([]int, 0, k)
        	// Заполняем результирующий массив из кучи.
        	for i := 0; i < k; i++ {
        		// O(k*log(n))
        		node := heap.Pop(freqToNum).(node)
        		res = append(res, node.num)
        	}
        
        	return res
        }
        
        // Узел в куче.
        type node struct {
          num int // число из исходного массива
        	freq int // повторяемость (счетчик) этого числа
        }
        
        // Формирование кучи из мапы. O(n)
        func buildHeap(numToFreq map[int]int) *MaxHeap {
        	mHeap := make(MaxHeap, 0, len(numToFreq))
        	for num, freq := range numToFreq {
        		mHeap = append(mHeap, node{freq:freq, num:num})
        	}
        	// Если сортировать кучу через Init, то будет O(n),
          // если через heap.Push(), то - O(n*log(n)).
        	heap.Init(&mHeap)
        
        	return &mHeap
        }
        
        // Реализация стандартного интерфейса heap.Interface для работы с кучей.
        type MaxHeap []node
        func (h MaxHeap) Len() int {
        	return len(h)
        }
        func (h MaxHeap) Less(i, j int) bool {
        	return h[i].freq > h[j].freq
        }
        func (h MaxHeap) Swap(i, j int) {
        	// Если элементов осталось меньше двух, то переставлять нечего **(когда k может быть больше len(nums)).**
        	if len(h) >= 2 {
        		h[i], h[j] = h[j], h[i]
        	}
        }
        func (h *MaxHeap) Push(x interface{}) {
        	*h = append(*h, x.(node))
        }
        // O(k*log(n))
        func (h *MaxHeap) Pop() interface{} {
        	// Обработки предпоследнего и последнего элементов (**когда k может быть больше len(nums)**)**.**
        	// Обработка предпоследнего оставшегося элемента (len=2).
        	if len(*h) == 1 {
        	  last := (*h)[0]
        	  (*h) = nil
        	  return last
        	}
        	// Обработка последнего оставшегося элемента (len=1).
        	if len(*h) == 0 {
        	  return nil
        	}
        	old := *h
        	n := len(old)
        	x := old[n-1]
        	*h = old[:n-1]
        	return x
        }
        ```

    - Решение 2. Quickselect (Hoare's selection algorithm). TODO.
    - Решение 3 (не оптимальное). Две [хэш-таблицы](https://www.notion.so/Map-6770d8cb3ec248f0ab1e3ec6b84d054f?pvs=21).

      **Сложность: время - ??, память - ??.**

        ```go
        func topKFrequent(nums []int, k int) []int {
            numsFreq := make(map[int]int, len(nums))
            for _, num := range nums {
                numsFreq[num]++
            }
            
            freqNums := make(map[int][]int, k)
            
            maxFreq := 0
            for num, freq := range numsFreq {
                _, ok := freqNums[freq]
                if !ok {
                    freqNums[freq] = make([]int, 0)
                }
                freqNums[freq] = append(freqNums[freq], num)
                
                if freq > maxFreq {
                    maxFreq = freq
                }
            }
            
            numsRes := make([]int, 0, k)
            for i := maxFreq; i >= 0; i-- {
                numsByFreq, ok := freqNums[i]
                if !ok {
                    continue
                }
                for j := 0; j < len(numsByFreq); j++ {
                    if len(numsRes) == k {
                        break
                    }
                    numsRes = append(numsRes, numsByFreq[j])
                }
                if len(numsRes) == k {
                    break
                }
            }
            
            return numsRes
        }
        ```

    - Решение 4 (не оптимальное). [Хэш-таблица](https://www.notion.so/Map-6770d8cb3ec248f0ab1e3ec6b84d054f?pvs=21) + сортировка.
        - Заполняем мапу для

      **Сложность: время - O(n + k*log(n)), память - O(n).**

        ```go
        // Хэш-таблица + куча.
        func topKFrequent(nums []int, k int) []int {
        	// Мапа для числа и его повторяемости.
        	// Ключ - число, значение - повторяемость числа (счетчик)
        	numToFreq := make(map[int]int)
        	for _, num := range nums {
        		numToFreq[num]++
        	}
        	// Строим максимальную кучу из мапы. Из кучи мы сможем брать максимальный элемент.
        	freqToNum := buildHeap(numToFreq)
        	// Результирующий массив.
        	res := make([]int, 0, k)
        	// Заполняем результирующий массив из кучи.
        	for i := 0; i < k; i++ {
        		// O(k*log(n))
        		node := heap.Pop(freqToNum).(node)
        		res = append(res, node.num)
        	}
        
        	return res
        }
        
        // Узел в куче.
        type node struct {
            num int // число из исходного массива
        	freq int // повторяемость (счетчик) этого числа
        }
        
        // Формирование кучи из мапы. O(n)
        func buildHeap(numToFreq map[int]int) *MaxHeap {
        	mHeap := make(MaxHeap, 0, len(numToFreq))
        	for num, freq := range numToFreq {
        		mHeap = append(mHeap, node{freq:freq, num:num})
        	}
        	// Если сортировать кучу через Init, то будет O(n),
          // если через heap.Push(), то - O(n*log(n)).
        	heap.Init(&mHeap)
        
        	return &mHeap
        }
        
        // Реализация стандартного интерфейса heap.Interface для работы с кучей.
        type MaxHeap []node
        func (h MaxHeap) Len() int {
        	return len(h)
        }
        func (h MaxHeap) Less(i, j int) bool {
        	return h[i].freq > h[j].freq
        }
        func (h MaxHeap) Swap(i, j int) {
        	**// Если элементов осталось меньше двух, то переставлять нечего (когда k может быть больше len(nums)).**
        	if len(h) >= 2 {
        		h[i], h[j] = h[j], h[i]
        	}
        }
        func (h *MaxHeap) Push(x interface{}) {
        	*h = append(*h, x.(node))
        }
        // O(k*log(n))
        func (h *MaxHeap) Pop() interface{} {
        	**// Обработки предпоследнего и последнего элементов нужно когда k может быть больше len(nums).**
        	// Обработка предпоследнего оставшегося элемента (len=2).
        	if len(*h) == 1 {
        	  last := (*h)[0]
        	  (*h) = nil
        	  return last
        	}
        	// Обработка последнего оставшегося элемента (len=1).
        	if len(*h) == 0 {
        	  return nil
        	}
        	old := *h
        	n := len(old)
        	x := old[n-1]
        	*h = old[:n-1]
        	return x
        }
        ```


- Найти `**k**` наиболее **близких чисел к числу** `**x**` в **массиве**.

  [LeetCode: 658. Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements)

    - Условие

      Дан отсортированный массив чисел `arr` и числа `k` и `x`. Нужно вернуть **`k` наиболее близких чисел к числу `x`**.

      Число `a` ближе к числу `x` чем число `b`, если:

        - `|a - x| < |b - x|` OR
        - `|a - x| == |b - x|` AND `a < b`

      Учесть дубликаты в массиве.

      Учесть пропуски чисел в массиве.

      `x` может не быть в массиве.

    - Кейсы

      `arr = [1,2,3,4,5], k = 4, x = 3; res = [1,2,3,4];`

      `arr = [1,2,3,4,5], k = 4, x = -1; res = [1,2,3,4];`

      `arr = [-5,-4,-3,-2,-1,0,1], k = 4, x = -3; res = [-5,-4,-3,-2];`

      `arr = [1,1,2,3,3,3,4,6,8,8], k = 6, x = 1; res = [1,1,2,3,3,3];`

      `arr = [0,2,2,3,4,6,7,8,9,9], k = 4, x = 5; res = [3,4,6,7];`

      `arr = [0,2,2,3,4,6,7,8,9,9], k = 4, x = 9; res = [7,8,9,9];`

      `arr = [0,2,2,3,4,6,7,8,9,9], k = 4, x = -1; res = [0,2,2,3];`

    - Решение 1 (объемное). [Бинарный поиск](https://www.notion.so/8aa67c33fcbe4ce6913fc300d98e87a3?pvs=21) + [два указателя](https://www.notion.so/draft-278415d3ec1246ff9b5b016795685ef8?pvs=21).
        - Находим индекс `x` в массиве бинарным поиском.
        - Двигаемся от найденного индекса в обе стороны двумя указателями до `k` элементов.

      **Сложность: время - O(log(n) + k), память - O(1).**

        ```go
        func findClosestElements(arr []int, k int, x int) []int {
            // Левый бегунок.
            leftP := 0
            // Правый бегунок.
            rightP := len(arr) - 1
            // Если x выходит за рамки массива справа - два бегунка указывают на конец массива.
            if x >= arr[rightP] {
                leftP = rightP
            }
            // Если x выходит за рамки массива слева - два бегунка указывают на начало массива.
            if x <= arr[leftP] {
                rightP = leftP
            }
            // Бегунки могут быть равны когда всего один элемент или x выходит за рамки массива.
            // Блок с бинарным поиском.
            // В остальных случаях нам нужно вычислить позицию, где находится x в массиве.
            // От этой позиции мы пойдем бегунками в разные стороны.
            if leftP != rightP {
                for {
                    // Находим середину подмассива.
                    midP := int((leftP + rightP) / 2)
                    // Если x слева от середины - переходим в левый подмассив.
                    if x > arr[midP] {
                        leftP = midP
                    }
                    // Если x справа от середины - переходим в правый подмассив.
                    if x < arr[midP] {
                        rightP = midP
                    }
                    // Искомый x - элемент в массиве.
                    // Бегунки указывают на одну позицию.
                    if x == arr[midP] {
                        leftP = midP
                        rightP = midP
                        break
                    }
                    // Искомый x между двух элементов массива.
                    // Бегунки указывают на разные позиции.
                    if leftP + 1 == rightP {
                        break
                    }
                }
            }
        
            // Бежим от элемента, который близок к x в разные стороны
            // и сравниваем элементы под бегунками.
            for i := 0; i < k; i++ {
                // Т.к. бегунок может выйти за рамки массива, используем хак с максимальным числом.
                // Разница (по модулю) между элементом под левым бегунком и x.
                leftDiff := math.MaxInt
                // Разница (по модулю) между элементом под правым бегунком и x.
                rightDiff := math.MaxInt
                // Левый элемент под левым бегунком.
                left := math.MaxInt
                // Правый элемент под правым бегунком.
                right := math.MaxInt
                // Левый бегунок в пределах массива - вычисляем разницу и элемент.
                if leftP >= 0 {
                    leftDiff = int(math.Abs(float64(arr[leftP] - x)))
                    left = arr[leftP]
                }
                // Правый бегунок в пределах массива - вычисляем разницу и элемент.
                if rightP < len(arr) {
                    rightDiff = int(math.Abs(float64(arr[rightP] - x)))
                    right = arr[rightP]
                }
                // |l - x| < |r - x| or |l - x| == |r - x| and l < r
                if (leftDiff < rightDiff) || (leftDiff == rightDiff  && left < right) {
                    leftP--
                }
                // |l - x| > |r - x| or |l - x| == |r - x| and l >= r
                if (leftDiff > rightDiff) || (leftDiff == rightDiff  && left >= right) {
                    rightP++
                    // Элементы под бегунками могут быть равны при первой итерации:
                    // если x - элемент массива либо если x за рамками массива.
                    // В этом случае смещаем сразу два бегунка, чтобы не было дубля.
                    if left == right && i == 0 {
                        leftP--
                    }
                }
            }
        
            // Результирующий массив.
            var res []int
            for leftP += 1;leftP < rightP; leftP++ {
                res = append(res, arr[leftP])
            }
        
            return res
        }
        ```

    - Решение 2 (оптимальное, но сложное). [Бинарный поиск](https://www.notion.so/8aa67c33fcbe4ce6913fc300d98e87a3?pvs=21).

      TODO: описать.

      **Сложность: время - O(log(n - k)), память - O(1).**

        ```go
        func findClosestElements(arr []int, k int, x int) []int {
            // Левый бегунок, бежим с начала.
            leftIdx := 0
            // Левый бегунок, бежим с конца со смещением на k.
            // Т.к. нам нужно найти левую границу искомого подмассива, она точно не больше чем k.
            rightIdx := len(arr) - k
            // Левый бегунок будет являться левой границей искомого подмассива.
            // Поэтому бинарный поиск модифицированный.
            for leftIdx < rightIdx {
                midIdx := (leftIdx + rightIdx) / 2
                // midIdx < x < midIdx + k
                // [midIdx, midIdx + k] - это наш искомый подмассив
                // Идем налево, если x ближе к leftIdx.
                if x - arr[midIdx] <= arr[midIdx + k] - x {
                    // Т.к. слева у нас приоритетное добавление числа, то не плюсуем единицу.
                    rightIdx = midIdx
                } else {
                    leftIdx = midIdx + 1
                }
            }
        
            // Результирующий массив.
            var res []int
            for i := leftIdx; i < leftIdx + k; i++ {
                res = append(res, arr[i])
            }
        
            return res
        }
        ```


### Дубликаты

- **Удалить** из отсортированного массива **дублирующиеся элементы**

  [LeetCode: 26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array)

    - Условие

      Дан отсортированный массив с целыми числами. Необходимо удалить дубликаты чисел в текущем массиве (не создавая новый).

    - Кейсы

      `nums = [1,1,2]; res = 2; nums = [1,2,_];`

      `nums = [0,0,1,1,1,2,2,3,3,4]; res = 5; nums = [0,1,2,3,4,_,_,_,_,_];`

    - Решение 1. [Два указателя](https://www.notion.so/draft-278415d3ec1246ff9b5b016795685ef8?pvs=21).

      На каждой итерации сравниваем текущий элемент с прошлым.

      **Сложность: время - O(n), память - O(1).**

        ```go
        func removeDuplicates(nums []int) int {
            // Левый бегунок.
            leftIdx := 0
            // Правый бегунок, начинаем со второго элемента.
            rightIdx := 1
            for ; rightIdx < len(nums); rightIdx++ {
                // Если прошлый элемент другой, то передвигаем левый бегунок
                // и заменяем элемент под левым бегунком на текущий.
                if nums[rightIdx] != nums[rightIdx - 1] {
                    leftIdx++
                    nums[leftIdx] = nums[rightIdx]
                }
            }
        
            return leftIdx + 1
        }
        ```


- Найти **один не дублирующийся элемент** в неотсортированном массиве

  [LeetCode: 136. Single Number](https://leetcode.com/problems/single-number)

    - Условие

      Дан неотсортированный массив с целыми числами. В массиве каждое число кроме одного дублируется. Найти не дублирующееся число.

    - Кейсы

      `nums = [2,2,1]; res = 1;`

      `nums = [4,1,2,1,2]; res = 4;`

      `nums = [1]; res = 1;`

    - Решение 1. [Битовые манипуляции](https://www.notion.so/3e8a63f0597a40d9b05c30952d3bcf77?pvs=21) (XOR).
        - Объяснение

          Если применить [XOR](https://www.notion.so/3e8a63f0597a40d9b05c30952d3bcf77?pvs=21) последовательно ко всем элементам, то получим в итоге число без дубля (все дубли схлопнутся).

            ```go
            // Например на входе массив:
            [12, 1, 13, 1, 12]
            // Получим такие результаты:
            1010 // 12
            0001 // 1
            
            1011 // 12^1
            1011 // 13
            
            0000 // 12^1^13
            0001 // 1
            
            0001 // 12^1^13^1
            1010 // 12
            
            1011 (bin) = 13 (dec)
            ```


        **Сложность: время - O(n), память - O(1).**
        
        ```go
        func singleNumber(nums []int) int {
            var single int
            for _, n := range nums {
                // XOR на одинаковых числах даст 0.
                single ^= n
            }
        
            return single
        }
        ```
        
    - Решение 2. [Хэш-таблица](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21). TODO.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        
        ```


- Найти **начальный и конечный индексы числа** в отсортированном массиве если числа дублируются

  [LeetCode: 34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array)

    - Условие

      Дан отсортированный массив целый чисел и искомое число. Числа в массиве дублируются. Нужно найти начальный и конечный индексы искомого числа или вернуть `[-1,-1]`, если число не найдено.

    - Кейсы

      `nums = [5,7,7,8,8,10]; target = 8; res = [3,4];`

      `nums = [5,7,7,8,8,10]; target = 6; res = [-1,-1];`

      `nums = []; target = 0; res = [-1,-1];`

    - Решение 1: [Бинарный поиск](https://www.notion.so/8aa67c33fcbe4ce6913fc300d98e87a3?pvs=21) искомого числа + поиск границ числа.
        - Бинарным поиском ищем число
        - Во втором цикле ищем границы дублей этого числа.

      **Сложность: время - O(log(n)), память - O(1).**

        ```go
        func searchRange(nums []int, target int) []int {
            // Стартовая (левая) позиция или левый бегунок
            startP := -1
            // Конечная (правая) позиция или правый бегунок
            endP := len(nums)
            // Найденная бинарным поиском позиция target.
            roughP := -1
        
            // Если массив пустой или target вне границ массива - выходим.
            if len(nums) == 0 || target > nums[len(nums) - 1] || target < nums[0] {
                return []int{-1, -1}
            }
        
            // Пока есть разница между бегунками
            for endP - startP > 1 {
                // Вычисляем середину.
                middleP := int((startP + endP) / 2)
                
                // Если target слева от середины - смещаем правый бегунок
                if target < nums[middleP] {
                    endP = middleP
                }
                // Если target справа от середины - смещаем левый бегунок
                if target > nums[middleP] {
                    startP = middleP
                }
                // Если target посередине - мы нашли искомую позицию.
                if target == nums[middleP] {
                    roughP = middleP
                    break
                }
            }
        
            // Если не нашли искомую позицию - выходим
            if roughP == -1 {
                return []int{-1, -1}
            }
        
            // Начинаем искать границы диапазона дублирующихся target.
            startP = roughP
            endP = roughP
            // Просто в цикле итеративно расширяем окно, если в нем есть дублирующиеся target.
            // Тут можно было бы так же использовать бинарный поиск.
            for {
                // Если следующий элемент слева равен target - смещаем левый бегунок.
                // Учитываем выход за пределы массива.
                if startP - 1 >= 0 && nums[startP - 1] == target {
                    startP--
                    continue
                }
                // Если следующий элемент справа равен target - смещаем правый бегунок.
                // Учитываем выход за пределы массива.
                if endP + 1 < len(nums) && nums[endP + 1] == target {
                    endP++
                    continue
                }
                break
            }
        
            return []int{startP, endP}
        }
        ```

    - Решение 2: [Бинарный поиск](https://www.notion.so/8aa67c33fcbe4ce6913fc300d98e87a3?pvs=21).
- Найти число, **дублирующееся** не менее **n/2** раз в неотсортированном массиве (преобладающий элемент последовательности, большинство голосов)

  [LeetCode: 169. Majority Element](https://leetcode.com/problems/majority-element)

    - Условие

      Дан массив целых чисел `nums`. Найти мажоритарное число в массиве.

      **Мажоритарное число** - число, которое дублируется n/2 раз и более, т.е. **занимает бОльную часть массива**.

    - Кейсы

      `nums = [**3**,2,**3**]; res = 3;`

      `nums = [**2**,**2**,1,1,1,**2**,**2**]; res = 2;`

    - Решение 1. [Хэш-таблица](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21) с повторяемостью чисел.

      **Сложность: время - O(n), память - O(n)**

        ```go
        // Хэш-таблица
        func majorityElement(nums []int) int {
            // Нужно количество повторений числа.
            needCount := int(math.Ceil(float64(len(nums)) / 2))
            // Мапа с повторениями чисел. Ключ - число, значение - количество повторений.
            repeatable := make(map[int]int)
            for _, n := range nums {
                repeatable[n]++
                // Если нашли число с нужным количеством повторений - выходим.
                if count := repeatable[n]; count == needCount {
                    return n
                }
            }
        
            return 0
        }
        ```

    - Решение 2 (оптимальное, но сложное). [Алгоритм большинства голосов Бойера — Мура](https://www.notion.so/draft-b530f67802e141fc84d89afe38339bb2?pvs=21).

      [TODO: описать, сложный для понимания.]

      **Сложность: время - O(n), память - O(1)**

        ```go
        // Алгоритм большинства голосов Бойера — Мура.
        func majorityElement(nums []int) int {
            // Счетчик.
            count := 0
            // Самое частовстречаемое число (вычислится только в конце цикла).
            freqNum := nums[0]
            for _, num := range nums {
                // Если счетчик сбросился, считаем текущее число кандидатом на самое частотное.
                if count == 0 {
                    freqNum = num
                }
                // Если число совпадает с частовстречаемым, то инкрементируем счетчик.
                if num == freqNum {
                    count++
                } else {
                    count--
                }
            }
        
            return freqNum
        }
        ```

    - Решение 3. Сортировка подсчетом (не проверял, но должно сработать). TODO.

      **Сложность: время - O(n), память - O(n).**

        ```go
        
        ```

    - Решение 3 (неотимальное). Сортировка. TODO.

      **Сложность: время - O(n*log(n)), память - O(1)-O(n).**

        ```go
        
        ```

- Проверить, есть ли в **массиве** хоть **один** **дубликат**

  [LeetCode: 217. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)

    - Условие

      Дан массив целых чисел `nums`. Вернуть флаг, дублируется в массиве хоть один элемент.

    - Кейсы

      `nums = [**1**,2,3,**1**]; res = true;`

      `nums = [1,2,3,4]; res = false;`

      `nums = [**1**,**1**,**1**,**3**,**3**,**4**,**3**,**2**,**4**,**2**]; res = false;`

    - Решение 1 (оптимальное по времени). [Хэш-таблица](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21) с повторяемостью чисел.

      **Сложность: время - O(n), память - O(n)**

        ```go
        // Хэш-таблица.
        func containsDuplicate(nums []int) bool {
            // Мапа для хранения уникальных чисел. Ключ - число, значение - не интересно.
            numCounters := make(map[int]struct{})
            for _, n := range nums {
                // Если число уже есть в мапе - выходим.
                if _, ok := numCounters[n]; ok {
                    return true
                }
                numCounters[n] = struct{}{}
            }
        
            return false
        }
        ```

    - Решение 2 (оптимальное по памяти). Сортировка.

      **Сложность: время - O(n*log(n)), память - O(1)-O(n).** Если использовать сортировку кучей, то память будет O(1).

        ```go
        func containsDuplicate(nums []int) bool {
            if len(nums) <= 1 {
                return false
            }
            
            // Time: O(nlogn)
            sort.Ints(nums)
            
            // Time: O(n)
            for i := 0; i < len(nums)-1; i++ {
                if nums[i] == nums[i+1] {
                    return true
                }
            }
            
            return false
        }
        ```


### **Поиск числа** по изначально отсортированному массиву с возможной **точкой разворота**

- **Поиск заданного числа** по изначально отсортированному массиву с возможной **точкой разворота** массива **без дубликатов**

  [LeetCode: 33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array)

    - Условие

      Изначально дан отсортированный по возрастанию (**без дубликатов**) массив целый чисел и искомое число. Массив может быть повернут относительно неизвестного индекса в массиве. Например, в массиве `[0,1,2,4,5,6,7]` может быть выбран индекс `3` как точка разворота и входящий массив станет `[4,5,6,7,0,1,2]`. Нужно найти индекс искомого числа или вернуть `-1`, если число не найдено.

    - Кейсы

      `nums = [4,5,6,7,0,1,2]; target = 0; res = 4;`

      `nums = [4,5,6,7,0,1,2]; target = 3; res = -1;`

      `nums = [1]; target = 0; res = -1;`

    - Решение 1: [Бинарный поиск](https://www.notion.so/8aa67c33fcbe4ce6913fc300d98e87a3?pvs=21).
        - Визуализация

          ![IMG_5419.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/IMG_5419.jpg)


        Используем бинарный поиск но определим дополнительные условия когда нам нужно двигаться вправо, а когда влево.
        
        **Сложность: время - O(log(n)), память - O(1).**
        
        ```go
        func search(nums []int, target int) int {
            // Левый бегунок.
            leftIdx := 0
            // Правый бегунок.
            rightIdx := len(nums) - 1
        
            for {
                // Средний индекс. Всегда округляется в меньшую сторону.
                midIdx := int((leftIdx + rightIdx) / 2)
                // Нашли искомый элемент.
                if nums[midIdx] == target {
                    return midIdx
                }
                fmt.Println(leftIdx, rightIdx)
                // Не нашли искомый элемент.
                if leftIdx > rightIdx {
                    break
                }
                // Т.к. у нас может быть точка разворота,
                // у нас усложняются условия по переходу в левый или правый подмассив.
                // Уходим в левый подмассив, когда:
                // s->t->m; t < m < s - разворот между s и t
                // s->t->m; s <= t < m - разворот справа от m
                // s->t->m; m < s <= t - разворот между t и m
                if target < nums[midIdx] && nums[midIdx] < nums[0] ||
                    nums[0] <= target && target < nums[midIdx] || 
                    nums[midIdx] < nums[0] && nums[0] <= target {
                    // Средний элемент мы уже сравнили.
                    // Если не смещать, то когда левый и правый бегунок будут рядом - 
                    // получим бесконечный цикл.
                    rightIdx = midIdx - 1
                // Уходим в правый подмассив, когда:
                // s->m->t; s < m < t - разворот справа от t
                // s->m->t; m < t < s - разворот между s и m
                // s->m->t; t < s < m - разворот между m и t
                } else {
                    leftIdx = midIdx + 1
                }
            }
        
            return -1
        }
        ```

- **Поиск заданного числа** по изначально отсортированному массиву с возможной **точкой разворота** массива **с дубликатами**

  [LeetCode: 81. Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii)

    - Условие

      Изначально дан отсортированный по неубыванию (**с дубликатами**) массив целый чисел и искомое число. Массив может быть повернут относительно неизвестного индекса в массиве. Например, в массиве `[0,1,2,4,5,6,7]` может быть выбран индекс `3` как точка разворота и входящий массив станет `[4,5,6,7,0,1,2]`. Нужно вернуть `true` если искомое число найдено и `false` если не найдено.

    - Кейсы

      `nums = [2,5,6,0,0,1,2]; target = 0; res = true;`

      `nums = [2,5,6,0,0,1,2]; target = 3; res = false;`

    - Решение 1: [Бинарный поиск](https://www.notion.so/8aa67c33fcbe4ce6913fc300d98e87a3?pvs=21) + перебор.
        - Визуализация

          ![IMG_5419.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/IMG_5419.jpg)

          ![Кейс когда непонятно в какой подмассив идти (в правый или в левый).](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/IMG_5422.jpg)

          Кейс когда непонятно в какой подмассив идти (в правый или в левый).


        Используем бинарный поиск но определим дополнительные условия когда нам нужно двигаться вправо, а когда влево. Из-за дубликатов есть корнер-кейс когда `s == m && s != t`. При этом кейсе мы не понимаем куда двигаться, поэтому используем второй цикл с простым перебором.
        
        **Сложность: время - O(log(n))-O(n), память - O(1).**
        
        ```go
        func search(nums []int, target int) bool {
            // Левый бегунок, начинает с начала.
            leftIdx := 0
            // Правый бегунок, начинает с конца.
            rightIdx := len(nums) - 1
            // Стартовый элемент.
            start := nums[0]
            // Пока бегунки не встретятся.
            for leftIdx <= rightIdx {
                // Вычисляем индекс посередине бегунков.
                // Если четное количество элементов в подмассиве с бегунками,
                // то середина будет левым элементом, а не правым (из-за приведения Go).
                midIdx := (leftIdx + rightIdx) / 2
                // Элемент посередине.
                mid := nums[midIdx]
                // Если искомый элемент равен серединному или элементам под бегунками, то
                // искомый найден.
                if mid == target || nums[leftIdx] == target || nums[rightIdx] == target {
                    return true
                }
        
                // Уходим вправо.
                if start < mid && target < start || // s->m->t, разворот m-t
                    start < mid && target > mid || // s->m->t, разворот t+
                    target > mid && target < start { // s->m->t, разворот s-m
                    leftIdx = midIdx + 1
                    continue
                }
                // Уходим влево.
                if start < target && target < mid || // s->t->m, разворот m+
                    start > mid && target < mid || // s->t->m, разворот s-t
                    start < target && mid < start { // s->t->m, разворот t-m
                    rightIdx = midIdx - 1
                    continue
                }
                // Сюда попадем когда s == m && s != t
                // В этом случае нельзя применить бинарный поиск,
                // т.к. не понятно куда идти. Поэтому тут просто перебираем.
                // nums=[1,1,2]; target=2
                // nums=[1,2,1,1,1]; target=2
                // nums=[1,1,0]; target=0
                // nums=[1,0,1,1,1]; target=0
                leftIdx++
                rightIdx--
            }
        
            return false
        }
        ```

- **Поиск минимального числа** по изначально отсортированному массиву с возможной **точкой разворота** массива **без дубликатов**

  [LeetCode: 153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)

    - Условие

      Изначально дан отсортированный по возрастанию (**без дубликатов**) массив целый чисел. Массив может быть повернут относительно неизвестного индекса в массиве. Например, в массиве `[0,1,2,4,5,6,7]` может быть выбран индекс `3` как точка разворота и входящий массив станет `[4,5,6,7,0,1,2]`. Нужно найти индекс минимального числа.

    - Кейсы

      `nums = [3,4,5,1,2]; res = 1;`

      `nums = [4,5,6,7,0,1,2]; res = 0;`

      `nums = [11,13,15,17]; res = 11;`

      `nums = [1]; res = 1;`

      `nums=[3,1,2]; res = 1;`

    - Решение 1: [Бинарный поиск](https://www.notion.so/8aa67c33fcbe4ce6913fc300d98e87a3?pvs=21) со сравнением стартового элемента, среднего элемента и искомого числа.
        - Визуализация

          ![IMG_5419.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/IMG_5419.jpg)


        Решение аналогично [поиску заданного числа в массиве с точкой разворота](https://www.notion.so/dd650cdfec394840a4b21483998f5e07?pvs=21), только заменим `target` минимальным int-ом и в конце вернем левый бегунок.
        
        Используем бинарный поиск но определим дополнительные условия когда нам нужно двигаться вправо, а когда влево.
        
        **Сложность: время - O(log(n)), память - O(1).**
        
        ```go
        func findMin(nums []int) int {
            // Если массив без разворота - выходим.
            if nums[0] < nums[len(nums) - 1] || len(nums) == 1 {
                return nums[0]
            }
            // Левый бегунок для подмассива поиска, бежим с начала.
            leftIdx := 0
            // Левый бегунок для подмассива поиска, бежим с конца.
            rightIdx := len(nums) - 1
            // Фиктивный искомый элемент.
            target := math.MinInt
            // Пока бегунки не встретятся.
            for leftIdx <= rightIdx {
                // Индекс среднего элемента. Если средних элементов два, средним будет левый.
                midIdx := (leftIdx + rightIdx) / 2
                // Стартовый элемент (для удобства сравнения).
                start := nums[0]
                // Средний элемент в текущем подмассиве поиска (для удобства сравнения).
                mid := nums[midIdx]
                // Идем вправо.
                if start <= mid && target < start || // s->m->t, разворот m-t
                    start <= mid && target > mid || // s->m->t, разворот t+
                    start >= target && target > mid { // s->m->t, разворот s-m
                    leftIdx = midIdx + 1
                } else {
                    // Идем влево в остальных случаях.
                    rightIdx = midIdx - 1
                }
            }
        
            return nums[leftIdx]
        }
        ```
        
    - Решение 2: [Бинарный поиск](https://www.notion.so/8aa67c33fcbe4ce6913fc300d98e87a3?pvs=21) со сравнением стартового, среднего и конечного элементов. TODO.
        
        **Сложность: время - O(log(n)), память - O(1).**
        
        ```go
        
        ```


### Максимальный профит при покупке-продажи акций

- Найти **максимальную разницу** между **минимальным и максимальным** значениями элементов (**максимальный профит** между **одной** покупкой и продажей **акций**)

  [LeetCode: 121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)

    - Условие

      Дан массив с целыми числами. Аналогично ценам на акцию за каждый день в определенный период. Необходимо найти максимальную разницу между ценами (между минимальным и максимальным значениями элементов). Нельзя учитывать разницу когда сначала идет максимальный, потом минимальный элемент (сначала надо купить, потом продать).

      ![121_profit_graph.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/121_profit_graph.png)

    - Кейсы

      `prices = [7,1,5,3,6,4]; res = 5;` - максимальный профит `6([4]) - 1([1]) = 5`

      `prices = [7,6,4,3,1]; res = 0;`

      `prices = [2,8,3,1]; res = 6;`

    - Решение 1 (оптимальное). Запоминаем минимальный элемент и вычисляем максимальную разницу с текущим элементом.
        - Визуализация

          ![121_profit_graph.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/121_profit_graph%201.png)


        **Сложность: время - O(n), память - O(1).**
        
        ```go
        func maxProfit(prices []int) int {
            // Минимальная цена
            minPrice := math.MaxInt
            // Максимальный профит
            maxDiff := 0
            for _, p := range prices {
                // Если нашли цену ниже - обновляем и продолжаем
                if p < minPrice {
                    minPrice = p
                    continue
                }
                // Если текущий профит больше максимального - обновляем
                if (p - minPrice) > maxDiff {
                    maxDiff = p - minPrice
                }
            }
            // Это решение покрывает кейс: [2,8,3,1].
            // Максимальный профит установится в самом начале,
            // а минимальная цена установится в конце,
            // но никак не повлияет обновление максимального профита.
            // В отличие от решения с обновлением максимальной цены.
        
            return maxDiff
        }
        ```

- Найти **максимальную серию диапазонов** между **минимальным и максимальным** значениями элементов (**максимальный профит** между **всеми** возможными покупками и продажами **акций**)

  [LeetCode: 122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)

    - Условие

      Дан массив с целыми числами. Аналогично ценам на акцию за каждый день в определенный период. Необходимо найти максимальную серию диапазонов цен (между минимальным и максимальным значениями элементов). Вернуть максимально возможный профит.

      Нельзя учитывать разницу когда сначала идет максимальный, потом минимальный элемент (сначала надо купить, потом продать). Количество операций покупка-продажа не ограничено.

    - Кейсы

      `prices = [7,1,5,3,6,4]; res = 7;` - максимальный профит `5([2]) - 1([1]) + 6([4]) - 3([3])`

      `prices = [1,2,3,4,5]; res = 4;`

      `prices = [7,6,4,3,1]; res = 0;`

    - Решение 1 (оптимальное). Суммируем профит если цена идет вверх.
        - Визуализация

          ![122_maxprofit_2.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/122_maxprofit_2.png)


        **Сложность: время - O(n), память - O(1).**
        
        ```go
        func maxProfit(prices []int) int {
            // Результирующий профит.
            maxProfit := 0
            for i := 1; i < len(prices); i++ {
                // Если цена идет вверх,
                // то просто прибавляем разницу в цене в результирующий профит.
                // Если цена идет вниз, то ничего не делаем.
                if prices[i] > prices[i - 1] {
                    maxProfit += prices[i] - prices[i - 1]
                }
            }
        
            // Можно было бы добавить состояние (куплено / не куплено),
            // минимаьлную цену покупки и второе условие, когда цена идет вниз -
            // продавать и фиксировать прибыль. Но текущее решение более простое.
        
            return maxProfit
        }
        ```
        
    - Решение 2. Суммируем профит если была покупка.
        
        **Сложность: время - O(n), память - O(1).**
        
        ```go
        func maxProfit(prices []int) int {
            curMin := 0
            isPurchased := false
            maxProfit := 0
            i := 1
            for ; i < len(prices); i++ {
                if !isPurchased && prices[i] > prices[i - 1] {
                    curMin = prices[i - 1]
                    isPurchased = true
                    continue
                }
                if isPurchased && prices[i] < prices[i - 1] {
                    maxProfit += prices[i - 1] - curMin
                    isPurchased = false
                    curMin = 0
                    continue
                }
            }
        
            if isPurchased {
                maxProfit += prices[i - 1] - curMin
            }
        
            return maxProfit
        }
        ```

- Найти **максимальный профит** между **всеми** возможными покупками и продажами **акций** с учетом **комиссии**

  [LeetCode: 714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)

  [TODO: описать решение подробнее и решить более просто]

    - Условие

      Дан массив с целыми числами. Аналогично ценам на акцию за каждый день в определенный период. Необходимо найти максимальную серию диапазонов цен (между минимальным и максимальным значениями элементов) с учетом комиссии за продажу. Вернуть максимально возможный профит.

      Нельзя учитывать разницу когда сначала идет максимальный, потом минимальный элемент (сначала надо купить, потом продать). Количество операций покупка-продажа не ограничено.

    - Кейсы

      `prices = [1,3,2,8,4,9], fee = 2; res = 8;` - максимальный профит `((8 - 1) - 2) + ((9 - 4) - 2) = 8`

      `prices = [1,3,7,5,10,3], fee = 3; res = 6;`

    - Решение 1 (объемное). Суммируем профит с учетом покупки, продажи и комиссии.

      **Сложность: время - O(n), память - O(1).**

        ```go
        func maxProfit(prices []int, fee int) int {
            // Минимальная цена (цена потенциальной покупки).
            minPrice := prices[0]
            // Максимальная цена (цена потенциальной продажи).
            maxPrice := prices[0]
            // Результирующий профит.
            maxProfit := 0
            // Итерируемся с 1го элемента, т.к. нам нужна как минимум пара элементов.
            for i := 1; i < len(prices); i++ {
                // Если текущая цена ниже максимальной с учетом комиссии
                // И есть профит от транзакции (с учетом комиссии),
                // то делаем транзакцию (продаем).
                if maxPrice - prices[i] > fee && maxPrice - minPrice - fee > 0 {
                    // Профит - разница между покупкой и продажей за вычетом комиссии.
                    maxProfit += maxPrice - minPrice - fee
                    // Переопределяем макс и мин цены.
                    minPrice = prices[i]
                    maxPrice = prices[i]
                    continue
                }
                // Если можем купить дешевле - покупаем.
                if prices[i] < minPrice {
                    minPrice = prices[i]
                    // Т.к. цена продажи должна быть после цены покупки, то сбрасываем.
                    maxPrice = prices[i]
                }
                // Если можем продать дороже - фиксируем потенциальную цену продажи.
                if prices[i] > maxPrice {
                    maxPrice = prices[i]
                }
            }
        
            // Надо обработать последнюю продажу, если она уместна.
            if maxPrice - minPrice - fee > 0 {
                maxProfit += maxPrice - minPrice - fee
            }
        
            return maxProfit
        }
        ```

- Найти **максимальный профит** между **всеми** возможными покупками и продажами **акций** с учетом паузы

  [LeetCode: 309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown)

  [TODO: разобрать решение, непонятное]

    - Условие

      Дан массив с целыми числами `prices`. Аналогично ценам на акцию за каждый день в определенный период. Необходимо найти максимальную серию диапазонов цен (между минимальным и максимальным значениями элементов) с учетом паузы в один день после продажи. Вернуть максимально возможный профит.

      Нельзя учитывать разницу когда сначала идет максимальный, потом минимальный элемент (сначала надо купить, потом продать). Количество операций покупка-продажа не ограничено.

    - Кейсы

      `prices = [1,2,3,0,2]; res = 3;` - максимальный профит `[buy, sell, pause, buy, sell]`

      `prices = [1]; res = 0;`

    - Решение 1 (оптимальное, но сложное). Оперируем состояниями.
        - Визуализация переходов состояний

          ![309_state_machine.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/309_state_machine.png)

          ![231f7274-a7f3-4b7c-9b0d-3572706041d2_1672006116.9163399.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/231f7274-a7f3-4b7c-9b0d-3572706041d2_1672006116.9163399.png)

        - Пример

          ![309_graph.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/309_graph.png)

          ![e6d60ef6-ef61-46e1-be2a-c690858b8329_1672006079.1507285.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/e6d60ef6-ef61-46e1-be2a-c690858b8329_1672006079.1507285.png)


        [TODO: разобрать решение, непонятное]
        
        **Сложность: время - O(n), память - O(1).**
        
        ```go
        func maxProfit(prices []int) int {
            pause, sell, bought := 0, 0, math.MinInt64
            
            for _, price := range prices{
                prevPause := pause
                prevSell := sell
                prevBought := bought
                
                pause = max(prevPause, prevSell)
                sell = prevBought + price
                bought = max(prevBought, prevPause - price)    
            }
            
            return max(sell, pause)
        }
        
        func max(a, b int) int {
            if a > b {
                return a
            }
            return b
        }
        ```


### Найти пересечение или разницу массивов  (`JOIN`)

- Полезное

  [Алгоритмы слияния массивов [draft]](https://www.notion.so/draft-658ce243bb0a469caccf3b8c298bdec0?pvs=21)

  В основном используются 3 алгорима: nested loop, hash join, merge join.
  **Nested loop** это простой перебор вложенным циклом, сложность - O(n^2). Малоэффективный.
  Для **merge join** массивы должны быть отсортированы. Либо нужно их предварительно сортировать. Сложность - O(n*log(n) + m*log(m)). Память - O(log(n) + log(m)).
  В **hash join** используется хэш-таблица. Для создания хэш-таблицы нужно выбрать меньший массив. По сложности - O(n+m), но расходуется память - O(m).

    - Визуализация JOIN-ов в SQL

      ![LEFT vs Right Outer Join in SQL.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/LEFT_vs_Right_Outer_Join_in_SQL.png)

- Найти **пересечение** двух **неотсортированных** массивов, результирующий массив **без дублей  (`INNER JOIN`)**.

  [LeetCode: 349. Intersection of Two Arrays](https://leetcode.com/problems/intersection-of-two-arrays)

    - Условие

      Даны **два неотсортированных целочисленных массива** `nums1`, `nums2` с **дубликатами**. Необходимо **слить** их в один массив (выбрать элементы присутствующие только в обоих массивах) и вернуть этот массив.

      В результирующем массиве не должно быть **дублей**.

      Числа в массивах находятся в диапазоне от 0 до 1000.

      Порядок чисел в результирующем массиве не важен.

    - Кейсы

      `nums1 = [1,2,2,1], nums2 = [2,2]; res = [2];`

      `nums1 = [4,9,5], nums2 = [9,4,9,8,4]; res = [9,4]; || res = [4,9];`

    - **Решение 1 (оптимальное и простое). [Хэш-таблица](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21).**
        - Составляем хэш-таблицу с уникальными числами для первого массива для быстрого поиска.
        - Ищем пересечения чисел второго массива и хэш-таблицы.

      **Сложность: время - O(n+m), память - O(n).**

        ```go
        // Хэш-таблица.
        func intersection(nums1 []int, nums2 []int) []int {
            **// TODO: можно делать мапу по меньшему массиву, но в данном случае массивы не велики.**
            // Мапа для уникальных чисел в первом массиве.
        		// Ключ - число, значение = true, если элемент присутствует.
            n1 := make(map[int]bool)
            // Результирующий массив.
            var res []int
            // Заполняем из первого массива неповторяющиеся элементы.
            for _, n := range nums1 {
                n1[n] = true
            }
        
            // Ищем пересекающиеся числа из второго массива в мапе.
            for _, n := range nums2 {
                // Если такое же число есть в первом массиве.
                if n1[n] == true {
                    // Добавляем это число в результирующий массив.
                    res = append(res, n)
                    // Также помечаем этот элемент как уже обработанный, чтобы исключить дубли.
                    n1[n] = false
                }
            }
        
            return res
        }
        ```


- Найти **пересечение** двух **неотсортированных** массивов, результирующий массив **с дублями (`INNER JOIN`)**

  [LeetCode: 350. Intersection of Two Arrays II](https://leetcode.com/problems/intersection-of-two-arrays-ii/)

    - Условие

      Даны **два неотсортированных целочисленных массива** `nums1`, `nums2` с **дубликатами**. Необходимо **слить** их в один массив (выбрать элементы присутствующие в обоих массивах) и вернуть этот массив.

      В результирующем массиве должны быть **все пересечения чисел, учитывая дубли**.

      Числа в массивах находятся в диапазоне от 0 до 1000.

      Порядок чисел в результирующем массиве не важен.

    - Кейсы

      `nums1 = [1,2,2,1], nums2 = [2,2]; res = [2,2];`

      `nums1 = [4,9,5], nums2 = [9,4,9,8,4]; res = [9,4]; || res = [4,9];`

      `nums1 = [1,2,2], nums2 = [1,2,2]; res = [1,2,2];`

    - **Решение 1 (оптимальное и простое). [Хэш-таблица](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21).**
        - Составляем хэш-таблицу с повторяемостью чисел для первого массива (для быстрого поиска).
        - Ищем пересечения чисел второго массива и хэш-таблицы.
        - Пример

          ![350_approach1-v2.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/350_approach1-v2.png)


        **Сложность: время - O(n+m), память - O(n).**
        
        ```go
        // Хэш-таблица.
        func intersect(nums1 []int, nums2 []int) []int {
            // Маленький массив.
            numsS := nums1
            // Большой массив.
            numsB := nums2
            if len(nums1) > len(nums2) {
                numsS = nums2
                numsB = nums1
            }
        
            // Мапа по маленькому массиву.
            numsSMap := make(map[int]int)
            // Для каждого числа в массиве считаем сколько раз он встречается (счетчик).
            for _, n := range numsS {
                numsSMap[n]++
            }
        
            // Результирующий массив.
            var res []int
            for _, n := range numsB {
                // Если число из бОльшего массива встречается в меньшем,
                // то уменьшаем счетчик этого числа в меньшем массиве и добавляем его в результирующий.
                if count := numsSMap[n]; count > 0 {
                    numsSMap[n]--
                    res = append(res, n)
                }
            }
        
            return res
        }
        ```
        
    - Решение 2 (простое, подходит только при определенных условиях). Сортируем и используем метод [сортировки слиянием](https://www.notion.so/merge-sort-018bc67a236b46098e566e6ec8b9c158?pvs=21).
        
        Можно использовать, когда входные массивы отсортированы, либо нужно, чтобы результирующий массив был отсортирован.
        
        - Пример
            
            ![350_approach2-v2.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/350_approach2-v2.png)
            
        
        **Сложность: время - O(n*log(n)+m*log(m)), память - O(n*log(n)+m*log(m))-O(n+m).**
        
        ```go
        // Сортируем массивы и используем метод сортировки слиянием.
        func intersect(nums1 []int, nums2 []int) []int {
            // Сортируем входные массивы.
            sort.Ints(nums1)
            sort.Ints(nums2)
            // Бегунки в первом и втором массивах.
            idx1, idx2 := 0, 0
            // Результирующий массив.
            var res []int
            // Пока не выйдем за рамки хоть одного массива.
            for idx1 < len(nums1) && idx2 < len(nums2) {
                // Если элемент первого массива больше, чем элемент второго,
                // то сдвигаем только бегунок первого массива.
                if nums1[idx1] < nums2[idx2] {
                    idx1++
                    continue
                }
                // Если элемент второго массива больше, чем элемент первого,
                // то сдвигаем только бегунок второго массива.
                if nums1[idx1] > nums2[idx2] {
                    idx2++
                    continue
                }
                // Сюда пришли когда элементы равны.
                // Добавляем элемент в результат и сдвигаем оба бегунка.
                res = append(res, nums1[idx1])
                idx1++
                idx2++
            }
        
            return res
        }
        ```
        
    - Отличия решений
        
        Решение данной задачи можно почерпнуть из реляционных БД (операция JOIN).
        
        В основном используются 3 алгорима: nested loop, hash join, merge join.
        
        Nested loop это простой перебор, сложность - O(n^2). Малоэффективный.
        
        Для merge join массивы должны быть отсортированы. Либо нужно их предварительно сортировать. Сложность - O(nlogn + mlogm). Память - O(logn + logm).
        
        В hash join используется хэш-таблица. Для создания хэш-таблицы нужно выбрать меньший массив. По сложности - O(n+m), но расходуется память - O(m).
        
        What if the given array is already sorted? How would you optimize your algorithm?
        
        Лучше использовать алгоритм merge join.
        
        What if nums1's size is small compared to nums2's size? Which algorithm is better? Если nums1 совсем маленький и нам критично использовать меньше памяти,то можно воспользоваться nested loop. Если память не критична, то однозначно hash join.
        
        What if elements of nums2 are stored on disk,and the memory is limited such that you cannot load all elements into the memory at once?
        
        В БД для хэш-таблиц, которые не влезают в память, обычно применяется батчевание. Т.к. мы берем хэш от ключа, значение которого это целочисленный индекс массива,то мы можем использовать диапазоны этих индексов для разбивки на батчи. При этом каждый батч последовательно помещается в память, а остальные хранятся на диске. Но в рамках Go для этого придется написать свою реализацию хэш-таблицы. [TODO: подумать над решением.]


- В **неотсортированных** массивов с **дублями** найти **элементы первого массива**, которых **нет во втором массиве** и элементы второго массива, которых нет в первом массиве **(`LEFT JOIN WHERE arr2 is null`** и **`RIGHT JOIN WHERE arr1 is null`)**

  [LeetCode: 2215. Find the Difference of Two Arrays](https://leetcode.com/problems/find-the-difference-of-two-arrays)

    - Условие

      Даны **два неотсортированных целочисленных массива** `nums1`, `nums2` с **дубликатами**. Необходимо найти уникальные элементы (**без дублей**) из первого массива, которых нет во втором массиве и найти уникальные элементы из второго массива, которых нет во первом массиве. Т.е. вернуть два массива.

      Порядок чисел в результирующем массиве не важен.

    - Кейсы

      `nums1 = [1,2,3], nums2 = [2,4,6]; res = [[1,3],[4,6]];`

      `nums1 = [1,2,3,3], nums2 = [1,1,2,2]; res = [[3],[]];`

    - **Решение 1 (оптимальное). [Хэш-таблица](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21).**
        - Составляем хэш-таблицу с присутствием чисел. Если число присутствует только в первом массиве значение `=1`, если только во втором `=2`, если в обоих `=0`.
        - Формируем результирующие массивы из хэш-таблицы для значений `1` или `2`.

      **Сложность: время - O(n+m), память - O(max(n,m)).**

        ```go
        // нам нужно найти пересечение, точнее JOIN
        func findDifference(nums1 []int, nums2 []int) [][]int {
        		**// TODO: можно сделать две мапы.**
            // мапа куда будем скаладывать числа для быстрой проверки на пересечение
            // значения мапы: 1 - массив найден в первом массиве, 2 - во втором, 0 - в обоих
            intersection := make(map[int]uint8)
            // заполняем мапу для первого массива
            for _, n := range nums1 {
                intersection[n] = 1
            }
        
            // заполняем мапу для второго массива
            for _, n := range nums2 {
                whose, ok := intersection[n];
                // если нашелся элемент, который был в первом массивеб
                // то помечаем элемент как не нужный
                if ok && whose == 1 {
                    intersection[n] = 0
                    continue
                }
                // если это не нужный или элемент из второго массива - пропускаем
                if ok && (whose == 0 || whose == 2) {
                    continue
                }
                // остался только элемент, который не был записан
                // помечаем его как элемент из второго массива
                intersection[n] = 2
            }
        
            // результирующие массивы
            var res1, res2 []int
            // перебираем мапу и складываем числа (ключи мапы) в результирующие массивы
            // в зависимости от значения ключа
            for n, whose := range intersection {
                if whose == 1 {
                    res1 = append(res1, n)
                    continue
                }
                if whose == 2 {
                    res2 = append(res2, n)
                }
            }
        
            return [][]int{res1, res2}
        }
        ```


- Найти **элементы первого массива**, которых **нет во втором массиве**, если оба массива **отсортированы** и есть **дубли** (`**LEFT JOIN WHERE arr2 is null**`)
    - Условие

      Даны **два неотсортированных целочисленных массива** `nums1`, `nums2` с **дубликатами**. Необходимо найти элементы (**с дублями**) из первого массива, которых нет во втором массиве.

    - Кейсы

      `nums1 = [1,2,4], nums2 = [1,2,3,4,5]; res = [];`

      `nums1 = [1,2,3,5,6], nums2 = [1,2,4]; res = [3,5,6];`

      `nums1 = [1,2], nums2 = []; res = [1,2];`

      `nums1 = [], nums2 = [1,2]; res = [];`

      `nums1 = [], nums2 = []; res = [];`

      `nums1 = [0,3,3,3], nums2 = [1,3]; res = [0];`

      `nums1 = [1,2,2,3], nums2 = [1,2,4]; res = [3];`

      `nums1 = [10,20,30], nums2 = [19,20,21]; res = [10,30];`

      `nums1 = [1,2,3,4], nums2 = [19,20,21,22]; res = [1,2,3,4];`

    - **Решение 1 (оптимальное). Перебор со сравнением.**

      **Сложность: время - O(len(nums1)), память - O(len(res)).**

        ```go
        // Важные кейсы:
        // элементы второго массива закончились, а первого нет
        // элементы первого массива закончились, а второго нет
        // nums1 = [1,2,2,2,3], nums2 = [1,2]
        // nums1 = [0,3,3], nums2 = [1,3]
        func array1DiffArray2(nums1 []int, nums2 []int) []int {
        	// Результирующий массив.
        	var res []int
        	// Бегунки для первого и второго массивов.
        	idx1, idx2 := 0, 0
        	// Пока не вышли за рамки одного из массивов.
        	// Включаем кейс: элементы первого массива закончились, а второго нет.
        	for idx1 < len(nums1) && idx2 < len(nums2) {
        		// Если элемент второго массива меньше чем элемент первого -
        		// сдвигаем бегунок второго массива и выходим из итерации.
        		if nums2[idx2] < nums1[idx1] {
        			idx2++
        			continue
        		}
        		// Если элемент первого массива меньше чем элемент второго -
        		// добавляем элемент первого массива (мы нашли искомый элемент).
        		if nums1[idx1] < nums2[idx2] {
        			res = append(res, nums1[idx1])
        		}
        		// Сюда пришли когда элемент первого массива не больше (<=) элемента второго массива.
        		// Смещаем бегунок первого массива.
        		// Если элементы равны, то смещать второй бегунок не нужно, иначе не покроем кейс:
        		// nums1 = [0,3,3], nums2 = [1,3].
        		idx1++
        	}
        	// Элементы второго массива закончились, а первого нет.
        	// В первом цикле обработать этот кейс более сложно, чем отдельно.
        	for ; idx1 < len(nums1); idx1++ {
        		// Если второй массив пуст или элемент из первого массива больше чем второй -
        		// добавляем элемент в результирующий массив.
        		// Покрываем кейс: nums1 = [0,3,3,3], nums2 = [1,3].
        		if len(nums2) == 0 || nums1[idx1] > nums2[len(nums2)-1] {
        			res = append(res, nums1[idx1])
        		}
        	}
        
        	return res
        }
        ```

- Найти **пересечение** нескольких **неотсортированных** массивов, результирующий массив должен быть **без дублей и отсортирован  (`INNER JOIN`)**.

  [LeetCode: 2248. Intersection of Multiple Arrays](https://leetcode.com/problems/intersection-of-multiple-arrays)

    - Условие

      Дан двумерный массив  `nums` ****с **неотсортированными целочисленных массивами** с **дубликатами**. Необходимо **слить** их в один массив (выбрать элементы присутствующие только во всех массивах) и вернуть этот массив.

      В результирующем массиве не должно быть **дублей**.

      Результирующий массив должен быть **отсортирован**.

      Числа в массивах находятся в диапазоне от 0 до 1000.

    - Кейсы

      `nums = [[**3**,1,2,**4**,5],[1,2,**3**,**4**],[**3**,**4**,5,6]]; res =` `[3,4];`

      `nums = [[1,2,3],[4,5,6]]; res = [];`

    - **Решение 1 (оптимальное и простое). [Хэш-таблица](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21) для счетчиков чисел + сортировка.**
        - Составляем хэш-таблицу с уникальными числами для всех массивов для быстрого поиска.
        - Если счетчик равен количеству массивов чисел, то мы нашли искомое число.
        - Сортируем результирующий массив.

      **Сложность: время - O(n*m), память - O(k)**, n - количество массивов, m - среднее количество элементов в массивах, k - уникальные элементы во всех массивах.

        ```go
        // Хэш-таблица для счетчиков чисел + сортировка.
        func intersection(nums [][]int) []int {
        	// Счетчики чисел. Ключ - число, значение - повторяемость числа во всех массивах.
            numCounts := make(map[int]int)
        	// Результирующий массив.
            var res []int
        	for _, numss := range nums {
        		for _, num := range numss {
        			// Увеличиваем счетчик числа.
        			numCounts[num]++
        			// Если счетчик равен количеству массивов чисел, то мы нашли искомое число.
        			// Это работает, т.к. числа в рамках каждого массива уникальные.
        			if numCounts[num] == len(nums) {
        				// Добавляем в результирующий массив.
        				res = append(res, num)
        			}
        		}
        	}
        	// Без сортировки никак.
        	sort.Ints(res)
        	return res
        }
        ```


### Найти подпоследовательность (подпоследовательности)

- Полезное

  **Подпоследовательность** - последовательность элементов массива, в которой сохраняется порядок элементов массива, но элементы массива можно пропускать.

  массив - `[1,5,7,4,3]`; подпоследовательность - `[1,7,3]`; подмассив - `[1,5,7]`;

  Т.е. в подмассиве нельзя пропускать элементы, а в подпоследовательности можно.

- Найти **наибольшую возрастающую подпоследовательность** (longest increasing subsequence)

  [LeetCode: 300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence)

    - Условие

      Дан несортированный массив с целыми числами `nums`. Необходимо найти подпоследовательность максимального размера такую, что элементы подпоследовательности строго возрастают.

    - Кейсы

      `nums = [10,9,2,5,3,7,101,18]; res = 4;` - подпоследовательность: `[2,3,7,101] || [2,3,7,18]`;

      `nums = [10,9,2,5,3,7,101,18,19]; res = 5;` - подпоследовательность: `[2,3,7,18,19]`;

      `nums = [0,1,0,3,2,3]; res = 4;`

      `nums = [7,7,7,7,7,7,7]; res = 1;`

    - Решение 1 (простое, не самое быстрое). Всплытие отсутствующего элемента в подпоследовательности.
        - Пример

          `nums = [10,9,2,5,3,7,101,18,19]; res = 5;`

            ```
            | 10 | 9 | 2 | 5 | 3 | 7 | 101 | 18 | 19 |
            	10                                       subseq=[10]
            	     9                                   subseq=[9]
            	         2                               subseq=[2]
            	             5                           subseq=[2,5]
            	                 3                       subseq=[2,3]
            	                     7                   subseq=[2,3,7]
            	                         101             subseq=[2,3,7,101]
            	                               18        subseq=[2,3,7,18]
            	                                    19   subseq=[2,3,7,18,19]
            ```

        - Итерируемся по элементам в массиве.
            - Если элемент больше последнего элемента подпоследовательности, то вставляем его в конец подпоследовательности.
            - Иначе итерируемся по подпоследовательности с начала и подменяем первый элемент подпоследовательности, который больше текущего элемента массива.

      **Сложность: время - O(n)-O(n^2), память - O(n).**

        ```go
        // Два указателя.
        func moveZeroes(nums []int)  {
            // Левый бегунок, переставляется когда под правым бегунком не ноль.
            leftIdx := 0
            // Правый бегунок, переставляется без условий.
            for rightIdx := 0; rightIdx < len(nums); rightIdx ++ {
                // Если под правым не ноль, то перемещаем элемент под левый бегунок.
                // Если нулевых элеметов еще не было, будем делать лишние операции перестановки. По факту будем перезаписывать текущий элемент текущим.
                if nums[rightIdx] != 0 {
                    nums[leftIdx] = nums[rightIdx]
                    leftIdx++
                }
            }
        
            // Теперь слева оказались все ненулевые элементы, а справа - мусор. Вместо мусора подставим нули.
            for ; leftIdx < len(nums); leftIdx++ {
                nums[leftIdx] = 0
            }
        }
        ```

    - **Решение 2 (оптимальное, но объемное). [Бинарный поиск](https://www.notion.so/8aa67c33fcbe4ce6913fc300d98e87a3?pvs=21).**
        - Пример

          `nums = [10,9,2,5,3,7,101,18,19]; res = 5;`

            ```
            | 10 | 9 | 2 | 5 | 3 | 7 | 101 | 18 | 19 |
            	10                                       subseq=[10]
            	     9                                   subseq=[9]
            	         2                               subseq=[2]
            	             5                           subseq=[2,5]
            	                 3                       subseq=[2,3]
            	                     7                   subseq=[2,3,7]
            	                         101             subseq=[2,3,7,101]
            	                               18        subseq=[2,3,7,18]
            	                                    19   subseq=[2,3,7,18,19]
            ```

        - Итерируемся по элементам в массиве.
            - Если элемент больше последнего элемента подпоследовательности, то вставляем его в конец подпоследовательности.
            - Иначе ищем бинарным поиском и подменяем первый элемент подпоследовательности, который больше текущего элемента массива.

      **Сложность: время - O(n*log(n)), память - O(n).**

        ```go
        // Бинарный поиск.
        func lengthOfLIS(nums []int) int {
            // Подпоследовательность. Назначаем сразу первый элемент для удобства сравнения.
            subSeq := []int{nums[0]}
            // Итерируемся со второго элемента входящего массива.
            for i := 1; i < len(nums); i++ {
                // Если элемент входящего массива равен последнему элементу подпоследовательности -
        				// продолжаем.
                if subSeq[len(subSeq) - 1] == nums[i] {
                    continue
                }
                // Если элемент входящего массива больше, чем последний элемент подпоследовательности -
        				// вставляем в элемент в конец подпоследовательности.
                if subSeq[len(subSeq) - 1] < nums[i] {
                    subSeq = append(subSeq, nums[i])
                } else {
                    // Если элемент входящего массива равен последнему элементу подпоследовательности -
        						// ищем элемент бинарным поиском.
                    subSeqIdx := binarySearch(subSeq, nums[i])
                    subSeq[subSeqIdx] = nums[i]
                }
            }
        
            return len(subSeq)
        }
        // Бинарный поиск, возвращаем индекс в подмассиве.
        // Либо вернем искомый элемент, либо вернем элемент справа (бОльший) от гипотетической вставки.
        func binarySearch(nums []int, target int) int {
            // Левый бегунок, начинаем с начала.
            leftIdx := 0
            // Правый бегунок, начинаем с конца.
            rightIdx := len(nums) - 1
            // Пока бегунки не встретятся.
            for leftIdx < rightIdx {
                // Средний индекс.
                // При четном количестве элементов подмассива
                // средним будет левый средний элемент.
                midIdx := (leftIdx + rightIdx) / 2
                // Если средний элемент равен искомому - выходим.
                if target == nums[midIdx] {
                    return midIdx
                }
                // Искомый справа от среднего - сдвигаем левый бегунок.
                if target > nums[midIdx] {
                    leftIdx = midIdx + 1
                } else {
                    // Искомый слева от среднего - сдвигаем правый бегунок.
                    rightIdx = midIdx
                }
            }
        
            // Если не нашли элемент, то возвращаем левый бегунок.
            return leftIdx
        }
        ```


- **Разбить неотсортированны**й массив **без дублей** на интервальные **последовательности**

  [TODO: найти задачу в задачниках]

    - Условие

      Дан неотсортированный массив с целыми уникальными числами. Нужно разбить массив на интервалы последовательно идущих чисел. Результирующий интервал должен представлять строку `0-2` если интервал `[0,2]`, либо строку `7`, если интервал `[7,7]`.

    - Кейсы

      `nums = [1, 4, 5, 2, 3, 9, 8, 11, 0]; res = "0-5,8-9,11";`

      `nums = [1, 4, 3, 2]; res = "1-4";`

      `nums = [1, 4]; res = "1-4";`

      `nums = [5, 0, 1, 2, 4, 9]; res = "0-2,4-5,9";`

    - **Решение 1 (оптимальное). Сортировка, перебор и сравнение**

      В Яндексе прокатило именно это решение.

      Используем решение задачи [Разбить отсортированный массив без дублей на интервальные последовательности](https://leetcode.com/problems/summary-ranges) ****предварительно отсортировав массив**.**

        - Сортируем массив.
        - Итерируемся и сравниваем текущее число с предыдущим.
        - Если предыдущее число больше текущего как минимум на единицу, то завершаем интервал.

      **Сложность: время - O(n*log(n)), память - O(1)**.

        ```go
        func compress(l []int) string {
        	// Результирующий массив.
        	var res []byte
        	// Обрабатываем кейс тут, чтобы сразу назначить startNum.
        	if len(l) == 0 {
        		return string(res)
        	}
        	// Сортируем.
        	sort.Ints(l)
        	// Начальный элемент интервала
        	startNum := l[0]
        	// 0-й элемент нам не интересен.
        	// Так же нам нужно обработать последний элемент, для этого выходим за рамки массива.
        	// Так же можно сравнивать текущий элемент с последующим, чтобы не выходить за рамки массива.
        	for i := 1; i <= len(l); i++ {
        		// Создаем интервал.
        		// Для этого либо текущий элемент должен быть началом нового интервала.
        		// Либо выходим за рамки массива и обрабатываем последний интервал.
        		if i == len(l) || l[i]-l[i-1] > 1 {
        			// Интервал состоит из одного числа.
        			if l[i-1] == startNum {
        				res = append(res, byte(startNum))
        			} else { // Интервал состоит из двух чисел.
        				res = append(res, byte(startNum), '-', byte(l[i-1]))
        			}
        			// Если мы не вышли за пределы массива, переустанавливаем начало интервала.
        			if i < len(l) {
        				startNum = l[i]
        			} else {
        				// Добавляем запятую, если это не последний интервал.
        				res = append(res, ',')
        			}
        		}
        	}
        
        	return string(res)
        }
        ```

    - Решение 2 (быстрое, но при определенных кейсах). Формирование интервалов на основе [хэш-таблицы](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21)

      [TODO: доработать решение, чтобы результирующие интервалы были отсортированы]

      Решение аналогично задаче [Найти наибольшую последовательную (числа должны быть по порядку) подпоследовательность (longest consecutive sequence)](https://leetcode.com/problems/longest-consecutive-sequence).

      **Сложность: время - O(n*log(k)), память - O(1)**.

        ```go
        // TODO: доработать решение, чтобы результирующие интервалы были отсортированы
        func intervalsFromUnsortedArray(nums []int) string {
        	// Мапа с числами, которые есть в массиве для быстрого поиска. Ключ - число, значение не важно.
        	numsMap := make(map[int]struct{})
        	// Результирующая строка с интервалами.
        	res := strings.Builder{}
        	// Заполняем мапу.
        	for _, num := range nums {
        		numsMap[num] = struct{}{}
        	}
        	// Бежим по мапе. startNum - потенциальное начало интервала.
        	for startNum := range numsMap {
        		// Если слева от числа не заполнено (т.е. число слева пропущено), то мы нашли интервал.
        		if _, ok := numsMap[startNum-1]; !ok {
        			// Потенциальный конец интервала.
        			endNum := startNum
        			// Бежим последовательно вправо от startNum, все последовательные числа входят в текущий интервал.
        			// Если число пропущено, то завершаем цикл. Последнее число это конец интервала.
        			for _, ok := numsMap[endNum+1]; ok; _, ok = numsMap[endNum+1] {
        				endNum++
        			}
        			// Ставим запятую к предыдущему интервалу.
        			if res.Len() > 0 {
        				res.WriteByte(',')
        			}
        			// Заполняем начало интервала.
        			res.WriteString(strconv.Itoa(startNum))
        			// Если конец интервала больше чем начало - заполняем конец интервала.
        			// Если интервал состоит из одного числа, то конец не заполняем.
        			if endNum != startNum {
        				res.WriteByte('-')
        				res.WriteString(strconv.Itoa(endNum))
        			}
        		}
        	}
        	// Если нам нужны отсортированные интервалы, то нужно писать интервалы в массив,
        	// а здесь отсортировать результирующий массив и превратить в строку.
        
        	return res.String()
        }
        ```

- Найти **наибольшую последовательную (числа должны быть по порядку) подпоследовательность** (longest consecutive sequence)

  [LeetCode: 128. Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence)

    - Условие

      Дан несортированный массив с целыми числами `nums`. Необходимо найти подпоследовательность максимального размера такую, что элементы подпоследовательности расположены последовательно (по порядку, без пропусков). Вернуть размер этой подпоследовательности.

      Необходимо написать алгоритм со сложностью O(n) по времени.

    - Кейсы

      `nums = [100,4,200,1,3,2]; res = 4;` - подпоследовательность: `[1,2,3,4]`;

      `nums = [0,3,7,2,5,8,4,6,0,1]; res = 9;`

    - Отличия решений

      [Techie delight: Cамая длинная последовательная подпоследовательность](https://www.techiedelight.com/ru/find-longest-subsequence-formed-by-consecutive-integers/)

    - Решение 1 (простое, не самое быстрое). [Сортировка](https://www.notion.so/e77152deb57d4e0e9b45c1a083cd00cd?pvs=21) + сравнение.
        - Визуализация

          ![sorting.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/sorting.png)


        **Сложность: время - O(n*log(n)), память - O(1)-O(n).**
        
        ```go
        
        ```
        
    - **Решение 2 (оптимальное). Формирование интервалов на основе [хэш-таблицы](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21)**
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // Бинарный поиск.
        func lengthOfLIS(nums []int) int {
            // Подпоследовательность. Назначаем сразу первый элемент для удобства сравнения.
            subSeq := []int{nums[0]}
            // Итерируемся со второго элемента входящего массива.
            for i := 1; i < len(nums); i++ {
                // Если элемент входящего массива равен последнему элементу подпоследовательности -
        				// продолжаем.
                if subSeq[len(subSeq) - 1] == nums[i] {
                    continue
                }
                // Если элемент входящего массива больше, чем последний элемент подпоследовательности -
        				// вставляем в элемент в конец подпоследовательности.
                if subSeq[len(subSeq) - 1] < nums[i] {
                    subSeq = append(subSeq, nums[i])
                } else {
                    // Если элемент входящего массива равен последнему элементу подпоследовательности -
        						// ищем элемент бинарным поиском.
                    subSeqIdx := binarySearch(subSeq, nums[i])
                    subSeq[subSeqIdx] = nums[i]
                }
            }
        
            return len(subSeq)
        }
        // Бинарный поиск, возвращаем индекс в подмассиве.
        // Либо вернем искомый элемент, либо вернем элемент справа (бОльший) от гипотетической вставки.
        func binarySearch(nums []int, target int) int {
            // Левый бегунок, начинаем с начала.
            leftIdx := 0
            // Правый бегунок, начинаем с конца.
            rightIdx := len(nums) - 1
            // Пока бегунки не встретятся.
            for leftIdx < rightIdx {
                // Средний индекс.
                // При четном количестве элементов подмассива
                // средним будет левый средний элемент.
                midIdx := (leftIdx + rightIdx) / 2
                // Если средний элемент равен искомому - выходим.
                if target == nums[midIdx] {
                    return midIdx
                }
                // Искомый справа от среднего - сдвигаем левый бегунок.
                if target > nums[midIdx] {
                    leftIdx = midIdx + 1
                } else {
                    // Искомый слева от среднего - сдвигаем правый бегунок.
                    rightIdx = midIdx
                }
            }
        
            // Если не нашли элемент, то возвращаем левый бегунок.
            return leftIdx
        }
        ```


- **Найти число** в **отсортированном** массиве

  [LeetCode: 704. Binary Search](https://leetcode.com/problems/binary-search/)

    - Решение 1: [Бинарный поиск](https://www.notion.so/8aa67c33fcbe4ce6913fc300d98e87a3?pvs=21).

      **Сложность: время - O(log(n)), память - O(1).**

        ```go
        // Бинарный поиск.
        func search(nums []int, target int) int {
          // Левый бегунок, начинаем с начала.
          leftIdx := 0
          // Правый бегунок, начинаем с конца.
          rightIdx := len(nums) - 1
          // Пока бегунки не встретятся.
          // Равенство необходимо для кейса: nums=[5]; target=5.
          // Без него мы не зайдем в цикл.
          for leftIdx <= rightIdx {
              // Средний индекс.
              // При четном количестве элементов подмассива
              // средним будет левый средний элемент.
              midIdx := (leftIdx + rightIdx) / 2
              // Если средний элемент равен искомому - выходим.
              if target == nums[midIdx] {
                  return midIdx
              }
              // Искомый справа от среднего - сдвигаем левый бегунок.
              if target > nums[midIdx] {
                  leftIdx = midIdx + 1
              } else {
                  // Искомый слева от среднего - сдвигаем правый бегунок.
                  rightIdx = midIdx - 1
              }
          }
        
          // Не нашли.
          return -1
        }
        ```


- Рассчитать **индекс цитируемости статей** (**h-index**, индекс Хирша).

  [LeetCode: 274. H-Index](https://leetcode.com/problems/h-index)

    - Условие

      Дан несортированный массив `citations` цитируемости научных статей. Индекс - статья, значение - число отсылок на эту статью (счетчик цитируемости). Необходимо вернуть [h-index](https://ru.wikipedia.org/wiki/Индекс_Хирша). Т.е. учёный с индексом *h* опубликовал как минимум *h* статей, на каждую из которых сослались как минимум *h* раз.

    - Кейсы

      `citations=[3,0,6,1,5]; res=3`

      `citations=[1,3,1]; res=1`

    - Решение 1. Сортируем и сравниваем с конца.
        - Визуализация

          ![274_H_index.svg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/274_H_index.svg)


        **Сложность: время - O(n*log(n)), память - O(1) || O(n), зависит от способа сортировки.**
        
        ```go
        // Сортировка + перебор. Время - O(nlogn), память - O(n)|O(1), зависит от способа сортировки.
        func hIndex(citations []int) int {
            // Сортируем.
            sort.Ints(citations)
            // Результирующий индекс.
            hIndex := 0
            // Итерируемся с конца в начало.
            // Мы можем пойти с конца и на каждом элементе итерировать индекс пока индекс не станет меньше чем текущий элемент.
            // citations=[0,1,3,5,6]
            // Т.е. устанавливаем индекс =1.
            // 6ка больше 1цы, поэтому мы уверены, что 1ца точно подходит.
            // 5ка и 6ка больше 2ки, 2ка точно подходит.
            // 3,5,6 содержат 3ку, поэтому 3ка тоже подходит.
            // 1ца не содержит 4ку, поэтому она не подойдет, остановимся на 3ке.
            for i := len(citations) - 1; i >= 0; i-- {
                if citations[i] <= hIndex {
                    return hIndex
                }
                hIndex++
            }
        
            // Кейс: citations=[1]
            return hIndex
        }
        ```
        
    - Решение 2 (оптимальное). [Сортировка подсчетом](https://www.notion.so/count-sort-1fba4a41d88f45d3a601d2fcd762906f?pvs=21). TODO.
        
        ```go
        
        ```


- Для **каждого числа в массиве** подсчитать **разницу** до первого **бОльшего числа** (**разница дневных температур**).

  [LeetCode: 739. Daily Temperatures](https://leetcode.com/problems/daily-temperatures)

    - Условие

      Дан несортированный массив со средними дневными температурами. Для каждого элемента (дневной температуры) нужно подсчитать количество дней до следующего повышения температуры, если повышения не будет, то расчет будет равен нулю.

    - Кейсы

      `temperatures = [73,74,75,71,69,72,76,73]; res = [1,1,4,2,1,1,0,0]`

      `temperatures = [30,40,50,60]; res = [1,1,1,0]`

      `temperatures = [30,60,90]; res = [1,1,0]`

    - Решение 1. [Монотонный стэк](https://www.notion.so/monotonic-stack-5f453bc0d9c64a7186b10d8eb02dcc62?pvs=21).

      Сложность: время - O(n), память - O(n).

        ```go
        // Стэк.
        func dailyTemperatures(temperatures []int) []int {
            var stack []elem
            // Результирующий массив.
            res := make([]int, len(temperatures))
            // Добавляем элемент в стэк, если температура не повысилась.
            // Если температура повысилась, то берем элемент со стека и если он меньше текущего, то записываем в результирующий массив разницу между индексами.
            for i := 1; i < len(temperatures); i++ {
                // Температура не повысилась - кладем в стэк.
                if temperatures[i] <= temperatures[i - 1] {
                    stack = append(stack, elem{i - 1, temperatures[i - 1]})
                    continue
                }
                // Температура повысилась.
                // Для прошлого элемента записываем ожидание 1 день.
                res[i - 1] = 1
                // Если есть элементы в стэке - обработаем их.
                for stackIdx := len(stack) - 1; stackIdx >= 0; stackIdx-- {
                    // Если текущий элемент больше какого-то элемента из стэка,
                    // то мы нашли для этого элемента из стэка время ожидания.
                    if temperatures[i] > stack[stackIdx].val {
                        // Запишем ожидание как разницу между индексами.
                        res[stack[stackIdx].idx] = i - stack[stackIdx].idx
                        // Уменьшим стэк.
                        stack = stack[:stackIdx]
                    } else {
                        break
                    }
                }
            }
        
            return res
        }
        
        // Элемент в стэке.
        type elem struct {
            // Индекс во входящем массиве.
            idx int
            // Значение элемента входящего массива под этим индексом.
            val int
        }
        ```


- Емкость с **наибольшим количеством воды** (**наибольшая площадь массива** спроецированного на двумерную плоскость).

  [LeetCode: 11. Container With Most Water](https://leetcode.com/problems/container-with-most-water)

    - Условие

      Дан несортированный массив с целыми числами. Представим что значения в массиве это столбики по оси Y, а индексы это значения по оси X. Необходимо найти два столбика максимальной высоты с максимальным расстоянием между ними. Как если бы мы могли заполнить расстояние между столбиками водой и размер (площадь) этой емкости был бы максимальный.

        - Визуализация

          ![question_11.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/question_11.jpg)

    - Кейсы
        - `height = [1,8,6,2,5,4,8,3,7]; res = 49;`

          ![question_11.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/question_11%201.jpg)


        `height = [1,1]; res = 1;`
        
    - Решение 1. [Два указателя](https://www.notion.so/draft-278415d3ec1246ff9b5b016795685ef8?pvs=21).
        
        Бежим от краев массива к центру. Перемещаем тот бегунок, значение под которым меньше.
        
        **Сложность: время - O(n), память - O(1).**
        
        ```go
        func maxArea(height []int) int {
            // Левый бегунок начинает с начала массива.
            leftIdx := 0
            // Правый бегунок начинает с конца.
            rightIdx := len(height) - 1
            // Максимальная площадь (вместимость).
            maxArea := 0
            // Пока бегунки не встретились.
            for leftIdx < rightIdx {
                // Нам нужно вычислить разницу между индексами бегунков
                // и выбрать минимальное значение под бегунками.
        				// Минимальное потому что иначе вода перельется через край емкости.
                // Перемножив эти параметры мы получим текущую вместимость.
                idxDiff := rightIdx - leftIdx
                // Минимальная высота из двух бегунков.
                minHeight := 0
                // Если высота под левым бегонком меньше, чем под правым, то выбираем ее.
                // Так же смещаем левый бегунок чтобы найти бОльшую вместимость.
                // Кейс: height=[3,5,4,8]
                // Если мы сместим правый бегунок h=8 (т.е. бОльший),
                // то никогда не получим максимальную площадь [5,8],
                // площадь всегда будет ограничена левым бегунком h=3.
                // А если сместим левый h=3, то сразу получим максимальную площадь [5,8].
                if height[leftIdx] < height[rightIdx] {
                    minHeight = height[leftIdx]
                    leftIdx++
                } else {
                    minHeight = height[rightIdx]
                    rightIdx--
                }
                // Вычисляем вместимость.
                curArea := idxDiff * minHeight
                // Увеличиваем максимальную вместимость, если необходимо.
                if curArea > maxArea {
                    maxArea = curArea
                }
            }
        
            return maxArea
        }
        ```


- Для **каждого числа** в **массиве** найти **произведение остальных чисел**

  [LeetCode: 238. Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self)

    - Условие

      Дан неотсортированный массив с целыми числами. Для каждого числа в массиве необходимо найти произведение остальных чисел массива. Т.е. произведение всех чисел, исключая текущее число.

      Нужно решить за **O(n)** и **без** использования операции **деления**.

    - Кейсы

      `nums = [1,2,3,4]; res = [24,12,8,6];`

      `nums = [-1,1,0,-3,3]; res = [0,0,9,0,0];`

    - **Решение 1 (оптимальное). Префиксное произведение (аналогично [префиксной сумме](https://www.notion.so/draft-f47ce8aefd4c4e06b3583f3a5487c470?pvs=21)).**
        - Строим префиксное произведение с левой стороны и с правой.
        - Перемножаем префиксные произведения.

      Например, для массива `[a,b,c,d]`:

      произведение слева направо = `[1, a, ab, abc]`

      произведение справа налево = `[bcd, cd, d, 1]`

      перемножение префиксных произведений даст искомый результат = `[bcd, acd, abd, abc]`

      **Сложность: время - O(n), память - O(1).**

        ```go
        // Префиксное произведение.
        func productExceptSelf(nums []int) []int {
            // Результирующий массив.
            res := make([]int, len(nums))
            // Обозначим элементы на входе:
            // [a, b, c, d]
        
            multiplier := 1
            // Сдвигаем произведение элементов на 1 элемент вправо.
            // Получим, что в последнем произведении не будет хватать последнего элемента,
            // в предпоследнем - последнего и предпоследнего и т.д:
            // [1, a, ab, abc]
            for i, n := range nums {
                res[i] = multiplier
                multiplier *= n
            }
        
            multiplier = 1
            // Сдвигаем произведение элементов на 1 элемент влево и начинаем с конца.
            // Получим, что в первом произведении не будет хватать первого элемента,
            // во втором - первого и второго и т.д:
            // [bcd, cd, d, 1]
            for i := len(res) - 1; i >= 0; i-- {
                res[i] *= multiplier
                multiplier *= nums[i]
            }
            // Если перемножить первое префиксное произведение со вторым, получим искомый массив:
            // [bcd, acd, abd, abc]
        
            return res
        }
        ```


- Вычислить **квадраты чисел** в **отсортированном массиве**

  [LeetCode: 977. Squares of a Sorted Array](https://leetcode.com/problems/squares-of-a-sorted-array)

    - Условие

      Дан отсортированный по неубыванию массив с целыми числами `nums`. Для каждого числа нужно найти квадрат этого числа и сформировать новый массив с отсортированными квадратами чисел.

      Нужно решить задачу за O(n) по времени.

    - Кейсы

      Учесть, что квадрат отрицательного числа это положительное число.

      `nums = [-4,-1,0,3,10]; res = [0,1,9,16,100];`

      `nums = [-7,-3,2,3,11]; res = [4,9,9,49,121];`

    - Решение 1 (оптимальное и простое). [Два указателя](https://www.notion.so/draft-278415d3ec1246ff9b5b016795685ef8?pvs=21). Идем с концов к середине.

      Идем от конечных элементов к центру сравнивая два элемента под бегунками. Тем самым учитывая случай, когда массив начинается с отрицательных чисел. Т.е. у нас где-то в массиве может быть нулевой элемент (не всегда), который является центральной точкой.

      **Сложность: время - O(n), память - O(1).**

        ```go
        // Два указателя
        func sortedSquares(nums []int) []int {
            // Результирующий массив.
            res := make([]int, len(nums))
            // Указатель (бегунок), который идет с левого элемента вправо до правого указателя.
            leftP := 0
            // Указатель (бегунок), который идет с правого элемента влево до левого указателя.
            rightP := len(nums) - 1
            // Начинаем заполнять с бОльшего элемента к меньшему. 
            // Идем от конечных элементов к центру сравнивая два элемента под бегунками.
            // Т.е. у нас где-то есть нулевой элемент (не всегда), который является центральной точкой.
            for i := len(nums) - 1; i >= 0; i-- {
                // Вычисляем квадраты.
                leftRes := nums[leftP] * nums[leftP]
                rightRes := nums[rightP] * nums[rightP]
                // Если левый больше, то вставляем его, иначе правый.
                if leftRes > rightRes {
                    res[i] = leftRes
                    leftP++
                } else {
                    res[i] = rightRes
                    rightP--
                }
            }
        
            return res
        }
        ```


- Найти **пропущенное порядковое число** в неотсортированном **массиве**

  [LeetCode: 268. Missing Number](https://leetcode.com/problems/missing-number/)

    - Условие

      Дан неотсортированный массив с целыми уникальными числами. В массиве размером `n` присутствуют числа только от `0` до `n`. Но пропущено одно порядковое число. Найти пропущенное число.

    - Кейсы

      `nums = [3,0,1]; res = 2;` - т.к. в массиве 3 элемента, то `n = 3`, пропущено число `2`.

      `nums = [0,1]; res = 2;` - т.к. в массиве 2 элемента, то `n = 2`, пропущено число `2`.

      `nums = [9,6,4,2,3,5,7,0,1]; res = 2;` - т.к. в массиве 9 элементов, то `n = 9`, пропущено число `8`.

    - **Решение 1 (оптимальное). Побитовый [XOR](https://www.notion.so/3e8a63f0597a40d9b05c30952d3bcf77?pvs=21).**
        - Объяснение с примером:

            ```go
            // Например на входе массив:
            [0, 1, 3, 4]
            // Индексы будут такими:
            [0, 1, 2, 3]
            // Получим такие результаты:
            0000 // 0
            0000 // ^0
            
            0000 // 0^0
            0001 // ^1
            0001 // ^1
            0000 // 0^0^1^1
            
            0000 // 0^0^1^1
            0011 // ^3
            0010 // ^2
            0001 // 0^0^1^1^3^2 = 1
            
            0001 // 0^0^1^1^3^2 = 1
            0100 // ^4
            0011 // ^3
            0110 // 0^0^1^1^3^2^4^3 = 6
            
            0110 // 0^0^1^1^3^2^4^3 = 6
            0100 // ^4
            0010 // 0^0^1^1^3^2^4^3^4 = 2
            
            0010 (bin) = 2 (dec)
            ```


        **Сложность: время - O(n), память - O(1).**
        
        ```go
        // Побитовый XOR.
        func missingNumber(nums []int) int {
            // Здесь будем вычислять недостающий элемент.
            // Применив XOR суммарно ко всем элементам и индексам массива получим недостающий элемент.
            // Это получится, т.к. XOR отдает разницу, если два числа не равны и 0, если равны.
            // Числа в XOR можно переставлять.
            // Последний элемент точно есть, поэтому сразу заложим его.
            missing := len(nums)
            for i, n := range nums {
                missing ^= i ^ n
            }
        
            return missing
        }
        ```
        
    - Решение 2 ****(оптимальное). Разница сумм.
        
        **Сложность: время - O(n), память - O(1).**
        
        ```go
        func missingNumber(nums []int) int {
            // Искомая сумма которая должна быть.
            targetSum := 0
            // Сумма с пропущенным числом.
            curSum := 0
            // Итерируемся до количества элементов в массиве.
            for i := 0; i <= len(nums); i++ {
                // Проверяем, если вышли за пределы массива.
                if i < len(nums) {
                    curSum += nums[i]
                }
                targetSum += i
            }
        
            return targetSum - curSum
        }
        ```
        
    - Решение 3 ****(неоптимальное). [Хэш-таблица](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21).
        - Собираем в цикле мапу с числами.
        - Во втором цикле удаляем элементы из мапы, найденные в массиве.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        
        ```

- В неотсортированном массиве **переместить нули вправо**.

  [LeetCode: 283. Move Zeroes](https://leetcode.com/problems/move-zeroes)

    - Условие

      Дан несортированный массив с целыми числами. Необходимо переместить все нули в правую часть массива, а все числа отличные от нуля в левую часть. При этом нужно сохранить порядок ненулевых чисел.

      Нужно решить задачу за O(1) по памяти.

    - Кейсы

      `nums = [0,1,0,3,12]; res = [1,3,12,0,0];`

      `nums = [0]; res = [0];`

    - Решение 1 (оптимальное и простое). [Два указателя](https://www.notion.so/draft-278415d3ec1246ff9b5b016795685ef8?pvs=21). Перемещаем все ненулевые числа влево.
        - Визуализация

          ![IMG_5431.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/IMG_5431.jpg)


        Бежим слева направо и каждое ненулевое число проталкиваем влево на одну позицию, если слева есть нолик. Мы не перескакиваем между ненулевыми числами и сохраняем их порядок.
        
        **Сложность: время - O(n), память - O(1).**
        
        ```go
        // Два указателя.
        func moveZeroes(nums []int)  {
            // Левый бегунок, переставляется когда под правым бегунком не ноль.
            leftIdx := 0
            // Правый бегунок, переставляется без условий.
            for rightIdx := 0; rightIdx < len(nums); rightIdx ++ {
                // Если под правым не ноль, то перемещаем элемент под левый бегунок.
                // Если нулевых элеметов еще не было, будем делать лишние операции перестановки. По факту будем перезаписывать текущий элемент текущим.
                if nums[rightIdx] != 0 {
                    nums[leftIdx] = nums[rightIdx]
                    leftIdx++
                }
            }
        
            // Теперь слева оказались все ненулевые элементы, а справа - мусор. Вместо мусора подставим нули.
            for ; leftIdx < len(nums); leftIdx++ {
                nums[leftIdx] = 0
            }
        }
        ```
        
    - Решение 2. [Два указателя](https://www.notion.so/draft-278415d3ec1246ff9b5b016795685ef8?pvs=21). Проталкиваем нолики вправо за один цикл.
        
        Бежим слева направо и каждый ноль проталкиваем вправо на одну позицию. Мы не перескакиваем между положительными числами и сохраняем их порядок.
        
        **Сложность: время - O(n), память - O(1).**
        
        ```go
        // решение похоже на сортировку пузырьком
        // метод двух указателей (бегунков)
        // бежим слево направо и каждое положительное число проталкиваем (всплытие) влево, меняя с нулем
        // каждый нолик тоже всплывает вправо, но итеративно, меняясь с каждым текущим числом
        // мы не перескакиваем между положительными числами и сохраняем их порядок
        func moveZeroes(nums []int)  {
            // бегунок для работы с нулевым элементом (нулевой)
            zeroPos := 0
            // бегунок для работы с ненулевым элементом (текущий)
            // начинаем с 1-го, т.к. для перестановки нужно минимум два элемента
            curPos := 1
            for curPos < len(nums) && zeroPos < len(nums) {
                // если в текущем бегунке число положительное
                // и в нулевом бегунке нулевой элемент
                if nums[zeroPos] == 0 && nums[curPos] != 0 {
                    // то меняем местами текущий положительный элемент и ноль, который под нулевым бегунком
                    nums[zeroPos] = nums[curPos]
                    nums[curPos] = 0
                    // обработали - можно искать следующий ноль под нулевым бегунком для перестановки
                    zeroPos++
                }
        
                // всегда инкрементируем текущий бегунок
                curPos++
        
                // нулевой бегунок инкрементируем когда переставили числа (сверху)
                // и когда число под бегунком положительное, нам не надо переставлять (обрабатывать)
                // т.е. мы либо переставляем, либо если под нулевым бегунком ноль, то ждем, когда под текущим бегунком будет положительное число, чтобы их переставить
                if nums[zeroPos] != 0 {
                    zeroPos++
                }
            }
        }
        ```


- В массиве для каждого **скользящего окна** размером `k` получить **максимальный** элемент в окне.

  [LeetCode: 239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)

    - Условие

      Дан несортированный массив `nums` с целыми числами и целочисленное `k`. Для каждого скользящего окна размером `k` в массиве нужно найти максимальное число в рамках скользящего окна.

    - Кейсы
        - `nums = [1,3,-1,-3,5,3,6,7], k = 3; res = [3,3,5,5,6,7];`

            ```
            Window position                Max
            ---------------               -----
            [1  3  -1] -3  5  3  6  7       **3**
             1 [3  -1  -3] 5  3  6  7       **3**
             1  3 [-1  -3  5] 3  6  7       **5**
             1  3  -1 [-3  5  3] 6  7       **5**
             1  3  -1  -3 [5  3  6] 7       **6**
             1  3  -1  -3  5 [3  6  7]      **7**
            ```


        `nums = [1], k = 1; res = [1];`
        
        `nums = [1,-1], k = 1; res = [1,-1];`
        
        `nums = [7,6,5,4], k = 2; res = [7,6,5];`
        
    - Решение 1 (оптимальное, сложное). Монотонная [двухсторонняя очередь](https://www.notion.so/08ce13fbf3654e68be6d1ed0a49acea9?pvs=21).
        - Примеры
            
            `dequeReflect` - отражения элементов массива в очереди, т.е. если бы в очереди вместо индексов массива вставить элементы массива.
            
            - `nums = [1,3,-1,-3,5,3,6,7], k = 3; res = [3,3,5,5,6,7];`
                
                ```
                Window position                Max     dequeReflect      deque
                ---------------               -----    ------------      -----
                [1  3  -1] -3  5  3  6  7       **3         [3,-1]         [1,2]**
                 1 [3  -1  -3] 5  3  6  7       **3        [3,-1,-3]      [1,2,3]**
                 1  3 [-1  -3  5] 3  6  7       **5           [5]           [4]**
                 1  3  -1 [-3  5  3] 6  7       **5          [5,3]         [4,5]**
                 1  3  -1  -3 [5  3  6] 7       **6           [6]           [6]**
                 1  3  -1  -3  5 [3  6  7]      **7           [7]           [7]**
                ```
                
            - `nums = [7,6,5,4], k = 2; res = [7,6,5];`
                
                ```
                Window position                Max     dequeReflect      deque
                ---------------               -----    ------------      -----
                	 [7 6] 5  4                   7          [7,6]         [0,1]
                	 7 [6  5] 4                   6          [6,5]         [1,2]
                	 7  6 [5  4]                  5          [5,4]         [2,3]
                ```
                
        
        **Сложность: время - O(n), память - O(k).**
        
        ```go
        // Монотонная двусторонняя очередь.
        func maxSlidingWindow(nums []int, k int) []int {
            // Монотонная двусторонняя очередь. Значение - индекс входящего массива.
            // Для понимания так же введем виртуальную очередь отражения (queueReflect).
            // Значения - элементы массива, на которые указывает элементы очереди.
            deque := make([]int, 0, k)
            // Результирующий массив.
            // Размер должен быть на k элементов меньше, т.к. элементы первого окна не попадают в результат.
            res := make([]int, 0, len(nums) - k + 1)
            // Бежим по элементам входящего массива.
            for numIdx := range nums {
                // Бежим по очереди с конца в начало.
                for dequeIdx := len(deque) - 1 ; dequeIdx >= 0; dequeIdx-- {
                    // Если элемент массива, на который указывает последний элемент очереди меньше чем текущий элемент массива, сокращаем очередь с конца (pop).
                    // Т.е. нам нужно поддержать правило, что первый элемент очереди указывает на наибольший элемент массива.
                    // queueReflect=[5,3,2,1];num=4; => queueReflect=[5]
                    // queueReflect=[5,4];num=3; => queueReflect=[5,4]
                    // TODO: можно этот if включить в for, но тогда будет сложнее понимать.
                    if nums[deque[dequeIdx]] < nums[numIdx] {
                        deque = deque[:dequeIdx]
                    } else {
                        break
                    }
                }
                // Удалили с конца очереди ненужные элементы, теперь добавим текущий индекс.
                // queueReflect=[5,3,2,1];num=4; => queueReflect=[5,4]
                // queueReflect=[5,4];num=3; => queueReflect=[5,4,3]
                deque = append(deque, numIdx)
                // Если еще не закончили набирать первое окно - продолжаем.
                if numIdx < k - 1 {
                    continue
                }
                // Первый элемент очереди максимальный в окне - добавляем его в результирующий массив.
                res = append(res, nums[deque[0]])
                // Если текущий индекс массива больше, чем первый элемент в очереди -
                // сократим очередь с начала, т.к. текущий элемент очереди указывает за границы окна.
                //  queue=[0,1];numIdx=1;k=2; => queue=[1];
                //  queue=[2,4];numIdx=3;k=2; => queue=[4];
                if deque[0] == numIdx - k + 1 {
                    deque = deque[1:]
                }
            }
        
            return res
        }
        ```


- Подсчитать **количество** неотсортированных элементов в **частично отсортированном** массиве.

  [LeetCode: 1051. Height Checker](https://leetcode.com/problems/height-checker)

    - Условие

      Дан частично отсортированный массив. Нужно подсчитать количество элементов не на своих местах в сравнении таким же отсортированным массивом.

    - Кейсы

      `heights = [1,1,4,2,1,3]; res=3` - элементы с индексами 2,4,5 не соответствуют

      `heights = [5,1,2,3,4]; res=5` - все элементы не соответствуют

      `heights = [1,2,3,4,5]; res=0` - все элементы соответствуют

    - Решение 1. Сортируем и сравниваем поэлементно.

      Сложность: время - O(n*log(n)), память - O(n).

        ```go
        func heightChecker(heights []int) int {
            // Скопируем входящий массив, чтобы сравнивать отсортированный и входящий массивы.
            originalHeights := make([]int, len(heights))
            copy(originalHeights, heights)
            // Отсортируем.
            sort.Ints(heights)
            // Результирующее количество несоответствий.
            count := 0
            // Сравниваем поэлементно.
            for i, h := range heights {
                if h != originalHeights[i] {
                    count++
                }
            }
        
            return count
        }
        ```


- Найти **массив с префиксным количеством общих чисел в двух массивах с перестановками от `0` до `n`** (prefix common array)

  [LeetCode: 2657. Find the Prefix Common Array of Two Arrays](https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/)

    - Условие

      Даны **два целочисленных массива** `A`, `B` с перестановками от `0` до `n`. Нужно сформировать общий префиксный массив `C` такой, что `C[i]` равно количеству чисел, которые присутствуют в индексе `i` или перед индексом `i` как в `A`, так и в `B`.

    - Кейсы
        - `A = [1,3,2,4], B = [3,1,2,4]; res = [0,2,3,4];`

          `i = 0`: нет общих префиксных чисел, т.е. кол-во общих префиксных чисел - `0`.
          `i = 1`: префиксные числа `1`, `3` общие (кол-во - `2`).
          `i = 2`: префиксные числа `1`, `2`, `3` общие (кол-во - `3`).
          `i = 3`: префиксные числа `1`, `2`, `3`, `4` общие (кол-во - `4`).


        `A = [2,3,1], B = [3,1,2]; res = [0,1,3];`
        
    - **Решение 1 (оптимальное и простое). Хэш-таблица для общей повторяемости чисел.**
        - Пример
            
            ```go
            A = [1,3,2,4,5], B = [3,1,2,4,6]; res = [0,2,3,4,4];
            i = 0; numToFreq[1] = 1; count = 0;
            i = 0; numToFreq[3] = 1; count = 0;
            i = 1; numToFreq[3] = 2; count = 1;
            i = 1; numToFreq[1] = 2; count = 2;
            i = 2; numToFreq[2] = 1; count = 2;
            i = 2; numToFreq[2] = 2; count = 3;
            i = 3; numToFreq[4] = 1; count = 4;
            i = 3; numToFreq[4] = 2; count = 4;
            i = 4; numToFreq[5] = 1; count = 4;
            i = 4; numToFreq[6] = 1; count = 4;
            ```
            
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // Время: O(n), память - O(n).
        // Хэш-таблица для общей повторяемости чисел.
        func findThePrefixCommonArray(A []int, B []int) []int {
            // Хэш-таблица для общей повторяемости чисел.
            // Ключ - число, значение - 0: нет повторов, 1: встречается в одном массиве, 2: встречается в обоих массивах.
            numToFreq := make(map[int]int)
            // Результирующий массив.
            res := make([]int, len(A))
            // Текущее количество общих чисел (счетчик).
            count := 0
            for i := 0; i < len(A); i ++ {
                // Увеличиваем счетчик для значения из A.
                numToFreq[A[i]]++
                // Т.к. каждое число в массиве уникальное, то если счетчик =2, то число есть в двух массивах.
                if numToFreq[A[i]] == 2 {
                    count++
                }
                // Увеличиваем счетчик для значения из B.
                numToFreq[B[i]]++
                // Т.к. каждое число в массиве уникальное, то если счетчик =2, то число есть в двух массивах.
                if numToFreq[B[i]] == 2 {
                    count++
                }
                // Добавим текущий префикс в результирующий массив.
                res[i] = count
            }
        
            return res
        }
        ```


- Найти **массив с префиксным количеством общих уникальных чисел в двух массивах** (prefix common array)
    - Условие

      Даны **два целочисленных массива** `A`, `B`. Нужно сформировать общий префиксный массив `C` такой, что `C[i]` равно количеству чисел, которые присутствуют в индексе `i` или перед индексом `i` как в `A`, так и в `B`.

    - Кейсы
        - `A = [1,3,2,4], B = [3,1,2,4]; res = [0,2,3,4];`

          `i = 0`: нет общих префиксных чисел, т.е. кол-во общих префиксных чисел - `0`.
          `i = 1`: префиксные числа `1`, `3` общие (кол-во - `2`).
          `i = 2`: префиксные числа `1`, `2`, `3` общие (кол-во - `3`).
          `i = 3`: префиксные числа `1`, `2`, `3`, `4` общие (кол-во - `4`).


        `A = [1,3,2,4,5,5], B = [3,1,2,4,6,6]; res = [0,2,3,4,4,4];`
        
    - **Решение 1. Хэш-таблица для общей повторяемости чисел с состояниями повторений.**
        
        [TODO: решение надо проверить]
        
        - Пример
            
            ```go
            A = [1,3,2,4,5,5], B = [3,1,2,4,6,6]; res = [0,2,3,4,4,4];
            i = 0; numToFreq[1] = 1; count = 0;
            i = 0; numToFreq[3] = 2; count = 0;
            i = 1; numToFreq[3] = 3; count = 1;
            i = 1; numToFreq[1] = 3; count = 2;
            i = 2; numToFreq[2] = 1; count = 2;
            i = 2; numToFreq[2] = 3; count = 3;
            i = 3; numToFreq[4] = 1; count = 4;
            i = 3; numToFreq[4] = 3; count = 4;
            i = 4; numToFreq[5] = 1; count = 4;
            i = 4; numToFreq[6] = 2; count = 4;
            i = 5; numToFreq[5] = 1; count = 4;
            i = 5; numToFreq[6] = 2; count = 4;
            ```
            
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // Время: O(n), память - O(n).
        // Хэш-таблица для общей повторяемости чисел.
        func findThePrefixCommonArray(A []int, B []int) []int {
            // Константы повторяемости.
            const (
                notFound = iota // еще не было такого числа
                inA // число есть в A
                inB // число есть в B
                inBoth // число есть в обоих массивах
            )
            // Хэш-таблица для общей повторяемости чисел.
            // Ключ - число, значение - константа повторяемости.
            numToFreq := make(map[int]int)
            // Результирующий массив.
            res := make([]int, len(A))
            // Текущее количество общих чисел (счетчик).
            count := 0
            for i := 0; i < len(A); i ++ {
                // Получаем состояние повторяемости для числа в первом массиве.
                aState := numToFreq[A[i]]
                // Если числа еще не было, установим, что число есть в A.
                if aState == notFound {
                    numToFreq[A[i]] = inA
                }
                // Если число было в B, установим, что число есть в обоих массивах, обновим счетчик.
                if aState == inB {
                    numToFreq[A[i]] = inBoth
                    count++
                }
                // Получаем состояние повторяемости для числа во втором массиве.
                bState := numToFreq[B[i]]
                // Если числа еще не было, установим, что число есть в B.
                if bState == notFound {
                    numToFreq[B[i]] = inB
                }
                // Если число было в A, установим, что число есть в обоих массивах, обновим счетчик.
                if bState == inA {
                    numToFreq[B[i]] = inBoth
                    count++
                }
                // Добавим текущий префикс в результирующий массив.
                res[i] = count
            }
        
            return res
        }
        ```


- Сравнить элементы массива, при **сравнении** оставляя только **разницу наибольших элементов**  (столкновения элементов) (выигрывает сильнейший)

  [LeetCode: 1046. Last Stone Weight](https://leetcode.com/problems/last-stone-weight)

    - Условие

      Дан несортированный массив с целыми числами `stones`. Необходимо сравнивать два максимальных числа массива, с каждым сравнением оставляя разницу этих чисел и уменьшая массив. В конечном итоге должен остаться один элемент.

        - Альтернативная формулировка

          Дан массив с весами камней. На каждом шагу мы сталкиваем два самых тяжелых камня и они разбиваются, оставляя разницу в весе между этими камнями. В конечном итоге нам нужно получить вес последнего оставшегося камня.

    - Кейсы
        - `stones = [2,7,4,1,8,1]; res = 1;`

          Сравниваем `7` and `8`, получаем 1, новый массив: `[2,4,1,1,1]`

          `2 4 => 2; stones = [2,1,1,1];`

          `2 1 => 1; stones = [1,1,1];`

          `1 1 => 0; stones = [1];`


        `stones = [1]; res = 1;`
        
    - Решения
        
        [Youtube: Interview Pen: Stone Game | Mastering Recursive Brute Forces & Dynamic Programming Recurrences](https://www.youtube.com/watch?v=HNEKaduMWVY)
        
    - Решение 1 (оптимальное и простое). [Максимальная куча](https://www.notion.so/heap-bbab5668199b473d957aca3403e85c2c?pvs=21) (приоритетная очередь).
        - Заполняем максимальную кучу.
        - Итеративно достаем из кучи два максимальных элемента, сравниваем их и кладем в кучу разницу.
        
        **Сложность: время - O(n*log(n)), память - O(n).**
        
        ```go
        // Максимальная куча.
        func lastStoneWeight(stones []int) int {
            // Приоритетная очередь (максимальная куча).
            // Сразу преобразуем входящий массив в очередь.
            queue := maxHeap(stones)
            // Инициализация кучи (O(n)).
            heap.Init(&queue)
            // Пока есть пара чисел в очереди.
            for queue.Len() > 1 {
                // Достаем пару чисел.
                x := heap.Pop(&queue).(int)
                y := heap.Pop(&queue).(int)
                // Вставляем разницу чисел в кучу, если она есть.
                if x != y {
                    heap.Push(&queue, x-y)
                }
            }
            // Если элементов не осталось - выходим с нулем.
            if queue.Len() == 0 {
                return 0
            }
            // Достаем последний элемент.
            return heap.Pop(&queue).(int)
        }
        
        // Реализация кучи для container/heap.
        type maxHeap []int
        func (h maxHeap) Len() int {return len(h)}
        func (h maxHeap) Less(i, j int) bool {return h[i] > h[j]}
        func (h maxHeap) Swap(i, j int) {h[i], h[j] = h[j], h[i]}
        func (h *maxHeap) Push(x interface{}) {*h = append(*h, x.(int))}
        func (h *maxHeap) Pop() interface{} {
            n := len(*h)
            x := (*h)[n-1]
            *h = (*h)[0:n-1]
            return x
        }
        ```
        
    - Решение 2 (зависит от входных данных). [Сортировка подсчетом](https://www.notion.so/count-sort-1fba4a41d88f45d3a601d2fcd762906f?pvs=21).  TODO.
        
        **Сложность: время - O(n+max(nums)), память - O(max(nums)).**
        
        ```go
        
        ```
        
    - Решение 3 (неоптимальное). Сортировка.
        
        **Сложность: время - O(n^2), память - O(n).** Квадратичная сложность потому, что нужно результат сравнения помещать обратно в массив.
        
        ```go
        
        ```


- **Минимально необходимый бонус** для участников **рейтинга** (**дети и леденцы**) (**бонус для работников**)

  [LeetCode: 135. Candy](https://leetcode.com/problems/candy)

  [TODO: решить оптимально]

    - Условие

      Дан неотсортированный массив с целыми числами. Каждое число это рейтинг участника, каждому участнику положен бонус в зависимости от правил:

        - каждый участник получает минимум 1 бонус;
        - участник с бОльшим рейтингом получает бОльший бонус, чем его соседи.

      Вернуть минимально необходимый бонус (число), который можно распределить между всеми участниками.
        
      ---

      Есть группа детей (массив с рейтингом детей). Каждому ребенку присвоен рейтинг. Необходимо раздать детям конфеты в зависимости от рейтинга:

        - каждый ребенок получает минимум 1 конфету;
        - ребенок с бОльшим рейтингом получает бОльше конфет, чем его соседи.
        -

        ---

      [https://leetcode.com/discuss/interview-question/3629814](https://leetcode.com/discuss/interview-question/3629814)

      Дан массив с работниками, каждому работнику присвоен рейтинг. Каждому работнику положен денежный бонус.

        - бонус не может быть меньше 500;
        - бонус кратен 500;
        - если рейтинг сотрудника выше, чем у левого или правого сотрудника в массиве, то бонус этого сотрудника должен быть больше чем у соседних;

      Найти минимальную сумму бонусов, которые нужно заплатить.

    - Кейсы

      `ratings = [1,0,2]; res = 5;`

      `ratings = [1,2,2]; res = 4;`

      `ratings = [12,4,3,11,34,34,1,67]; res = 16;`

    - Решение 1 (простое, не самое быстрое). Строим два массива сравнивая соседей справа налево и слева направо, сложив все элементы сформированных массивов получим искомую сумму.
        - Пример

          `ratings = [12,4,3,11,34,34,1,67]; res = 16;`

            ```
              12 | 4 | 3 | 11 | 34 | 34 | 1 | 167   - массив
                 >   >   <    <    =    >   <       - сравнения пар элементов
            -> 1 | 1 | 1 |  2 |  3 |  1 | 1 |  2    - результаты сравнения слева направо пар элементов
               3 | 2 | 1 |  1 |  1 |  2 | 1 |  1 <- - результаты сравнения справа налево пар элементов
            ```

            - Визуализация

              ![135_Candy_Two_Pass.gif](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/135_Candy_Two_Pass.gif)


        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // Строим два массива сравнивая соседей справа налево и слева направо, сложив все элементы построенных массивов получим искомую сумму.
        func candy(ratings []int) int {
            // Участники = дети, бонусы = леденцы.
            // Массив результатов сравнения пар участников слева направо.
            leftToRight := make([]int, len(ratings))
            // Массив результатов сравнения пар участников справа налево.
            rightToLeft := make([]int, len(ratings))
            // Сравниваем слева направо.
            for i, _ := range ratings {
                // Бонус первому участнику =1 (не с кем сравнивать).
                if i == 0 {
                    leftToRight[0] = 1
                    continue
                }
                // Минимальный бонус =1.
                leftToRight[i] = 1
                // Если рейтинг текущего участника больше, чем рейтинг участника слева - 
                // бонус на 1 больше, чем у участника слева.
                if ratings[i] > ratings[i - 1] {
                    leftToRight[i] += leftToRight[i - 1]
                }
            }
            // Сравниваем справа налево.
            for i := len(ratings) - 1; i >= 0; i-- {
                // Бонус первому участнику с конца =1 (не с кем сравнивать).
                if i == len(ratings) - 1 {
                    rightToLeft[i] = 1
                    continue
                }
                // Минимальный бонус =1.
                rightToLeft[i] = 1
                // Если рейтинг текущего участника больше, чем рейтинг участника справа - 
                // бонус на 1 больше, чем у участника справа.
                if ratings[i] > ratings[i + 1] {
                    rightToLeft[i] += rightToLeft[i + 1]
                }
            }
            // Результирующая минимальная сумма бонусов.
            res := 0
            for i, _ := range ratings {
                // Бонус для участника равен максимальному элементу из массивов с результатами.
                r := leftToRight[i]
                if rightToLeft[i] > leftToRight[i] {
                    r = rightToLeft[i]
                }
                // Сложим бонусы всех участников.
                res += r
            }
        
            return res
        }
        ```
        
    - Решение 2 (простое, не самое быстрое). Строим один массив сравнивая соседей справа налево и слева направо, сложив все элементы сформированного массива получим искомую сумму. TODO.
        
        **Сложность: время - O(n), память - O(1).**
        
        ```go
        
        ```
        
    - Решение 3 (быстрое, но сложное). График подъемов и спусков. TODO.
        
        **Сложность: время - O(n), память - O(1).**
        
        ```go
        
        ```


## Строки

### Найти наибольшую подстроку с уникальными символами

- Найти **наибольшую подстроку с уникальными** символами

  [LeetCode: 3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters)

    - Кейсы

      `s = "abcabcbb"; res = 3;` - `abc` либо `bca` либо `cab`

      `s = "bbbbb"; res = 1;` - `b`

      `s = "pwwkew"; res = 3;` - `wke` либо `kew`

      `s = ""; res = 0;`

    - Решение 1 (оптимальное). [Скользящее окно](https://www.notion.so/Sliding-window-draft-e553bdf67d21409eafa60b0b2030fea4?pvs=21) + [хэш-таблица](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21).

      Символы в скользящем окне дублируются в мапе.

      **Сложность: время - O(n), память - O(min(n, k)), где k - количество используемых символов.**

        ```go
        // Скользящее окно + хэш-таблица.
        func lengthOfLongestSubstring(s string) int {
            // Кейс s = "".
            if len(s) == 0 {
                return 0
            }
            // Мапа для быстрого поиска символа в скользящем окне.
            // 128 - примерное количество используемых символов.
            letters := make(map[rune]int, 128)
            // Левый бегунок скользящего окна.
            leftIdx := 0
            res := 0
            for rightIdx, ch := range s {
                existPos, isExist := letters[ch]
                // Такого символа еще не было, либо она была раньше, до окна.
                if !isExist || existPos < leftIdx {
                    // Обновляем максимальное окно.
                    if rightIdx - leftIdx > res {
                        res = rightIdx - leftIdx
                    }
                // Символ уже был в окне - урежем окно с позиции дубля символа.
                } else {
                    leftIdx = existPos + 1
                }
                // обновляем позицию текущей буквы
                letters[ch] = rightIdx
            }
        
            return res + 1
        }
        ```


- Найти **наибольшую подстроку с двумя уникальными** символами

  [LeetCode: 159. Longest Substring with At Most Two Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters)

    - Условие

      Дана строка. Вернуть подстроку с **наибольшим** количеством символов, чтобы в этой подстроке было не больше **двух уникальных символов.**

    - Кейсы

      `s = "eceba"; res = 3;` - `"ece"`

      `s = "ccaabbb"; res = 5;` - `"aabbb"`

    - Решение 1 (оптимальное). [Скользящее окно](https://www.notion.so/Sliding-window-draft-e553bdf67d21409eafa60b0b2030fea4?pvs=21).
        - Визуализация

          ![sliding.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/sliding.png)


        Используем **максимальное** окно. Т.е. если превысили максимум уникальности букв, то не подтягиваем левую границу, чтобы добиться нужной уникальности букв (=2), а подтягиваем левый бегунок на одну позицию, чтобы поддерживать максимальный размер окна. Так мы убираем лишние итерации.
        
        **Сложность: время - O(n), память - O(1).**
        
        ```go
        func lengthOfLongestSubstringTwoDistinct(s string) int {
            // Мапа для подсчета уникальных символов.
            // Ключ - символ, значение повторяемость символа в строке (счетчик).
            charCounters := make(map[byte]int)
            // Левая граница окна (левый бегунок).
            leftIdx := 0
            // Правая граница окна (правый бегунок).
            rightIdx := 0
            for ; rightIdx < len(s); rightIdx++ {
                // Инкрементируем счетчик текущего символа.
                charCounters[s[rightIdx]]++
                // Если превысили максимум по уникальным символам.
                if len(charCounters) > 2 {
                    // Уменьшаем счетчик символа под левым бегунком
                    // и смещаем левый бегунок.
                    charCounters[s[leftIdx]]--
                    if count, ok := charCounters[s[leftIdx]]; ok && count <= 0 {
                        delete(charCounters, s[leftIdx])
                    }
                    leftIdx++
                }
            }
        
            // Результируее максимальное окно.
            return rightIdx - leftIdx
        }
        ```


- Найти **наибольшую подстроку** с как минимум **`k` уникальными** символами.

  [LeetCode: 340. Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/)

    - Условие

      Дана строка. Необходимо найти **наибольшую подстроку**, в которой будет как минимум **k уникальных** (недублирующихся) символов. Вернуть **длину** такой подстроки.

    - Кейсы

      `s = "eceba", k = 2; res = 3;` - `"ece"`

      `s = "aa", k = 1; res = 2;` - `"aa"`

    - Решение 1 (оптимальное). Максимальное [скользящее окно](https://www.notion.so/Sliding-window-draft-e553bdf67d21409eafa60b0b2030fea4?pvs=21) + [хэш-таблица](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21) с повторяемостью символов в окне.

      **Сложность: время - O(n), память - O(k).**

        ```go
        // Максимальное скользящее окно.
        func lengthOfLongestSubstringKDistinct(s string, k int) int {
            // Левый бегунок окна.
            leftIdx := 0
            // Правый бегунок окна.
            rightIdx := 0
            // Мапа для находящихся в окне букв.
            // Ключ - буква, значение - повторяемость буквы (счетчик).
            // Можно заменить на массив.
            letters := make(map[byte]int)
            // Пока правый бегунок в пределах массива строки.
            for rightIdx < len(s) {
                // Инкрементируем счетчик буквы в мапу и передвигаем правый бегунок.
                letters[s[rightIdx]]++
                rightIdx++
        
                // Если число букв больше k.
                if len(letters) > k {
                    // Уменьшаем счетчик буквы под левым бегунком.
                    letters[s[leftIdx]]--
                    // Если счетчик нулевой - удаляем букву из мапы, чтобы правильно считать
                    // уникальное количество букв в окне.
                    if count, ok := letters[s[leftIdx]]; ok && count <= 0 {
                        delete(letters, s[leftIdx])
                    }
                    // Передвигаем левый бегунок.
                    leftIdx++
                }
            }
        
            // В данном алгоритме мы используем максимальное скользящее окно.
            // Т.е. мы не уменьшаем окно, чтобы добиться искомого количества уникальных букв
            // в окне. Если мы достигли максимального окна, с учетом условий, то мы поддерживаем
            // его размер (смещаем на единицу левый бегунок).
            // Это позволяет не делать лишние операции смещения левого бегунка.
        
            return rightIdx - leftIdx
        }
        ```


### Палиндромы

- Полезное


    - Функция для проверки, является ли строка с буквами палиндромом
        
        ```go
        // Является ли строка палиндромом.
        func isPalindrome(s string) bool {
            // Левый бегунок бежит с начала строки, правый с конца.
            leftIdx, rightIdx := 0, len(s)-1
            // Пока бегунки не встретятся.
            for leftIdx < rightIdx {
                // Сравниваем буквы.
                if s[leftIdx] != s[rightIdx]{
                    return false;
                }
                // Увеличиваем бегунки.
                leftIdx++
                rightIdx--
            }
            // Если дошли сюда - буквы симметричны.
            return true;
        }
        ```

- Является ли **строка** c ASCII символами **палиндромом**

  [LeetCode: 125. Valid Palindrome](https://leetcode.com/problems/valid-palindrome)

    - Условие

      Дана строка. Проверить, является ли строка палиндромом.

      В строке могут быть любые символы, включая пробелы, знаки препинания. В качестве допустимых для палиндрома символов учитываем только буквы и цифры. Буквы равны не зависимо от регистра.

    - Кейсы

      `s = "A man, a plan, a canal: Panama"; res = true;` - палиндром `"amanaplanacanalpanama"`

      `s = "race a car"; res = false;`

      `s = " "; res = true;`

    - Решение 1 (оптимальное): [Два указателя](https://www.notion.so/draft-278415d3ec1246ff9b5b016795685ef8?pvs=21).

      Бежим с обоих концов к центру. Сверяем элементы пропуская все кроме буквы или цифры.

      **Сложность: Время - O(n), память O(1).**

        ```go
        func isPalindrome(s string) bool {
            // Левый указатель (бегунок). Бежит с начала строки.
            leftP := 0
            // Правый указатель (бегунок). Бежит с конца строки.
            rightP := len(s) - 1
            // Для простоты переводим сразу строку в верхний регистр.
            // Можно это делать побуквенно в процессе.
            s = strings.ToUpper(s)
        
            // Пока бегунки не встретились.
            // Таким условием мы покрываем четное и нечетное количество букв, цифр.
            for leftP < rightP {
                // Если слева не буква - пропускаем.
                if !isLetterOrNumber(s[leftP]) {
                    leftP++
                    continue
                }
                // Если справа не буква - пропускаем.
                if !isLetterOrNumber(s[rightP]) {
                    rightP--
                    continue
                }
        
                // Слева и справа буквы. Если буквы не равны - выходим (точно не палиндром).
                if s[leftP] != s[rightP] {
                    return false
                }
                // Обе буквы равны - смещаем оба бегунка.
                leftP++
                rightP--
            }
        
            return true
        }
        
        // Функция для проверки является ли символ буквой или цифрой.
        func isLetterOrNumber(l byte) bool {
            return (l >= 'A' && l <= 'Z') || (l >= '0' && l <= '9')
        }
        ```

- **Является** ли **строка** палиндромом, если можно удалить один символ

  [LeetCode: 680. Valid Palindrome II](https://leetcode.com/problems/valid-palindrome-ii/)

    - Условие

      Дана строка `s`. Проверить, является ли строка палиндромом, если можно удалить из строки не более одного символа.

      В строке могут быть только английские буквы в нижнем регистре.

    - Кейсы

      `s = "aba"; res = true;` - строка палиндром без удаления символа.

      `s = "ab**c**a"; res = true;` - строка палиндром, если удалить `c`

      `s = "abc"; res = false;`

    - Решение 1 (оптимальное): [Два указателя](https://www.notion.so/draft-278415d3ec1246ff9b5b016795685ef8?pvs=21).
        - Бежим с обоих концов к центру.
        - Если текущие буквы не равны, то вызываем простую функцию определения палиндрома для **двух вариантов**: удаляем букву справа и удаляем слева

      **Сложность: Время - O(n), память O(1).**

        ```go
        // Два указателя.
        func validPalindrome(s string) bool {
            // Левый бегунок.
            leftIdx := 0
            // Правый бегунок.
            rightIdx := len(s) - 1
            // Пока бегунки не встретятся.
            for leftIdx < rightIdx {
                // Если буквы под бегунками не равны.
                if s[leftIdx] != s[rightIdx] {
                    // Т.к. мы не знаем с какой стороны нужно удалить букву,
                    // чтобы проверить является ли остальная часть палиндромом,
                    // то придется просчитать 2 варианта:
                    // удаляем букву справа и удаляем слева.
                    return validPalindromeOriginal(s, leftIdx, rightIdx - 1) ||
                        validPalindromeOriginal(s, leftIdx + 1, rightIdx)
                }
                // Буквы равны - смещаем бегунки.
                leftIdx++
                rightIdx--
            }
        
            return true
        }
        
        // Ф-я для определения палиндрома без доп условий.
        func validPalindromeOriginal(s string, leftIdx int, rightIdx int) bool {
            // Пока бегунки не встретятся.
            for leftIdx < rightIdx {
                // Если буквы под бегунками не равны - выходим.
                if s[leftIdx] != s[rightIdx] {
                    return false
                }
                // Буквы равны - смещаем бегунки.
                leftIdx++
                rightIdx--
            }
        
            return true
        }
        ```

- **Является** ли **число** палиндромом

  [LeetCode: 9. Palindrome Number](https://leetcode.com/problems/palindrome-number/)

    - Условие

      Дано целое число `x`. Проверить, является ли число палиндромом.

      Отрицательное число не является палиндромом, т.к. знак минус тоже участвует в сравнении.

    - Кейсы

      `x = 121; res = true;`

      `x = -121; res = false;`

      `x = 10; res = false;`

    - Усложнение

      Could you solve it without converting the integer to a string?

    - Решение 1 (объемное): Преобразование числа в массив цифр и сравнение двумя указателями.

      **Сложность: Время - O(n), память O(n).**

        ```go
        func isPalindrome(x int) bool {
            // Сложно обработать в основном алгоритме.
            if x < 0 {
                return false
            }
            // Представляем число как массив цифр.
            nums := parseIntToSlice(x)
            // Левый бегунок.
            leftIdx := 0
            // Правый бегунок.
            rightIdx := len(nums) - 1
            // Идем от краев к центру числа и сравниваем поэлементно.
            for leftIdx < rightIdx {
                if nums[leftIdx] != nums[rightIdx] {
                    return false
                }
                leftIdx++
                rightIdx--
            }
        
            return true
        }
        
        // Функция для представления числа в виде массива цифр.
        func parseIntToSlice(num int) []int {
            var res []int
        	curNum := num
        	// На каждой итерации делим число на 10 и разделяем целую часть и дробную.
            for curNum > 0 {
                // Делим на 10, дробная часть - правая цифра (35.4).
                offset := float64(curNum) / 10
                // Получаем правую цифру откидывая целую часть (4).
                rightDigit := int(math.Round((offset - float64(int(offset))) * 10))
                // Записываем в массив правую цифру.
                res = append(res, rightDigit)
                // Переопределяем текущее число как целую часть (35).
                curNum = int(offset)
            }
        
            return res
        }
        ```

    - Решение 2: Преобразование числа в строку и сравнение двумя указателями.

      **Сложность: Время - O(n), память O(n).**

        ```go
        func isPalindrome(x int) bool {
            numsStr := strconv.Itoa(x)
            numsLen := len(numsStr)
            for pos, num := range numsStr {
                if num != rune(numsStr[numsLen - pos - 1]) {
                    return false
                }
            }
            
            return true
        }
        ```

    - Решение 3 (короткое): Формируем зеркальное (реверсивное) число и сравниваем его с входящим.

      **Сложность: Время - O(n), память O(n).**

        ```go
        // Формируем зеркальное (реверсивное) число и сравниваем его с входящим.
        func isPalindrome(x int) bool {
        	if x < 0 {
        		return false
        	}
        	temp := x // 12321
        	// Зеркальное (реверсивное) число.
        	reversed := 0
        	// Формируем зеркальное число.
        	for temp != 0 {
        		reversed = 10 * reversed + temp % 10 // 1; 12; 123; 1232; 12321;
        		temp /= 10 // 1232; 123; 12; 1; 0;
        	}
        	// Входящее число и зеркальное должны быть одинаковые.
        	return (reversed == x)
        }
        ```

- Найти **наибольшую подстроку-палиндром**

  [TODO: решить оптимальным способом]

  [LeetCode: 5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)

    - Условие

      Дано строка `s`. Найти наибольшую подстроку, являющуюся палиндромом.

      Строка `s` состоит из цифр и английских букв.

    - Кейсы

      `s = "babad"; res = "bab" || "aba";`

      `s = "cbbd"; res = "bb";`

    - Решение 1 (простое): Итерируемся, считаем каждую букву центром палиндрома, бежим от центра двумя указателями.
        - Итерируемся побуквенно.
        - Считаем букву центром палиндрома.
        - Итеративно идем двумя бегунками направо и налево от буквы и сравниваем буквы под левым и правым бегунком.
            - Если буквы под бегунками одинаковы, то мы внутри палиндрома - продолжаем бежать.
            - Если буквы разные, то сохраняем палиндром, если он больше по буквам, чем максимальный.
        - Учесть также случай, что центр палиндрома может состоять из двух букв.

      **Сложность: Время - O(n^2), память O(1).**

        ```go
        // От каждой буквы пытаемся найти палиндром, считая букву центром палиндрома.
        func longestPalindrome(s string) string {
            // Индекс начала максимального палиндрома.
            startIdx := 0
            // Индекс конца максимального палиндрома.
            endIdx := 0
            for i := 0; i < len(s); i++ {    
                // Пытаемся найти палиндром, с нечетным размером.
                startIdx1, endIdx1 := findBoubdaries(s, i, i)
                // Пытаемся найти палиндром, с четным размером.
                startIdx2, endIdx2 := findBoubdaries(s, i, i + 1)
                // Если палиндром с четным размером больше нечетного и больше максимального -
                // заменяем максимальный.
                if endIdx2 - startIdx2 > endIdx1 - startIdx1 &&
                    endIdx2 - startIdx2 > endIdx - startIdx {
                    endIdx = endIdx2
                    startIdx = startIdx2
                // Если палиндром с нечетным размером больше четного и больше максимального -
                // заменяем максимальный.
                } else if endIdx1 - startIdx1 > endIdx - startIdx {
                    endIdx = endIdx1
                    startIdx = startIdx1
                }
            }
            
            
            return s[startIdx:endIdx + 1]
        }
        // Функция для поиска палидрома, расширяя границы подстроки.
        func findBoubdaries(s string, startIdx, endIdx int) (int, int) {
            // Пока подстрока в размерах строки и буквы по концам палиндрома одинаковые - 
            // расширяемся.
            for ; startIdx >= 0 && endIdx < len(s) && s[startIdx] == s[endIdx]; {
                startIdx--
                endIdx++
            }
            
            startIdx++
            endIdx--
            
            return startIdx, endIdx
        }
        ```

    - Решение 2 (быстрое): [Manacher's algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm). TODO.

      **Сложность: Время - O(n), память O(n).**

        ```go
        
        ```


### Анаграммы

**Анаграмма** - это фраза (или слово), образованная путем перестановки букв другого фразы, с использованием всех букв исходной фразы ровно один раз.

- Являются ли **две строки** анаграммами

  [LeetCode: 242. Valid Anagram](https://leetcode.com/problems/valid-anagram/)

    - Условие

      Даны две строки. Необходимо проверить, являются ли входные две строки анаграммами друг для друга.

      Строки состоят только из английских символов в нижнем регистре.

    - Кейсы

      `s = "anagram", t = "nagaram"; res = true;`

      `s = "rat", t = "car"; res = fa;`

    - **Решение 1 (оптимальное): Массив с маппингом кода буквы на повторяемость буквы + два цикла.**
        - Составляем массив с маппингом кодов букв (со смещением) к повторяемости букв для первой строки.
        - В цикле проверяем каждую букву второй строки на количество из маппинга.

      **Сложность: Время - O(n), память O(1).**

        ```go
        func isAnagram(s string, t string) bool {
            // Если размер разный - выходим.
            if len(s) != len(t) {
                return false
            }
            // Мапа для счетчика букв в строке s.
            // Ключ - буква со смещением, значение - повторяемость (счетчик) буквы в строке.
            // Можно использовать хэш-таблицу, но это менее эффективно.
            var searchIn [28]int
            for _, l := range s {
                searchIn['z' - l]++
            }
            // Сопоставляем повторяемость каждой буквы в строках.
            for _, l := range t {
                // Если счетчик в s пустой - выходим.
                if count := searchIn['z' - l]; count == 0 {
                    return false
                }
                // Уменьшаем счетчик.
                searchIn['z' - l]--
            }
        
            return true
        }
        ```

    - Решение 2: Хэш-таблица с маппингом кода буквы на повторяемость буквы + два цикла. TODO.
        - Составляем массив с маппингом кодов букв (со смещением) к повторяемости букв для первой строки.
        - В цикле проверяем каждую букву второй строки на количество из маппинга.

      **Сложность: Время - O(n*log(n)), память O(n).**

    - Решение 3 (неоптимальное): Сортировка и сопоставление строк.
        - Составляем массив с маппингом кодов букв (со смещением) к повторяемости букв для первой строки.
        - В цикле проверяем каждую букву второй строки на количество из маппинга.

      **Сложность: Время - O(n*log(n)), память O(n).**

- Найти **все анаграммы** в строке

  [LeetCode: 438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)

    - Условие

      Даны две строки `s` и `p`. Найти все анаграммы строки `p` в строке `s`. Вернуть стартовые индексы в массиве букв `s` таких анаграмм (порядок индексов не важен).

      Символы в строках могут быть только английскими буквами в нижнем регистре.

    - Кейсы

      `s = "cbaebabacd", p = "abc"; res = [0,6];` - `["cba", "bac"]`

      `s = "abab", p = "ab"; res = [0,1,2];` - `["ab", "ba", "ab"]`

    - **Решение 1 (оптимальное): Скользящее окно + массив повторений букв.**

      Вместо массивов в качестве словарей можно использовать хэш-таблицы, но это будет чуть дольше и сравнивать их придется вручную.

        - Составляем массив с маппингом кодов букв (со смещением) к повторяемости букв для строки `p`.
        - Объявляем массив с маппингом кодов букв (со смещением) к повторяемости букв для строки `s`.
        - В цикле идем скользящим окном по строке `s` и записываем в маппинг `s` буквы из скользящего окна.
        - На каждой итерации сравниваем маппинг `s` и маппинг `p`. Если они совпадает, мы нашли анаграмму.

      **Сложность: Время - O(len(s)), память O(1).**

        ```go
        // Скользящее окно + словари повторений букв.
        // Аналогичная задача - 567
        func findAnagrams(s string, p string) []int {
            // Анаграмм точно не будет.
            if len(p) > len(s) {
                return nil
            }
            // Искомое количество повторений каждой буквы (искомый словарь).
            // Ключ - это код буквы, значение - количество повторений.
            // Вместо массива можно так же использовать хэш-таблицу, но это будет более затратно.
            // Так же хэш-таблицы нельзя сравнивать между собой.
            var search [26]int
            // Найденное количество повторений каждой буквы (найденный словарь).
            // Ключ - это код буквы, значение - количество повторений.
            var found [26]int
            // Заполняем искомое количество.
            for _, l := range p {
                search[l - 'a']++
            }
        
            // Результирующий слайс стартовых позиций анограмм.
            var res []int
            // Левый указатель (бегунок) скользящего окна.
            leftP := 0
            // Правый указатель (бегунок) скользящего окна.
            for rightP, _ := range s {
                // Окно вышло за рамки допустимого размера.
                if rightP - leftP == len(p) {
                    // Уберем левую букву слева из найденного словаря.
                    found[s[leftP] - 'a']--
                    // Сместим левый бегунок.
                    leftP++
                }
                // Добавим правую букву в найденный словарь.
                found[s[rightP] - 'a']++
        
                // Если словари одинаковые - мы нашли анограмму.
                // Т.к. у нас массив, можно сравнивать.
                // Либо можно перебирать,
                // либо можно соптимизировать и добавить счетчик (но выйдет сложнее).
                if search == found {
                    res = append(res, leftP)
                }
            }
        
            return res
        }
        ```


- **Найдется** ли **анаграмма** в строке

  [LeetCode: 567. Permutation in String](https://leetcode.com/problems/permutation-in-string/)

    - Условие

      Даны две строки `s` и `p`. Проверить, есть ли хоть одна анаграмма строки `p` в строке `s`. Вернуть флаг проверки.

      Символы в строках могут быть только английскими буквами в нижнем регистре.

    - Кейсы

      `s1 = "ab", s2 = "eidbaooo"; res = true;` - `"eid**ba**ooo"`

      `s1 = "ab", s2 = "eidboaoo"; res = false;`

    - **Решение 1 (оптимальное): [Скользящее окно](https://www.notion.so/Sliding-window-draft-e553bdf67d21409eafa60b0b2030fea4?pvs=21) + два словаря для искомых букв и найденных.**

      Вместо массивов в качестве словарей можно использовать хэш-таблицы, но это будет чуть дольше и сравнивать их придется вручную.

        - Составляем массив с маппингом кодов букв (со смещением) к повторяемости букв для строки `p`.
        - Объявляем массив с маппингом кодов букв (со смещением) к повторяемости букв для строки `s`.
        - В цикле идем скользящим окном по строке `s` и записываем в маппинг `s` буквы из скользящего окна.
        - На каждой итерации сравниваем маппинг `s` и маппинг `p`. Если они совпадает, мы нашли анаграмму.

      **Сложность: Время - O(len(s2)), память O(1).**

        ```go
        // Скользящее окно + два словаря для искомых букв и найденных.
        // Аналогичная задача - 438
        // Вместо массивов в качестве словарей можно использовать хэш-таблицы,
        // но это будет чуть дольше и сравнивать их придется вручную.
        func checkInclusion(s1 string, s2 string) bool {
            // При таком случае точно не будет совпадений.
            if len(s1) > len(s2) {
                return false
            }
        
            // Словари. Ключ - код буквы, значение - количество повторений буквы.
            // Словарь с искомыми буквами из s1 (искомый словарь). 
            var search [26]int
            // Словарь с найденными буквами в рамках скользящего окна из s2 (найденный словарь).
            var found [26]int
        
            // Заполняем словари.
            // Найденный словарь заполняем, чтобы во втором цикле отбросить часть итераций.
            for i := 0; i < len(s1); i++ {
                search[s1[i] - 'a']++
                found[s2[i] - 'a']++
            }
        
            // Левый бегунок скользящего окна.
            leftP := 0
            // Правый бегунок скользящего окна.
            // Т.к. мы уже заполнили найденный словарь для первого окна, то начинаем со второго окна.
            for rightP := len(s1); rightP < len(s2); rightP++ {
                // Нашли совпадение словарей - завершаемся.
                if search == found {
                    return true
                }
                // Убираем букву в найденном словаре из-под левого бегунка.
                found[s2[leftP] - 'a']--
                // Смещаем левый бегунок.
                leftP++
                // Добавляем букву в найденном словаре из-под правого бегунка.
                found[s2[rightP] - 'a']++
            }
        
            // Проверяем последнее окно (в цикле проверка запаздывает на одно окно).
            if search == found {
                return true
            }
        
            return false
        }
        ```

    - Решение 2. Сортировка. TODO

      **Сложность: время - O(len(s1)*log(len(s1)) + (len(s2)-len(s1))len(s1)*log(len(s1))), память - O(len(s1)).**

        ```go
        
        ```


### Слова

- **Перевернуть** каждое **слово** в строке

  [LeetCode: 557. Reverse Words in a String III](https://leetcode.com/problems/reverse-words-in-a-string-iii)

    - Условие

      Дана строка `s`. Строка состоит из слов, разделенных пробелами. Необходимо каждое слово перевернуть, сохранив пробелы и порядок слов и вернуть новую строку.

    - Кейсы

      `s = "Let's take LeetCode contest"; res = "s'teL ekat edoCteeL tsetnoc";`

      `s = "God Ding"; res =` `"doG gniD";`

    - Решение 1. Каждое слово сохраняем и инвертируем перебором с конца.

      **Сложность: время - O(n), память - O(1).**

        ```go
        // Каждое слово сохраняем и инвертируем.
        func reverseWords(s string) string {
            // Слово.
            var word []byte
            // Результирующий массив символов.
            res := make([]byte, 0, len(s))
            // Перебираем строку, выходим за рамки массива чтобы обработать последнее слово.
            for i := 0; i <= len(s); i++ {
                // Если пробел или вышли за рамки массива - инвертируем слово и сохраняем.
                if len(word) > 0 && (i == len(s) || s[i] == ' ') {
                    // Инвертируем слово и сохраняем.
                    for j := len(word) - 1; j >= 0; j-- {
                        res = append(res, word[j])
                    }
                    // Обнуляем слово.
                    word = nil
                    // Добавляем пробел
                    res = append(res, ' ')
                } else {
                    // Формируем слово.
                    word = append(word, s[i])
                }
            }
        
            // Убираем последний пробел.
            return string(res[:len(res) - 1])
        }
        ```

    - Решение 2 (оптимальное). Каждое слово инвертируем [двумя указателями](https://www.notion.so/draft-278415d3ec1246ff9b5b016795685ef8?pvs=21). TODO.

      **Сложность: время - O(n), память - O(1).**

        ```go
        
        ```

- Расставить слова в строке в **обратном** **порядке**

  [LeetCode: 151. Reverse Words in a String](https://leetcode.com/problems/reverse-words-in-a-string)

    - Условие

      Дана строка `s`. Строка состоит из слов, разделенных пробелами. Необходимо составить новую строку так, чтобы порядок слов стал обратным. Вернуть новую строку.

      Так же нужно убрать лишние пробелы. Т.е. в новой строке должен быть только один пробел между словами.

    - Кейсы

      `s = "the sky is blue"; res = "blue is sky the";`

      `s = "  hello world  "; res = "world hello";`

      `s = "a good   example"; res = "example good a";`

    - Усложнение

      If the string data type is mutable in your language, can you solve it **in-place** with `O(1)` extra space?

    - Решение 1. Промежуточный массив со словами.

      **Сложность: время - O(n), память - O(n).**

        ```go
        // не очень оптимальное решение через промежуточный массив со словами
        func reverseWords(s string) string {
            // промежуточный массив со словами
            words := [][]byte{nil}
            // индекс текущего слова в массиве
            wordIdx := 0
        		//
            for i := 0; i < len(s); i++ {
                // если пробел, то добавляем новое пустое слово в массив
                // в случае с двойным пробелом мы просто ниже будем пропускать пустые слова
                if s[i] == 32 {
                    words = append(words, nil)
                    wordIdx++
                    continue
                }
                // добавляем слово побуквенно
                words[wordIdx] = append(words[wordIdx], s[i])
            }
        
            // результирующий массив байт
            var res []byte
            // перебираем массив слов в обратном порядке
            // и собираем результирующую строку
            for i := len(words) - 1; i >= 0; i-- {
                // пустое слово может быть из-за дублирования пробелов
                if words[i] == nil {
                    continue
                }
                // добавляем пробел перед словом
                res = append(res, byte(32))
                // добавляем слово
                res = append(res, words[i]...)
            }
        
            // убираем первый лишний пробел
            return string(res[1:])
        }
        ```

    - Решение 2. Промежуточный массив со словами через `strings.Split()`.

      **Сложность: время - O(), память - ??.**

        ```go
        // не очень оптимальное решение через промежуточный массив со словами
        func reverseWords(s string) string {
            // промежуточный массив со словами
            words := strings.Split(s, " ")
        
            // результирующий массив байт
            var res []byte
            // перебираем массив слов в обратном порядке
            // и собираем результирующую строку
            for i := len(words) - 1; i >= 0; i-- {
                // пустое слово может быть из-за дублирования пробелов
                if len(words[i]) == 0 {
                    continue
                }
                // добавляем пробел перед словом
                res = append(res, byte(32))
                // добавляем слово
                res = append(res, []byte(words[i])...)
            }
        
            // убираем первый лишний пробел
            return string(res[1:])
        }
        ```

- **Разбить строку без лидирующих и лишних пробелов** на **слова**

  [LeetCode: 2114. Maximum Number of Words Found in Sentences](https://leetcode.com/problems/maximum-number-of-words-found-in-sentences)

    - Условие

      Дана строка `s`. Строка состоит из слов, разделенных пробелами. Необходимо подсчитать количество слов.

      **Лидирующих и лишних пробелов в строке нет**.

    - Кейсы

      `s = "the sky is blue"; res = "blue is sky the";`

      `s = "  hello world  "; res = "world hello";`

      `s = "a good   example"; res = "example good a";`

    - Решение 1. Подсчет слов по пробелам вручную.

      **Сложность: время - O(n*m), память - O(1).**

        ```go
        func mostWordsFound(sentences []string) int {
          // Результирующее количество слов.
          maxCount := 0
        	for _, sentence := range sentences {
            // Количество слов в текущем предложении.
        		wordsCount := 1
        		for _, char := range sentence {
        			if char == ' ' {
        			    wordsCount++
        			}
        		}
            if wordsCount > maxCount {
                maxCount = wordsCount
            }
        	}
        
        	return maxCount
        }
        ```

    - Решение 2. Подсчет слов с помощью `strings.Count`.

      **Сложность: время - O(n*m), память - O(1).**

        ```go
        func mostWordsFound(sentences []string) int {
          // Результирующее количество слов.
          res := 0
            for _, s := range sentences {
                numberOfWords := strings.Count(s, " ") + 1
                if  numberOfWords > res {
                    res = numberOfWords
                }
            }
        
            return res 
        }
        ```

- **Наибольший общий префикс в наборе слов**

  [LeetCode: 14. Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix)

    - Условие

      Дана массив слов `strs`. Необходимо найти наибольший общий префикс этих слов.

    - Кейсы

      `strs = ["flower","flow","flight"]; res = "fl";`

      `strs = ["dog","racecar","car"]; res = "";`

    - **Решение 1 (оптимальное). Итерируемся сначала по словам, потом по буквам и уменьшаем префикс.**
        - Устанавливаем префикс как первое слово.
        - Итерируемся по оставшимся словам.
        - Для каждого итерируемого слова сравниваем каждую букву префикса и слова, если буква отличается, то обновляем префикс и завершаем обработку слова.
        - Пример

          ![14_basic.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/14_basic.png)


        **Сложность: время - O(s), память - O(1), где s - количество букв во всех словах.**
        
        ```go
        // Устанавливаем начальный префикс в первое слово.
        // Сравниваем префикс каждого слова.
        func longestCommonPrefix(strs []string) string {
            // Устанавливаем первый префикс.
            // Должен быть хотя бы один элемент в массиве.
            prefix := []byte(strs[0])
            for _, word := range strs {
                // Если префикс пустой - общего префикса нет.
                if len(prefix) == 0 {
                    break
                }
                for letterIdx := range word {
                    // Если текущее слово больше префикса - переходим к другому слову
                    if letterIdx >= len(prefix) {
                        break
                    }
                    // Если буква в префиксе и слове не совпадает - переходим к другому слову
                    if prefix[letterIdx] != word[letterIdx] {
                        prefix = prefix[:letterIdx]
                    }
                }
                // Сюда пришли если слово совпадает.
                // Если слово меньше префикса - урезаем префикс.
                if len(word) < len(prefix) {
                    prefix = prefix[:len(word)]
                }
            }
        
            return string(prefix)
        }
        ```
        
    - Решение 2. Итерируемся сначала по позициям букв, потом по словам и увеличиваем префикс. TODO.
        
        итерируемся в бесконечном цикле по позиции буквы для всех слов. Для каждого слова берем текущую букву и сравниваем, если буквы несопдают, мы нашли префикс - выходим.
        
        **Сложность: время - O(s), память - O(1), где s - количество букв во всех словах.**
        
        ```go
        
        ```

- Сравнить **слова** в строке с **паттерном** (изоморфность паттерна и строки)

  [LeetCode: 290. Word Pattern](https://leetcode.com/problems/word-pattern)

    - Условие

      Дана строка `s` содержащая слова (буквы от 1) и одиночные пробелы между словами и строка `pattern`, содержащая буквы. Нужно выяснить содержит ли строка данный паттерн.

      Имеется в виду, что буква в паттерне соответствует уникальному слову в строке, нужно сопоставить порядок букв в паттерне и слов в строке.

    - Кейсы

      `pattern = "abba", s = "dog cat cat dog"; res = true;`

      `pattern = "abba", s = "dog cat cat fish"; res = false;`

      `pattern = "aaaa", s = "dog cat cat dog"; res = false;`

    - **Решение 1 (оптимальное). Две хэш-таблицы + strings.Split.**

      [TODO: описать]

      **Сложность: время - O(len(s)), память - O(len(s)).**

        ```go
        // Две хэш-таблицы + strings.Split.
        func wordPattern(pattern string, s string) bool {
        	// Получаем массив слов.
        	words := strings.Split(s, " ")
        	// Мапа последних индексов букв в паттерене. Ключ - буква, значение - последний индекс.
        	lettersIndexes := make(map[byte]int, len(pattern))
        	// Мапа последних индексов слов. Ключ - слово, значение - последний индекс.
        	wordsIndexes := make(map[string]int, len(pattern))
        	// Если количество слов не сходится с количеством букв в паттерне - выходим.
        	if len(pattern) != len(words) {
        		return false
        	}
        
        	for i := range pattern {
        		// Текущая буква.
        		letter := pattern[i]
        		// Текущее слово.
        		word := words[i]
        		// Индекс последней найденной буквы. 0, если не найден.
        		letterIdx := lettersIndexes[letter]
        		// Индекс последнего найденного слова. 0, если не найден.
        		wordIdx := wordsIndexes[word]
        		// Если индексы не равны - выходим.
        		if letterIdx != wordIdx {
        			return false
        		}
        		// Обновляем последние индексы. +1, чтобы отдельно не обрабатывать кейс с не найденой буквой или словом (под ключом 0 всегда 0).
        		lettersIndexes[letter] = i + 1
        		wordsIndexes[word] = i + 1
        	}
        
        	return true
        }
        ```

    - Решение 2 (объемное, быстрое). Одна хэш-таблица для букв в паттерне и слов в строке с ручной итерацией по словам + сравнение.

      [TODO: описать]

      **Сложность: время - O(len(s)), память - O(len(s)).**

        ```go
        // Хэш-таблица.
        func wordPattern(pattern string, s string) bool {
            // Маппинг либо слова либо буквы из паттерна на индекс в паттерне.
            // Ключ - буква из паттерна либо слово из s.
            // Строки можно сравнивать, слайсы байт нельзя.
            // Значение - текущий индекс в паттерне.
            // Добавлять слово в качестве ключа нужно для кейса:
            // pattern="abba";s="dog dog dog dog".
            // Для слова добавляем префикс _, т.к. слово в s может быть одной буквой:
            // pattern="abc";s="b c a".
            charsToIdx := make(map[string]int)
            // Добавим пустое слово для кейса pattern="he";s="unit".
            charsToIdx["_"] = -1
            // Бегунок для s.
            wordIdx := 0
            // Для каждой буквы из паттерна перебираем слова из s.
            for patternIdx := 0; patternIdx < len(pattern); patternIdx++ {
                // Для слова добавляем префикс _, т.к. слово в s может быть одной буквой.
                word := []byte{'_'}
                // Формируем текущее слово из s.
                for ; wordIdx < len(s); wordIdx++ {
                    // Прерываемся на пробеле.
                    if s[wordIdx] == ' ' {
                        wordIdx++
                        break
                    }
                    word = append(word, s[wordIdx])
                }
                // Переводим в строки.
                // Текущая буква из pattern.
                patternStr := string(pattern[patternIdx])
                wordStr := string(word)
                // Ищем в мапе букву и слово.
                existPatternIdx, isPatternExist := charsToIdx[patternStr]
                existWordIdx, isWordExist := charsToIdx[wordStr]
                // Если не нашли, то добавляем.
                if !isPatternExist && !isWordExist {
                    charsToIdx[patternStr] = patternIdx
                    charsToIdx[wordStr] = patternIdx
                    continue
                }
                // Если нашли и букву и слово под одним индексом - успех.
                if isPatternExist && isWordExist && existPatternIdx == existWordIdx {
                    continue
                }
                // Сюда пришли, когда слово не совпало с паттерном.
                return false
            }
        
            // Не обработали все слова (букв в паттерне меньше чем слов).
            if wordIdx != len(s) {
                return false
            }
        
            return true
        }
        ```


- **Поиск слова в матрице** с возможностью искать соседние буквы по горизонтали и вертикали

  [LeetCode: 79. Word Search](https://leetcode.com/problems/word-search)

    - Условие

      Дана матрица `board` в виде двухмерного массива размером `m*n` с буквами в ячейках, дана строка `word`. Необходимо проверить можно ли составить слово `word` (точнее, набор букв) в матрице если обходить соседние ячейки по горизонтали или вертикали.

      ![word2.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/word2.jpg)

    - Кейсы
        - `board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"; res = true;`

          ![word2.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/word2%201.jpg)

        - `board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"; res = true;`

          ![word-1.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/word-1.jpg)

        - `board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"; res = false;`

          ![word3.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/word3.jpg)

    - Усложнение

      Could you use search pruning to make your solution faster with a larger `board`?

    - Решение 1. [Backtracking](https://www.notion.so/Backtracking-c11e4366b07a44f880d47601a133111b?pvs=21) ([обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) (DFS)).

      **Сложность: время - O(len(board[0])*3^len(word)), память - O(len(word))**.

        ```go
        // Обход в глубину (DFS).
        // Т.к. могут быть дублирующие буквы, то циклом будет сложно воспользоваться, нужна рекурсия. Например, кейс:
        // board=[["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]];word="SEE";
        // Из S мы можем уйти наверх и не найти еще одну E, а можем уйти вниз и найти вторую E.
        func exist(board [][]byte, word string) bool {
            // Перебираем все элементы в матрицы и для каждого вызываем рекурсию с поиском DFS.
            for rowIdx := 0; rowIdx < len(board); rowIdx++ {
                for colIdx := 0; colIdx < len(board[rowIdx]); colIdx++ {
                    if searchWord(board, word, rowIdx, colIdx) {
                        return true
                    }
                }
            }
        
            return false
        }
        
        func searchWord(board [][]byte, word string, rowIdx int, colIdx int) bool {
            if len(word) == 0 {
                // Сюда можем прийти только если все буквы в искомом слове и матрице совпали (плюс слово закончилось).
                return true
            }
            // Проверяем, что мы находимся в рамках матрицы.
            if rowIdx < 0 ||
                rowIdx >= len(board) ||
                colIdx < 0 ||
                colIdx >= len(board[rowIdx]) {
                return false
            }
            // Индекс для обработки текущей буквы в искомом слове.
            wordIdx := 0
            // Текущая буква в искомом слове и матрице не сопадает - выходим из рекурсии.
            if board[rowIdx][colIdx] != word[wordIdx] {
                return false
            }
            // Важный кейс: нам нужно понимать, с какого элемента в матрице мы пришли (чтобы его не обрабатывать), иначе можем получить ложно положительный результат сравнения.
            if board[rowIdx][colIdx] == '*' {
                return false
            }
            // Поэтому сохраним текущий элемент и заменим его на фиктивный ложный элемент, чтобы во вложенных рекурсиях не обрабатывать этот элемент.
            // Это нельзя сделать через передачу индексов предыдущего обработанного элемента, т.к. мы может быть кейс с закольцованным совпадением слова.
            saved := board[rowIdx][colIdx]
            board[rowIdx][colIdx] = '*'
            // Запускаем рекурсии на каждое направление.
            // Если в какой-то рекурсии мы выйдем за пределы матрицы, в самом начале рекусии есть проверка.
            down := searchWord(board, word[wordIdx + 1:], rowIdx - 1, colIdx)
            up := searchWord(board, word[wordIdx + 1:], rowIdx + 1, colIdx)
            left := searchWord(board, word[wordIdx + 1:], rowIdx, colIdx - 1)
            right := searchWord(board, word[wordIdx + 1:], rowIdx, colIdx + 1)
            // Возвращаем оригинальный элемент вместо фиктивного.
            board[rowIdx][colIdx] = saved
        
            return down || up || left || right
        }
        ```


### Скобочные последовательности

- Является ли строка **правильной скобочной последовательностью**

  [LeetCode: 20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses)

    - Условие

      Дана строка со скобками `{}()[]`. Нужно проверить все ли открытые скобки закрыты в правильном порядке.

    - Кейсы

      `s = "()"; res = true;`

      `s = "()[]{}"; res = true;`

      `s ="(]" res = false;`

    - Решение 1. [Стэк](https://www.notion.so/8c2aa09cb4994480a7b115d6eee03a49?pvs=21).

      **Сложность: время - O(n), память - O(n).**

        ```go
        func isValid(s string) bool {
            // Стэк, складываем открывающиеся скобочки.
            var stack []rune
            // Маппинг закрывающихся скобочек к открывающимся.
            closedToOpen := make(map[rune]rune)
            closedToOpen[')'] = '('
            closedToOpen[']'] = '['
            closedToOpen['}'] = '{'
            for _, par := range s {
                // Ищем открывающую скобочку по закрывающей.
                open, ok := closedToOpen[par]
                // Если текущая скобка открывающая - добавляем в стэк.
                if !ok {
                    stack = append(stack, par)
                    continue
                }
        
                // Если текущая скобка закрывающая, то в стэке должна быть соответствующая открывающая.
                if len(stack) == 0 || stack[len(stack) - 1] != open {
                    return false
                }
                // Уменьшаем стэк, т.к. мы закрыли скобку.
                stack = stack[:len(stack) - 1]
            }
            
            // Стэк должен быть пуст.
            if len(stack) > 0 {
                return false
            }
            
            return true
        }
        ```

- **Подсчет скобочек арифметическими операциями**

  [LeetCode: 856. Score of Parentheses](https://leetcode.com/problems/score-of-parentheses)

    - Условие

      Дана строка с правильной скобочной последовательностью `s`. Необходимо сделать расчет строки, учитывая, что:

        - `()` = 1
        - две правильные скобочные последовательности суммируются, например, `()()` = 1 + 1 = 2
        - при вложении скобочной последовательности она умножается на 2, например, `(())` = 2 x 1 = 2

      Строка состоит только из символов `(`, `)`.

    - Кейсы

      `s = "()"; res = 1;`

      `s = "(())"; res = 2;`

      `s = "()()"; res = 2;`

      `s = "(()(()))"; res = 6;` - `(()(())) -> (1(1)) -> (1+1*2) -> (3) -> 3*2 -> 6`;

    - **Решение 1 (простое, быстрое). [Стек](https://www.notion.so/8c2aa09cb4994480a7b115d6eee03a49?pvs=21).**
        - Примеры

            ```
            Последовательность     Стек          Расчет
            ------------------     ----          ------
            		   (())             [0]
                   (               [0,0]          
            				(             [0,0,0]
                     )             [0,1]         pop + 1 = 0 + 1 + 0 = 1
                      )             [2]          pop * 2 = 1 * 2 + 0 = 2
            ------------------     ----          ------
                   ()()             [0]
                   (               [0,0]          
            				)               [1]          pop + 1 = 0 + 1 + 0 = 1
                     (             [1,0]         
                      )             [2]          pop + 1 = 0 + 1 + 1 = 2
            ------------------     ----          ------
                 (()(()))           [0]
                 (                 [0,0]          
            			(               [0,0,0]        
                   )               [0,1]         pop + 1 = 0 + 1 + 0 = 1
                    (             [0,1,0]        
                     (           [0,1,0,0]
                      )           [0,1,1]        pop + 1 = 0 + 1 + 0 = 1
                       )           [0,3]         pop * 2 = 1 * 2 + 1 = 3 
                        )           [6]          pop * 2 = 3 * 2 + 0 = 6
            ```


        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // Стек.
        func scoreOfParentheses(s string) int {
            // Стек для расчета. Нулевой элемент нужен, чтобы положить в него итоговый расчет.
            stack := []int{0}
            for i := range s {
                // Текущая скобка открывающая.
                if s[i] == '(' {
                    // Добавляем на стек 0, т.к. операция не завершена.
                    stack = append(stack, 0)
                    continue
                }
                // Текущая скобка закрывающая - операция завершена, нужно рассчитать.
                // Инкремент для завершения операции.
                currentScoreIncr := 0
                // Извлекаем значение последней операции и уменьшаем стек (pop).
                lastScore := stack[len(stack) - 1]
                stack = stack[:len(stack) - 1]
                // Последняя операция это либо вложенные скобки (()), либо сложный расчет.
                if lastScore > 0 {
                    currentScoreIncr = lastScore * 2
                } else { // Последняя операция это открытая скобка - закрываем (+1).
                    currentScoreIncr = 1
                }
                // Инкрементируем предпоследнюю операцию.
                // Это может быть рассчитанная операция () или сложная операция.
                stack[len(stack) - 1] += currentScoreIncr
            }
            // В сути здесь должен остаться один элемент.
            return stack[len(stack) - 1]
        }
        ```
        
    - Решение 2 (оптимальное). Два счетчика и битовый сдвиг. TODO
        
        **Сложность: время - O(n), память - O(1).**
        
        ```go
        
        ```

- Найти длину **наибольшей подстроки**, являющейся **правильной скобочной последовательностью**

  [LeetCode: 32. Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses)

    - Условие

      Дана строка со скобочной последовательностью `s`. Необходимо найти максимальную подстроку, которая является правильной скобочной последовательностью.

      Строка состоит только из символов `(`, `)`.

    - Кейсы

      `s = "(()"; res = 2;` - максимальная подстрока - `()`;

      `s = ")()())"; res = 4;` - максимальная подстрока - `()()`;

      `s = ""; res = 0;`

      `s = "())((())"; res = 4;`

    - **Решение 1 (простое, быстрое). [Стек](https://www.notion.so/8c2aa09cb4994480a7b115d6eee03a49?pvs=21).**
        - Примеры

            ```
            Последовательность      Стек          Текущий размер       Максимальный размер
            ------------------      ----          --------------       -------------------
                   0123
            		   (())             [-1]                                         
                   (               [-1,0]                                        0     
            				(             [-1,0,1]                                       0
                     )             [-1,0]         2 - 0 = 2                      2
                      )             [-1]          3 - (-1) = 4                   4
            ------------------      ----          --------------       -------------------
            			 0123
                   ()()             [-1]
                   (               [-1,0]                                        0
            				)               [-1]          2 - 0 = 2                      2  
                     (             [-1,2]                                        2
                      )             [-1]          3 - (-1) = 4                   4   
            ------------------      ----          --------------       -------------------
            		 01234567
                 ())((())           [-1]
                 (                 [-1,0]                                        0 
            			)                 [-1]          1 - (-1) = 2                   2  
                   )                [2]                                          2
                    (              [2,3]                                         2
                     (            [2,3,4]                                        2
                      (          [2,3,4,5]                                       2     
                       )          [2,3,4]         6 - 4 = 2                      2  
                        )          [2,3]          7 - 3 = 4                      4  
            ```


        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // Стек.
        func longestValidParentheses(s string) int {
            // Стек для скобочек. Значение - индекс скобочки.
            // Это всегда открывающая скобочка, но если стек заканчивается кладем фиктивную закрывающую,
            // чтобы считать правильную последовательность до нее и не делать лишних if-ов.
        		// Так же сразу кладем -1, чтобы было можно сразу рассчитывать.
            // )  - [-1] -> [0]
        		// (  - [-1] -> [-1,0]
        		// () - [-1] -> [-1,0] -> [-1]
        		// )) - [-1] -> [0] -> [1]
            stack := []int{-1}
            // Размер максимальной подстроки (результат).
            res := 0
            for i := range s {
                // Текущая скобочка открывающая - добавляем на стек.
                if s[i] == '(' {
                    stack = append(stack, i)
                    continue
                }
                // Текущая скобочка закрывающая.
                // Убираем последнюю скобочку (открывающую или фиктивную закрывающую).
                stack = stack[:len(stack) - 1]
                // Если стек пустой - добавляем закрывающую, чтобы теперь считать до нее.
                if len(stack) == 0 {
                    stack = append(stack, i)
                    continue
                }
                // Если стек не был пустой -
                // считаем размер подстроки до последней скобочки в стеке.
                subStrLen := i - stack[len(stack) - 1]
                // Если размер больше максимального - перезаписываем.
                if subStrLen > res {
                    res = subStrLen
                }
            }
        
            return res
        }
        ```
        
    - Решение 2 (сложное, быстрое). Динамическое программирование.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        
        ```
        
    - Решение 3 (сложное, оптимальное). Счетчики.
        
        **Сложность: время - O(n), память - O(1).**
        
        ```go
        
        ```

- **Подсчет скобочек арифметическими операциями**

  [LeetCode: 678. Valid Parenthesis String](https://leetcode.com/problems/valid-parenthesis-string)

    - Условие

      Дана строка со скобочной последовательностью `s`. Строка может содержать символы: `**(**`, `**)**`, `*****`. Необходимо вернуть флаг является ли строка правильной скобочной последовательностью, при условии, что символ `*****` можно **заменить на любую скобку** или **пропустить**.

    - Кейсы

      `s = "()"; res = true;`

      `s = "(*)"; res = true;`

      `s = "(*))"; res = true;`

      `s = "((*)"; res = true;`

      `s = "(((*)"; res = false;`

      `s = "(**()*"; res = true;`

      `s = "(*)))"; res = false;`

    - **Решение 1 (оптимальное). [Жадный алгоритм](https://www.notion.so/draft-4ad9b8d9fdc2402f838dd04480cb1f80?pvs=21) - подсчет комбинаций скобочек.**

      Считаем минимальное количество открытых скобочек и максимальное количество открытых скобочек.

        - Примеры

            ```
            Последовательность   minCount    maxCount
            ------------------   --------    --------
            		  (**()*                   
                  (                (+)1       (+)1
                   *               (-)0       (+)2
                    *              (-)0       (+)3
                     (             (+)1       (+)4
                      )            (-)0       (-)3
                       *           (-)**0**       (+)4
            = true
            ------------------   --------    --------
            		  (((*)                   
                  (                (+)1       (+)1
                   (               (+)2       (+)2
                    (              (+)3       (+)3
                     *             (-)2       (+)4
                      )            (-)**1**       (-)3
            = false
            ------------------   --------    --------
            		  (*)))                   
                  (                (+)1       (+)1
                   *               (-)0       (+)2
                    )              (-)0       (-)1
                     )             (-)0       (-)0
                      )            (-)**-1**      (-)-1
            = false
            ------------------   --------    --------
            ```


        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // Жадный алгоритм - подсчет комбинаций скобочек.
        func checkValidString(s string) bool {
            // Минимально возможное количество открытых скобок.
            minCount := 0
            // Максимально возможное количество открытых скобок.
            maxCount := 0
            for _, ch := range s {
                // Если открывающая скобка - увеличиваем оба счетчика.
                if ch == '(' {
                    minCount++
                    maxCount++
                }
                // Если закрывающая скобка - уменьшаем оба счетчика.
                if ch == ')' {
                    minCount--
                    maxCount--
                }
                // Если звездочка - расширяем окно, т.е. добавляем две комбинации.
                if ch == '*' {
                    minCount--
                    maxCount++
                }
                // Если вышли за границы максимального счетчика -
                // последовательность неправильная - (*))).
                if maxCount < 0 {
                    break
                }
                // Выходить за рамки минимального счетчика можно.
                if minCount < 0 {
                    minCount = 0
                }
            }
        
            // Считаем остаток открытых скобочек по минимальному счетчику.
            return minCount == 0
        }
        ```
        
    - Решение 2 (объемное, долгое). [Динамическое программирование](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21). TODO
        
        **Сложность: время - O(n^3), память - O(n^2).**
        
        ```go
        
        ```


### Найти подстроку

- Найти **первую подстроку** равную искомой

  [LeetCode: 28. Find the Index of the First Occurrence in a String](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string)

  [TODO: решить другими алгоритмами]

    - Условие

      Даны две строки с буквами. Нужно найти вхождение (вернуть индекс первой строки) второй строки в первую.

    - Кейсы

      `haystack = "**sad**butsad", needle = "sad"; res = 0;`

      `haystack = "leetcode", needle = "leeto"; res = -1;`

    - Решение 1. [Скользящее окно](https://www.notion.so/Sliding-window-draft-e553bdf67d21409eafa60b0b2030fea4?pvs=21).

      **Сложность: время - O(n*m), память - O(1).**

        ```go
        func strStr(haystack string, needle string) int {
            // Итерируемся по haystack до n - len(needle) элемента,
            // т.к. дальше точно не будет совпадений.
            for i := 0; i <= len(haystack) - len(needle); i++ {
                // Если подстрока от текущей буквы идентична needle - мы нашли совпадение.
                // Тут можно в еще одном цикле перебрать, чтобы не использовать лишнюю память под слайс.
                if haystack[i:i+len(needle)] == needle{
                    return i
                }
            }
        
            return -1
        }
        ```

        - Если вместо сравнения слайса перебирать:

            ```go
            func strStr(haystack string, needle string) int {
                m := len(needle)
                n := len(haystack)
            
                for windowStart := 0; windowStart <= n - m; windowStart++ {
                    for i := 0; i < m; i++ {
                        if needle[i] != haystack[windowStart + i] {
                            break
                        }
                        if i == m - 1 {
                            return windowStart
                        }
                    }
                }
            
                return -1
            }
            ```

    - Есть еще много алгоритмов.

      ****Rabin-Karp Algorithm (Single Hash)****

      ****Rabin-Karp algorithm (Double Hash)****

      ****Knuth–Morris–Pratt Algorithm****


- Найти **наибольшую подстроку** из **повторяющегося** символа, если в строке можно **заменить k символов**

  [LeetCode: 424. Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement)

    - Условие

      Дана строка `s`. Необходимо найти наибольшую подстроку, в которой будет повторяться только один символ с учетом того, что можно заменить любой символ в строке на любой другой символ `k` раз. Вернуть длину такой подстроки.

    - Кейсы

      `s = "AABABBA", k = 1; res = 4;` - можно заменить 3-й элемент на `A` и получить `"**AAAA**BBA"`

      `s = "ABAB", k = 2; res = 4;`

      `s = "ABAB", k = 2; res = 4;`

      `s = "A", k = 0;`
      `s = "AB", k = 0;`
      `s = "ABCDA", k = 1;`
      `s = "ABCDA", k = 5;`
      `s = "AABABBA", k = 1;`

    - **Решение 1 (оптимальное). [Скользящее окно](https://www.notion.so/Sliding-window-draft-e553bdf67d21409eafa60b0b2030fea4?pvs=21) + [хэш-таблица](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21).**

      В скользящем окне собираем мапу с символами и их повторяемостью, так же сохраняем максимально повторяющийся символ. Если из количества повторов максимально повторяющегося символа вычесть `k` и получится `0`, то мы нашли искомую подстроку.

      **Сложность: время - O(n), память - O(k).**

        ```go
        // Скользящее окно + хэш-таблица.
        func characterReplacement(s string, k int) int {
            // Используем максимальное скользящее окно.
            // Т.е. не возвращаем левый бегунок для актуализации k.
        
            // Мапа повторяемости букв в окне.
            // Ключ - буква, значение - повторяемость (счетчик).
        		**// Если в качестве символов только буквы, то можно использовать массив вместо мапы.**
            lettersToCount := make(map[byte]int)
            // Приоритетная буква (буква с максимальным кол-вом повторений).
            var priorityLetter byte
            // Левый бегунок, бежит с начала.
            leftIdx := 0
            // Правый бегунок, бежит с начала.
            rightIdx := 0
            for ; rightIdx < len(s); rightIdx++ {
                // Увеличиваем счетчик буквы под правым бегунком.
                lettersToCount[s[rightIdx]]++
                // Если буква под правым бегунком чаще повторяется, чем текущая приоритетная буква - подменяем приоритетную букву.
                if lettersToCount[s[rightIdx]] > lettersToCount[priorityLetter] {
                    priorityLetter = s[rightIdx]
                }
                // Если количество букв в окне превысило сумму приоритетных букв и остальных (букв, которые можно подменить), то декрементируем счетчик буквы под левым бегунком и смещаем левый бегунок.
                if rightIdx - leftIdx + 1 > k + lettersToCount[priorityLetter] {
                    lettersToCount[s[leftIdx]]--
                    leftIdx++
                }
            }
        
            // Размер окна и является результатом.
            return rightIdx - leftIdx
        }
        
        // Кейсы:
        // s="A";k=0
        // s="AB";k=0
        // s="ABCDA";k=1
        // s="ABCDA";k=5
        // s="AABABBA";k=1
        ```

    - Решение 2. [Скользящее окно](https://www.notion.so/Sliding-window-draft-e553bdf67d21409eafa60b0b2030fea4?pvs=21) + [бинарный поиск](https://www.notion.so/8aa67c33fcbe4ce6913fc300d98e87a3?pvs=21).

      **Сложность: время - O(n*log(n)), память - O(k).**

        ```go
        
        ```


- **Отличаются** ли **две строки** только **одним** символом

  [LeetCode: 161. One Edit Distance](https://leetcode.com/problems/one-edit-distance)

    - Условие

      Даны две строки. Нужно определить можно ли из первой строки сделать вторую (или наоборот из второй первую), если использовать операцию над одним символом.

      **Доступные операции:**

        - Можно **вставить** один символ в первую строку
        - Можно **удалить** один символ в первую строку
        - Можно **заменить** один символ из первой строки любым символом из второй строки
    - Кейсы

      `s = "abcd"; t = "ab**e**cd"; res = true;`

      `s = "ab**e**cd"; t = "abcd"; res = true;`

      `s = "ab**e**cd"; t = "ab**k**cd"; res = true;`

      `s = "abcd**e**"; t = "abcd"; res = true;`

      `s = "abcd"; t = "abcd**e**"; res = true;`

      `s = "a"; t = "b"; res = true;`

      `s = "ac"; t = "c"; res = true;`

      `s = "ac"; t = "c"; res = true;`

      `s = "c"; t = "ac"; res = true;`

      `s = ""; t = ""; res = false;`

    - Решение 1 (оптимальное): [Два указателя](https://www.notion.so/draft-278415d3ec1246ff9b5b016795685ef8?pvs=21).
        - Можно **вставить** один символ в первую строку
        - Можно **удалить** один символ в первую строку

      Вышеуказанные условия можно взаимозаменить переставив строки местами. Т.е. если одна строка больше другой на 1 символ, то можно несовпадающий символ просто проигнорировать. Это упростит алгоритм.

      **Сложность: время - O(n), память - O(n).**

        ```go
        func isOneEditDistance(s string, t string) bool {
            // s должна быть не меньше t (s >= t), так мы уберем лишние if-ы    
            if len(s) < len(t) {
                return isOneEditDistance(t, s)
            }
        
            for i := 0; i < len(t); i++ {
                // Символы равны - пропускаем итерацию.
                if s[i] == t[i] {
                    continue
                }
                // Текущие символы не равны.
                // Если длина строк одинаковая,
                // то может пропустить текущие символы в обоих строках и сравнить строки.
                if len(s) == len(t) {
                    //return isStringsEqual(s[i+1:len(s)], t[i+1:len(t)])
                    return s[i+1:len(s)] == t[i+1:len(t)]
                }
                // Т.к. s >= t,
                // то мы можем пропустить символ из s и сравнить оставшиеся части строк.
                if len(s) - 1 == len(t) {
                    //return isStringsEqual(s[i+1:len(s)], t[i:len(t)])
                    return s[i+1:len(s)] == t[i:len(t)]
                }
        
                return false
            }
        
            // Дообрабатываем кейсы:
            // ac - c
            // a - a
            return len(s) - 1 == len(t)
        }
        
        // Ф-я для сравнения строк. Сравниваем по длине и по символам.
        // Можно ее заменить встроенным сравнением.
        func isStringsEqual(s1 string, s2 string) bool {
            if len(s1) != len(s2) {
                return false
            }
        
            for i := 0; i < len(s1); i++ {
                if s1[i] != s2[i] {
                    return false
                }
            }
        
            return true
        }
        ```

- **Перевернуть** (развернуть относительно середины) **строку**

  [LeetCode: 344. Reverse String](https://leetcode.com/problems/reverse-string)

    - Условие

      Дана строка `s` в виде массива байт. Необходимо изменить входящий массив так, чтобы строка была зеркально отражена относительно середины (перевернута).

    - Кейсы

      `s = ["h","e","l","l","o"]; res = ["o","l","l","e","h"];`

      `s = ["H","a","n","n","a","h"]; res = ["h","a","n","n","a","H"];`

    - Решение 1 (оптимальное). [Два указателя](https://www.notion.so/draft-278415d3ec1246ff9b5b016795685ef8?pvs=21).
        - Визуализация

          ![two.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/two.png)


        **Сложность: время - O(n), память - O(1).**
        
        ```go
        // Два указателя.
        func reverseString(s []byte)  {
            // Левый бегунок бежит с начала.
            leftIdx := 0
            // Правый бегунок бежит с конца.
            for rightIdx := len(s) - 1; rightIdx >= leftIdx; rightIdx-- {
                // Подменяем левый элемент правым, а правый левым.
                l := s[leftIdx]
                s[leftIdx] = s[rightIdx]
                s[rightIdx] = l
                leftIdx++
            }
        }
        ```
        
    - Решение 2. Рекурсия.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        
        ```


- **Сжатие** (**compression**, RLE) строки с изменением входной строки

  [LeetCode: 443. String Compression](https://leetcode.com/problems/string-compression)

    - Условие

      Дана строка `chars` в виде массива байт. Необходимо сжать строку `chars`.

      Алгоритм сжатия: если количество повторений буквы больше 1, то за буквой ставим число повторений буквы.

      В качестве ответа нужно **изменить входящий массив** заменив левую часть сжатой формой строки. Так же нужно **вернуть количество элементов** в сжатой форме строки.

      Каждый разряд в числе повторений пишем в отдельный элемент массива.

    - Кейсы

      `chars = ["a","a","b","b","c","c","c"]; res = 6, chars = ["a","2","b","2","c","3"];`

      `chars = ["a"]; res = 1, chars = ["a"];`

      `chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]; res = 4, chars = ["a","b","1","2"];`

    - **Решение 1 (оптимальное). Итеративный подсчет повторений.**

      **Сложность: время - O(n), память - O(1).**

        ```go
        func compress(chars []byte) int {
        	// число повторений текущей буквы
        	letterCount := 0
        	// т.к. входящий массив надо пересобрать
        	// это текущий индекс (указатель) для подмены старого элемента на новый
        	newPos := 0
        	// следующая буква
        	var nextLetter byte
        	for i := 0; i < len(chars); i++ {
        		// если текущая буква последняя, то следующая дефолтная
        		nextLetter = 0
        		if i < len(chars) - 1 {
        			nextLetter = chars[i+1]
        		}
        
        		// увеличиваем счетчик повторений текущей буквы
        		letterCount++
        
        		// если текущая буква повторяется
        		if chars[i] == nextLetter {
        			continue
        		}
        		// сюда пришли потому что повторения текущей буквы прошли - надо обработать
        		// либо это последний элемент
        		// подменяем старый элемент на обрабатываемую букву
        		chars[newPos] = chars[i]
        		// смещаем новый указатель
        		newPos++
        		// если повторений нет, то не записываем число повторений
        		if letterCount > 1 {
        			// нужно записать число повторений
        			// записываем число посимвольно
        			for _, d := range strconv.Itoa(letterCount) {
        				chars[newPos] = byte(d)
        				// смещаем новый указатель
        				newPos++
        			}
        		}
        		// сбрасываем повторения буквы
        		letterCount = 0
        	}
        
        	return newPos
        }
        ```

- **Удалить звездочки** из строки, захватывая один символ слева

  [LeetCode: 2390. Removing Stars From a String](https://leetcode.com/problems/removing-stars-from-a-string)

    - Условие

      Дана строка с буквами и звездочками. Нужно удалить все звездочки из строки и вернуть строку. При удалении каждой звездочки нужно так же удалять символ слева от звездочки.

    - Кейсы

      `s = "leet**cod*e"; res = "lecoe";`

      `s = "erase*****"; res = "";`

    - **Решение 1. [Два указателя](https://www.notion.so/draft-278415d3ec1246ff9b5b016795685ef8?pvs=21).**

      Левый указатель исключает звездочки и перемещает буквы, которые стоят после звездочек.

      **Сложность: время - O(n), память - O(n).**

        ```go
        // Метод двух указателей.
        // Левый указатель исключает звездочки и перемещает буквы, которые стоят после звездочек.
        func removeStars(s string) string {
            // Результирующий массив.
            res := []byte(s)
            // Левый бегунок.
            leftIdx := 0
            // Правый бегунок.
            for rightIdx := 0; rightIdx < len(res); rightIdx++ {
                // Если текущий символ звездочка - отбрасываем левый бегунок влево.
                // Тем самым удаляя букву слева от звездочки.
                if res[rightIdx] == '*' {
                    leftIdx--
                    continue
                }
        
                // Сюда пришли, если текущий символ буква.
                // Если бегунки на разных позициях -
                // перемещаем букву, которая под правым бегунок.
                // Сдвигаем левый бегунок вправо.
                if rightIdx != leftIdx {
                    res[leftIdx] = res[rightIdx]
                }
                leftIdx++
            }
        
            // Все, что справа от левого бегунка нужно удалить.
            return string(res[:leftIdx])
        }
        ```

    - Решение 2. [Стек](https://www.notion.so/777574ca23264e6fbdd978e5d71fce17?pvs=21). TODO

      **Сложность: время - O(n), память - O(n).**

        ```go
        
        ```


- Являются ли две строки **изоморфными** (одинаковое количество повторов букв с сохранением порядка) (совпадение паттернов букв)

  [TODO: переписать заголовок и описание на более понятное]

  [LeetCode: 205. Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings)

    - Условие

      Даны две равные по длине строки `s`, `t` с ASCII символами. Необходимо проверить являются ли строки изоморфными.

    - Кейсы

      `s = "egg", t = "add"; res = true;`

      `s = "foo", t = "bar"; res = false;`

      `s = "paper", t = "title"; res = true;`

    - **Решение 1 (оптимальное). Два словаря с последними индексами букв.**
        - Сохраняем последний индекс буквы для `s` и `t`.
        - Если текущая буква есть в словарях, то индексы этой буквы должны совпадать.
        - Пример

            ```
            s1 symbol:   **a | b | a | c | a | g |**
            s1 last idx: 0 | 1 |0→2| 3 |2→4| **5** |
            s2 symbol:   **e | f | e | d | e | f |**
            s2 last idx: 0 | 1 |0→2| 3 |0→2|**1→5**|
            
            На последнем символе индексы в словарях не сходятся.
            ```


        **Сложность: время - O(n), память - O(1).**
        
        ```go
        func isIsomorphic(s string, t string) bool {
        	// Заменим нейминг для удобства.
        	s1 := s
        	s2 := t
        	// Словари символов и их последних индексов.
        	// Индекс - символ в строке,
        	// значение - последний индекс в строке, когдасимвол встречался.
        	s1SymToIdx := map[uint8]int{}
        	s2SymToIdx := map[uint8]int{}
        	for i := range s1 {
        		// Получаем индекс последнего повтора символа и флаг, встречался ли символ в строке.
        		s1PrevIdx, isS1SymExist := s1SymToIdx[s1[i]]
        		s2PrevIdx, is22SymExist := s2SymToIdx[s2[i]]
        		// Если символ встречался в s1, а в s2 нет или наоборот, то строки не изоморфны.
        		if isS1SymExist != is22SymExist {
        			return false
        		}
        		// Если символ встречался и в s1 и в s2, но последний индекс символа разный, то строки не изоморфны.
        		if isS1SymExist && s1PrevIdx != s2PrevIdx {
        			return false
        		}
        		// Можно убрать два верхних if-а:
        		// if s1SymToIdx[s[index]] != s2SymToIdx[t[index]], но нужно будет снизу обновлять i + 1.
        		// Обновляем индекс для символа.
        		s1SymToIdx[s1[i]] = i
        		s2SymToIdx[s2[i]] = i
        	}
        
        	return true
        }
        ```
        
    - Решение 2. Еще одно решение. TODO
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        
        ```

- Проверить, можно ли **составить одну строку из букв другой строки**

  [LeetCode: 383. Ransom Note](https://leetcode.com/problems/ransom-note/)

  Схожа с задачей **[Найдется** ли **анаграмма** в строке](https://leetcode.com/problems/permutation-in-string/), но здесь не нужно искать подстроку, а просто проверить буквы в любом порядке.

    - Условие

      Дана строка `ransomNote` и строка `magazine`, обе строки состоят из английских символов в нижнем регистре. Нужно вернуть флаг можно ли составить строку `ransomNote` составить из букв строки `magazine`, используя каждый символ строки только один раз.

    - Кейсы

      `ransomNote = "a", magazine = "b"; res = false;`

      `ransomNote = "aa", magazine = "ab"; res = false;`

      `ransomNote = "aa", magazine = "aab"; res = true;`

    - **Решение 1 (простое, быстрое). [Хэш-таблица](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21) с повторяемостью букв.**

      **Сложность: время - O(len(magazine)), память - O(1).**

        ```go
        // Хэш-таблица
        func canConstruct(ransomNote string, magazine string) bool {
            // Хэш-таблица для второй строки.
            // Ключ - буква, элемент - количество повторений буквы.
        		**// TODO: более оптимально использовать массив со смещением букв.**
            magMap := make(map[byte]int)
            for i := 0; i < len(magazine); i++ {
                magMap[magazine[i]]++
            }
        
            // Перебираем буквы из первой строки.
            // Находим такую букву в хэш-таблице и уменьшаем ее повторяемость.
            // Как только повторяемость какой-либо буквы будет меньше нуля,
            // такой буквы нет во второй строке - выходим.
            for i := 0; i < len(ransomNote); i++ {
                magMap[ransomNote[i]]--
                if magMap[ransomNote[i]] < 0 {
                    return false
                }
            }
        
            return true
        }
        ```

    - Решение 2 (неоптимальное). Сортировка и два стека. TODO

      **Сложность: время - O(len(magazine)*log(len(magazine))), память - O(len(magazine)).**

        ```go
        
        ```


- Удалить все смайлики из строки

  [https://leetcode.com/discuss/interview-question/3179621/](https://leetcode.com/discuss/interview-question/3179621/)

  [TODO: найти в задачниках]

    - Условие

      Дана строка `s`. Нужно удалить из строки все смайлики. Например `:-)))`, `:-((`.

      Смайлик - это строка, начинающаяся с `:-` и заканчивающаяся произвольным числом скобок `(` или `)`.

    - Кейсы

      `str = "I work in google :-)))"; res = "I work in google ";`

      `str = "Cool :-) and I failed assesment there:-(("; res = "Cool  and I failed assesment there";`

      `str = "lol:)"; res = "lol:)";`

      `str = "YEEEEE BOIIII!!!! :-))(())"; res = "YEEEEE BOIIII!!!! (())";`

      `str = "Cringe :-)))))))))))))))"; res = "Cringe";`

    - **Решение 1 (объемное, красивое). Конечный автомат для состояний смайлика.**

      **Сложность: время - O(n), память - O(n).**

        ```go
        // Конечный автомат для состояний смайлика
        func removeSmilesFromString(s string) string {
        	const (
        		start = iota
        		needNose
        		needMouth
        		moreSad
        		moreHappy
        	)
        	states := make([]map[rune]int, 5)
        	for i := 0; i < 5; i++ {
        		states[i] = make(map[rune]int)
        	}
        	// Конечный автомат. Ключ - текущее состояние, значение - мапа.
        	// Ключ мапы - текущий символ, значение - следующее доступное состояние автомата.
        	states[start][':'] = needNose
        	states[needNose]['-'] = needMouth
        	states[needMouth]['('] = moreSad
        	states[needMouth][')'] = moreHappy
        	states[moreSad]['('] = moreSad
        	states[moreHappy][')'] = moreHappy
        	// Результирующая строка (используем как стек).
        	var stringStack []rune
        	// Текущее состояние.
        	curState := start
        	for _, ch := range s {
        		// Пытаемся получить следующее состояние, если текущий символ - символ из смайлика.
        		nextState, isExist := states[curState][ch]
        		// Добавляем символ если:
        		// уже есть один или два символа из смайлика: ':', '-' (нужно вставить, т.к. после них может и не быть скобки, тогда это будет не смайлик)
        		// ЛИБО не нашли новое состояние по текущему символу, т.е. символ не из смайлика (обычный символ - нужно вставить).
        		if isExist && nextState <= needMouth || !isExist {
        			stringStack = append(stringStack, ch)
        		}
        		// Если до этого был символ '-' и нашлось новое состояние, т.е. текущий символ ')' или '(' -
        		// убираем последние два символа: ":-" (т.е. нашли смайлик - удалим его).
        		if isExist && curState == needMouth {
        			stringStack = stringStack[:len(stringStack)-2]
        		}
        		// Переопределяем новое состояние.
        		// Если новое состояние не нашлось - переопределимся на состояние start.
        		curState = nextState
        		// При состояниях moreSad и moreHappy мы просто игнорируем скобки.
        	}
        
        	return string(stringStack)
        }
        ```

    - Решение 2. Стек +перебор с условиями. TODO

      **Сложность: время - O(n), память - O(n).**

        ```go
        
        ```


## Бинарный поиск

- Полезное

  [LeetCode: Sergei Prosvirnin list: Binary search](https://leetcode.com/list/rrmazisc)


- **Угадай число** посредством **больше/меньше** (тепло/холодно)

  [LeetCode: 374. Guess Number Higher or Lower](https://leetcode.com/problems/guess-number-higher-or-lower/)

    - Условие

      Загадано число от 1 до n. Есть функция `int guess(int num) int` с помощью которой можно угадывать число. Она возвращает:

        - `-1`: `num > target`
        - `1`:  `num < target`
        - `0`:  `num == target`
    - Кейсы

      `n = 10, pick = 6; res = 6;`

      `n = 1, pick = 1; res = 1;`

      `n = 2, pick = 1; res = 1;`

    - Решение 1 (оптимальное): Бинарный поиск.

      **Сложность: время - O(log(n)), память - O(1).**

        ```go
        // Бинарный поиск.
        func guessNumber(n int) int {
            // левый ограничитель
            leftP := 0
            // правый ограничитель
            rightP := n + 1
            // расширяем границы на единицу чтобы учесть случай, когда искомое это n или 1
            // так же можно это сделать дополнительными if-ами
            for {
                // вычисляем среднее и округляем убирая десятичную часть
                curN := int((rightP + leftP) / 2)
                // проверяем искомое
                res := guess(curN)
                // нашли искомое
                if res == 0 {
                    return curN
                }
                // сужаем правую границу если искомое больше текущего среднего
                if res == -1 {
                    rightP = curN
                    continue
                }
                // сужаем левую границу если искомое меньше текущего среднего
                if res == 1 {
                    leftP = curN
                }
            }
        }
        ```


- **Поиск числа в матрице**

  [LeetCode: 74. Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix)

    - Условие

      Дана матрица `matrix` с целыми числами размером `m x n` и число `target`. Если разложить числа матрицы в массив, то числа будут отсортированы по неубыванию. Необходимо проверить, есть ли число `target` в матрице.

    - **Решение 1: Два указателя.**

      Если разложить элементы матрицы в массив, то можно применить стандартный бинарный поиск. Сложность только в том, как маппить индекс одномерного массива в двумерный индекс.

      Деление на количество столбцов - индекс строки.

      Остаток от деления на количество столбцов - индекс столбца.

      **Сложность: время - O(log(m*n)), память - O(1).**

        ```go
        func searchMatrix(matrix [][]int, target int) bool {
            // Если разложить строки в массив,
            // то можно легко использовать бинарный поиск по  массиву.
            // Останется вопрос маппинга индекса в массиве на индексы в матрице.
            // Левый бегунок по "массиву" - начинаем с начала.
            leftIdx := 0
            // Количество строк в матрице.
            rowCount := len(matrix)
            // Количество столбцов в матрице.
            colCount := len(matrix[0])
            // Правый бегунок по "массиву" - начинаем с конца.
            rightIdx := rowCount * colCount - 1
            // Пока бегунки в "массиве" не встретятся.
            for leftIdx <= rightIdx {
                // Текущий средний элемент в подмассиве leftIdx-rightIdx.
                midIdx := (leftIdx + rightIdx) / 2
                // Вычисляем позицию текущего среднего элемента в матрице.
                midRowIdx := int(midIdx / colCount)
                // В каждой строке первый элемент кратен количеству столбцов.
                // Поэтому **остаток от деления на количество столбцов** и даст **индекс столбца**.
                midColIdx := midIdx % colCount
                // Нашли искомый элемент.
                if matrix[midRowIdx][midColIdx] == target {
                    return true
                }
                // Уходим вправо.
                if matrix[midRowIdx][midColIdx] < target {
                    leftIdx = midIdx + 1
                } else {
                    // Уходим влево.
                    rightIdx = midIdx - 1
                }
            }
        
            return false
        }
        ```


## Интервалы

- Полезное

    <aside>
    💡 В общем случае, для сравнения интервалов, нужно сначала отсортировать интервалы.

    </aside>

    - Визуализация пересечения

      ![IMG_5389 (1).jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/IMG_5389_(1).jpg)


    [Medium: Leetcode is Easy! The Interval Pattern.](https://medium.com/@timpark0807/leetcode-is-easy-the-interval-pattern-d68a7c1c841)
    
    [LeetCode: Sergei Prosvirnin Lists - Intervals](https://leetcode.com/list/rp87r9mv)


### Разбить массив на интервальные последовательности

- **Разбить отсортированны**й массив **без дублей** на интервальные **последовательности**

  [LeetCode: 228. Summary Ranges](https://leetcode.com/problems/summary-ranges)

    - Условие

      Дан отсортированный массив с целыми уникальными числами. Нужно разбить массив на интервалы последовательно идущих чисел. Результирующий интервал должен представлять строку `0->2` если интервал `[0,2]`, либо строку `7`, если интервал `[7,7]`.

    - Кейсы

      `nums = [0,1,2,4,5,7]; res = ["0->2","4->5","7"];`

      `nums = [0,2,3,4,6,8,9]; res = ["0","2->4","6","8->9"];`

    - **Решение 1 (оптимальное). Перебор и сравнение.**

      Итерируемся и сравниваем текущее число с предыдущим. Если предыдущее число больше текущего как минимум на единицу, то завершаем интервал.

      **Сложность: время - O(n), память - O(1)**.

        ```go
        // Перебор и сравнение
        func summaryRanges(nums []int) []string {
            // Массив с результирующими строками
            var res []string
            // Обрабатываем кейс тут, чтобы сразу назначить startNum.
            if len(nums) == 0 {
                return res
            }
            // Начальный элемент интервала
            startNum := nums[0]
            // 0-й элемент нам не интересен.
            // Так же нам нужно обработать последний элемент, для этого выходим за рамки массива.
        		// Тут можно сравнивать текущий элемент с последующим, чтобы не выходить за рамки массива.
            for i := 1; i <= len(nums); i++ {
                // Создаем интервал.
                // Для этого либо текущий элемент должен быть началом нового интервала.
                // Либо выходим за рамки массива и обрабатываем последний интервал.
                if i == len(nums) || nums[i] - nums[i - 1] > 1 {
                    // Интервал состоит из одного числа.
                    if nums[i - 1] == startNum {
                        res = append(res, strconv.Itoa(startNum))
                    } else { // Интервал состоит из двух чисел.
                        res = append(res, strconv.Itoa(startNum)+"->"+strconv.Itoa(nums[i - 1]))
                    }
                    // Если мы не вышли за пределы массива, устанавливаем начало интервала.
                    if i < len(nums) {
                        startNum = nums[i]
                    }
                }
            }
        
            return res
        }
        ```

- **Пересечение неотсортированных** интервалов в двумерном массиве

  [LeetCode: 252. Meeting Rooms](https://leetcode.com/problems/meeting-rooms/)

    - Условие

      Есть двумерный массив с несортированными интервалами. Проверить нет ли пересечения между интервалами.

    - Кейсы

      `intervals = [[0,30],[5,10],[15,20]]; res = false;`

      `intervals = [[7,10],[2,4]]; res = true;`

    - **Решение 1 (оптимальное). Сортировка и проверка конца прошлого и начала следующего интервалов.**

      **Сложность: время - O(n*log(n)), память - O(n).** Если сортировка не требует полного копирования, то O(n*log(n)).

        ```go
        // Сортировка.
        func canAttendMeetings(intervals [][]int) bool {
            // Сортируем.
            sort.Slice(intervals, func(i, j int) bool {
                return intervals[i][0] < intervals[j][0]
            })
        
            // Если конец текущего интервала больше чем начало следующего - выходим с false.
            for i := 0; i < len(intervals); i++ {
                if i < len(intervals) - 1 && intervals[i][1] > intervals[i + 1][0] {
                    return false
                }
            }
        
            return true
        }
        ```


- **Слить** пересекающиеся интервалы в **неотсортированном** массиве

  [LeetCode: 56. Merge Intervals](https://leetcode.com/problems/merge-intervals)

    - Условие

      Дан двумерный массив `intervals` с несортированными интервалами. Необходимо слить (смержить) все пересекающиеся интервалы и вернуть массив непересекающихся интервалов.

    - Кейсы

      `intervals=[[1,4],[2,3]]; res=[[1,4]]` - интервалы могут включать друг друга.

      `intervals=[[1,4],[4,5]]; res=[[1,5]]` - если окончание прошлого и начало текущего равны, то интервалы пересекаются.

    - **Решение 1 (оптимальное). Сортировка и проверка конца прошлого и начала следующего интервалов.**

      **Сложность: время - O(n*log(n)), память - O(n)**. Если сортировка не требует полного копирования, то O(log(n)).

        ```go
        func merge(intervals [][]int) [][]int {
            // Сортируем.
            sort.Slice(intervals, func(i, j int) bool {
                return intervals[i][0] < intervals[j][0]
            })
        
            // Результирующий массив с непересекающимися интервалами.
            var res [][]int
            // Начало и конец текущего непересекающего интервала.
            start := intervals[0][0]
            end := intervals[0][1]
            for i := 1; i < len(intervals); i++ {
                // Если есть разрыв между текущим и прошлым непересекающимся интервалами.
                if end < intervals[i][0] {
                    // Добавляем в результирующий массив и начинаем новый непересекающийся интервал.
                    res = append(res, []int{start, end})
                    start = intervals[i][0]
                }
                
                // Обновим окончание непересекающегося интервала
        				// если текущий интервал не включен в прошлый непересекающийся.
                if intervals[i][1] > end {
                    end = intervals[i][1]
                }
            }
            // Обработаем последний интервал (или первый, если интервал один).
            res = append(res, []int{start, end})
        
            return res
        }
        ```

- **Слить** пересекающиеся интервалы из **двух отсортированных** массивов

  [LeetCode: 986. Interval List Intersections](https://leetcode.com/problems/interval-list-intersections/)

    - Условие

      Есть два двумерных массива с отсортированными интервалами `firstList`, `secondList`. Необходимо слить (смержить) все пересекающиеся интервалы и вернуть массив пересекающихся интервалов.

      ![interval1.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/interval1.png)

    - Кейсы
        - `firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]; res=``[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]`

          ![interval1.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/interval1%201.png)


        `firstList = [[1,3],[5,9]], secondList = []; res=[]`
        
    - **Решение 1 (оптимальное). Два указателя + сравнение границ интервалов.**
        
        Пересечение определяется когда начало интервала одного списка в пределах интервала другого списка.
        
        - Визуализация
            
            ![Все случаи пересечения](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/10d44fda-e8a1-49ed-90a5-9f5634c14093_1593003495.0978696.png)
            
            Все случаи пересечения
            
        
        **Сложность: время - O(n + m), память - O(n + m).**
        
        ```go
        // Два указателя.
        // Пересечение определяется когда начало интервала одного списка
        // в пределах интервала другого списка.
        func intervalIntersection(firstList [][]int, secondList [][]int) [][]int {
            // Бегунок в первом списке.
            firstIdx := 0
            // Бегунок во втором списке.
            secIdx := 0
            // Результирующий слайс пересекающихся интервалов.
            var res [][]int
            // Пока оба бегунка в пределах своих слайсов.
            for firstIdx < len(firstList) && secIdx < len(secondList) {
                // Индекс начала пересекающегося интервала.
                min := -1
                // Индекс конца пересекающегося интервала.
                max := -1
        
                // Начало интервала пересечения определяется когда
                // начало интервала одного списка
                // находится в пределах интервала другого списка.
                // Это условие является достаточным для определения пересечения интервалов.
        
        				// **Определим начало пересечения интервалов:**
                // Начало первого интервала в пределах второго интевала.
                if firstList[firstIdx][0] >= secondList[secIdx][0] && 
                    firstList[firstIdx][0] <= secondList[secIdx][1] {
                    min = firstList[firstIdx][0]
                }
                // Начало второго интервала в пределах первого интевала.
                if secondList[secIdx][0] >= firstList[firstIdx][0] && 
                    secondList[secIdx][0] <= firstList[firstIdx][1]{
                    min = secondList[secIdx][0]
                }
        
        				// **Определим конец пересечения интервалов:**
                // Если точно есть пересечение (определено начало интервала пересечения).
                // И конец первого интервала в границах второго интервала.
                if min != -1 && firstList[firstIdx][1] <= secondList[secIdx][1] {
                    // Определяем конец интервала как конец первого интервала.
                    max = firstList[firstIdx][1]
                    // Добавляем интервал в результирующий слайс.
                    res = append(res, []int{min, max})
                    // Переходим на другой интервал из первого списка.
                    firstIdx++
                    continue
                }
                // И конец второго интервала в границах первого интервала.
                if min != -1 && secondList[secIdx][1] < firstList[firstIdx][1] {
                    // Определяем конец интервала как конец второго интервала.
                    max = secondList[secIdx][1]
                    // Добавляем интервал в результирующий слайс.
                    res = append(res, []int{min, max})
                    // Переходим на другой интервал из второго списка.
                    secIdx++
                    continue
                }
        
                // **Если нет пересечения**, то двигаем бегунок того списка,
                // начало интервала которого меньше, чем начало интервала другого списка.
                if firstList[firstIdx][0] < secondList[secIdx][0] {
                    firstIdx++
                } else {
                    secIdx++
                }
            }
        
            return res
        }
        ```


- Сколько **интервалов содержат заданное число** (сколько **студентов** делают **домашнюю работу в определенное время**)

  [LeetCode: 1450. Number of Students Doing Homework at a Given Time](https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time/)

    - Условие

      Даны два неотсортированный массива с целыми уникальными числами `startTime` и `endTime` и число `queryTime`. Представим, что массив `startTime` это когда `i`-й студент начал делать домашнее задание. Массив `endTime` это когда `i`-й студент закончил делать домашнее задание. Вернуть количество студентов, которые делают домашнее задание в `queryTime` время. Иначе говоря когда число `queryTime` попадает в интервал `startTime[i], endTime[i]`.

    - Кейсы

      `startTime = [1,2,3], endTime = [3,2,7], queryTime = 4; res = 1;` - третий студент (`i=2`) делает домашнее задание в `queryTime`, `4` попадает в интервал `[3,7]`

      `startTime = [4], endTime = [4], queryTime = 4; res = 1;`

    - Решение 1 (оптимальное). В цикле смотрим попадает ли `queryTime` в каждый интервал.

      **Сложность: время - O(n), память - O(1)**.

        ```go
        func busyStudent(startTime []int, endTime []int, queryTime int) int {
            count := 0
            for i := 0; i < len(startTime); i++ {
                if queryTime >= startTime[i] && queryTime <= endTime[i] {
                    count++
                }
            }
        
            return count
        }
        ```


- Минимальное количество комнат для проведения встреч (максимальное дневное количество гостей в отеле) (**максимальное** количество **пересечений** интервалов)

  [LeetCode: 253. Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii)

    - Условие

      Дан неотсортированный двумерный массив `intervals` с интервалами бронирования переговорок с интервалами вида `[start, end]`. Необходимо вернуть минимальное количество переговорок. Либо, по-другому, максимальное количество пересечений интервалов.

    - Кейсы

      `intervals = [[0,30],[5,10],[15,20]]; res = 2;`

      `intervals = [[7,10],[2,4]]; res = 1;`

    - Разбор решений

      [Geeksforgeeks: Maximum number of overlapping Intervals](https://www.geeksforgeeks.org/maximum-number-of-overlapping-intervals/)

    - **Решение 1 (оптимальное, короткое). Два массива начал и концов + сортировка + сравнение.**
        - Пример 1

          `intervals = [[4,6],[1,3],[2,5],[7,12],[8,10],[9,11]]; res = 3;`

          ![IMG_5449.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/IMG_5449.jpg)

        - Пример 2

          `intervals = [[1,10],[2,7],[3,19],[8,12],[10,20],[11,30]]; res = 4;`

          ![253_Meeting_Rooms_II_Diag_3.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/253_Meeting_Rooms_II_Diag_3.png)

          ![253_Meeting_Rooms_II_Diag_4.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/253_Meeting_Rooms_II_Diag_4.png)

          ![253_Meeting_Rooms_II_Diag_5.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/253_Meeting_Rooms_II_Diag_5.png)


        **Сложность: время - O(n*log(n)), память - O(n)**.
        
        ```go
        // Time: O(nlogn)
        // Space: O(n)
        func minMeetingRooms(intervals [][]int) int {
        	// Массив начал интервалов.
        	starts := make([]int, len(intervals))
        	// Массив концов интервалов.
        	ends := make([]int, len(intervals))
        	for i := range intervals {
        		starts[i]  = intervals[i][0]
        		ends[i] = intervals[i][1]
        	}
        	// Отсортируем массивы начал и окончаний (time: O(n*log(n))).
        	sort.Ints(starts)
        	sort.Ints(ends)
        	// Индекс конца интервала.
        	endIndex := 0
        	// Необходимое количество комнат.
        	res := 0
        	// Индекс начала интервала.
        	for startIdx := range starts {
        		// Если начало текущего интервала меньше чем конец интервала из массивов концов, то надо обновить максимум.
        		if starts[startIdx] < ends[endIndex] {
        			res++
        			continue
        		}
        		// Переходим к следующему интервалу в массиве концов, если начало текущего интервала больше чем окончание интервала в массиве концов.
        		endIndex++
        	}
        
        	return res
        }
        ```
        
    - Решение 2. Приоритетные очереди. TODO.
        
        **Сложность: время - O(n*log(n)), память - O(n)**.
        
        ```go
        
        ```

- **Вставить интервал** в **массив отсортированных интервалов**

  [LeetCode: 57. Insert Interval](https://leetcode.com/problems/insert-interval/)

    - Условие

      Дан двумерный массив (массив пар интервалов) с отсортированными интервалами `intervals` и массив с одним интервалом `newInterval`. Необходимо вставить новый интервал `newInterval` в массив с интервалами `intervals`. При этом нужно сохранить сортировку и слить интервалы, если необходимо.

    - Кейсы

      `intervals = [[1,3],[6,9]], newInterval = [2,5]; res = [[1,5],[6,9]];`

      `intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]; res = [[1,2],[3,10],[12,16]];` - при вставке интервалы `[3,5],[6,7],[8,10]` сольются.

    - **Решение 1 (простое, но не самое быстрое). Итеративное формирование результирующего массива тремя блоками.**

      Разделим формирование результирующего массива с интервалами на 3 блока:
        1. Копируем интервалы до пересечения с новым интервалом.
        2. Сливаем интервалы, которые пересекаются с новым интервалом.
        3. Копируем оставшиеся интервалы после пересечения с новым интервалом.

      **Сложность: время - O(n), память - O(1).**

        ```go
        // Итеративное формирование результирующего массива тремя блоками.
        // Разделим формирование результирующего массива с интервалами на 3 блока:
        // 1. Копируем интервалы до пересечения с новым интервалом.
        // 2. Сливаем интервалы, которые пересекаются с новым интервалом.
        // 3. Копируем оставшиеся интервалы после пересечения с новым интервалом.
        func insert(intervals [][]int, newInterval []int) [][]int {
            // Результирующий массив.
            res := make([][]int, 0)
            // Общий бегунок.
            i := 0
            // Копируем интервалы до пересечения с новым интервалом
            // Конец текущего интервала должен быть меньше, чем начало нового.
            for ; i < len(intervals) && intervals[i][1] < newInterval[0]; i++ {
                res = append(res, intervals[i])
            }
            // Формируем интервал, в котором сливаем интервалы, пересекающееся с новым интервалом.
            // Начало текущего интервала должено быть не больше, чем конец нового.
            for ; i < len(intervals) && intervals[i][0] <= newInterval[1]; i++ {
                // Левая граница это минимум из начал интервалов.
                newInterval[0] = min(intervals[i][0], newInterval[0])
                // Правая граница это максимум из концов интервалов.
                newInterval[1] = max(intervals[i][1], newInterval[1])
            }
            // Добавляем слитый интервал.
            res = append(res, newInterval)
            // Копируем оставшиеся интервалы после пересечения с новым интервалом.
            for i < len(intervals) {
                res = append(res, intervals[i])
                i++
            }
            
            return res
        }
        
        func min(x, y int) int {
            if x < y {
                return x
            }
            return y
        }
        
        func max(x, y int) int {
            if x > y {
                return x
            }
            return y
        }
        ```

    - Решение 1 (объемное, быстрое). Бинарный поиск. TODO.

      **Сложность: время - O(n), память - O(1).** Бинарный поиск осуществляется за O(log(n)), но нам нужно сформировать новый массив, что займет O(n), по факту будет **чуть быстрее решения с проверкой**.

        ```go
        
        ```


## Матрицы

### Спиральная матрица

- Сформировать **квадратную спиральную матрицу** из числа

  [LeetCode: 59. Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/)

    - Условие

      Дано целое число. Необходимо сформировать спиральную матрицу с числами от 1 до n^2.

    - Кейсы
        - `n = 3; res=[[1,2,3],[8,9,4],[7,6,5]];`

          ![spiraln.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/spiraln.jpg)


        `n = 1; res=[[1]];`
        
    - Решение 1. Заполнение в зависимости от стороны в одном цикле.
        - Визуализация
            
            ![IMG_5421.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/IMG_5421.jpg)
            
        
        **Сложность: время - O(n^2), память - O(1)**.
        
        ```go
        func generateMatrix(n int) [][]int {
            // Результирующая матрица.
            mtrx := make([][]int, n, n)
            // Заполняем все элементы для обращения по индексу.
            for i := 0; i < n; i++{
                mtrx[i] = make([]int, n, n)
            }
        
            // Смещение внутрь первого и последнего элемента для стороны.
            offset := 0
            // Сторона (1 - верхняя, 2 - правая, 3 - нижняя, 4 - левая).
            sideNum := 1
            // Бегунки: строка и столбец.
            i := 0
            j := 0
            // Пока не кончатся элементы для заполнения.
            for curNum := 1; curNum <= n * n; curNum++ {
                // Заполняем верхнюю сторону.
                if sideNum == 1 {
                    // Заполняем элемент и инкрементируем столбец.
                    mtrx[i][j] = curNum
                    j++
                    // Если вышли за рамки - переходим к другой стороне.
                    if j == n - offset - 1 {
                        sideNum++
                    }
                    continue
                }
                // Заполняем правую сторону.
                if sideNum == 2 {
                    // Заполняем элемент и инкрементируем строку.
                    mtrx[i][j] = curNum
                    i++
                    // Если вышли за рамки - переходим к другой стороне.
                    if i == n - offset - 1 {
                        sideNum++
                    }
                    continue
                }
                // Заполняем нижнюю сторону.
                if sideNum == 3 {
                    // Заполняем элемент и декрементируем столбец.
                    mtrx[i][j] = curNum
                    j--
                    // Если вышли за рамки - переходим к другой стороне.
                    if j == offset {
                        sideNum++
                    }
                    continue
                }
                // Заполняем левую сторону.
                if sideNum == 4 {
                    // Заполняем элемент и декрементируем столбец.
                    mtrx[i][j] = curNum
                    i--
                    // Если вышли за рамки.
                    if i == offset {
                        // Переходим обратно к верхней стороне.
                        sideNum = 1
                        // Увеличиваем смещение внутрь.
                        offset++
                        // Сбрасываем бегунки на начало.
                        i, j = offset, offset
                    }
                    continue
                }
            }
        
            return mtrx
        }
        ```
        
    - Решение 2. Вычисление направления.
        - Составляем два массива инкрементов для строк и столбцов. Инкремент будет зависеть от направления.
        - Направление это целое число, которое инкрементируется при выходе за рамки матрицы. Используется как остаток от деления на 4 (т.к. 4 направления).
        - Так же в проверке выхода за рамки матрицы (в смене направления) нужно проверить, не заполняли ли мы уже этот элемент. Это сделать просто, т.к. элементы могут быть только больше нуля. Просто в самом начале заполним все элементы матрицы нулями.
        
        **Сложность: время - O(n^2), память - O(1)**.
        
        ```go
        func generateMatrix(n int) [][]int {
        	// Результирующая матрица.
        	res := make([][]int, n)
        	// Проинициализируем все элементы матрицы нулями.
        	for i := 0; i < n; i++ {
        		res[i] = make([]int, n)
        	}
        	// Направления:
        	// 0 - верхняя строка слева направо,
        	// 1 - правый столбец сверху вниз,
        	// 2 - нижняя строка справа налево,
        	// 3 - левый столбец снизу вверх.
        	// Инкременты для строк и столбцов в зависимости от направления.
        	// Индекс - направление, значение - инкремент.
        	rowIncrements := []int{0, 1, 0, -1}
        	colIncrements := []int{1, 0, -1, 0}
        	// Текущее направление.
        	direction := 0
        	// Текущий индекс строки.
        	rowIdx := 0
        	// Текущий индекс столбца.
        	colIdx := 0
        	for curNum := 1; curNum <= n*n; curNum++ {
        		// Добавляем текущее значение в матрицу.
        		res[rowIdx][colIdx] = curNum
        		// Вычисляем инкременты.
        		rowIncrement := rowIncrements[direction%4]
        		colIncrement := colIncrements[direction%4]
        		// Вычисляем следующие бегунки, чтобы проверить на смену направления.
        		nextRowIdx := rowIdx + rowIncrement
        		nextColIdx := colIdx + colIncrement
        		// Если мы вышли за рамки матрицы или уже заполняли элемент, то меняем направление.
        		if nextRowIdx < 0 ||
        			nextRowIdx >= n ||
        			nextColIdx < 0 ||
        			nextColIdx >= n ||
        			// Сужение происходит за счет проверки на заполнение элемента (значение элемента должно быть >1, а дефолтное значение =0).
        			res[nextRowIdx][nextColIdx] >= 1 {
        			// Меняем направление.
        			direction++
        			// Вычисляем инкременты от нового направления.
        			rowIncrement = rowIncrements[direction%4]
        			colIncrement = colIncrements[direction%4]
        		}
        		// Перемещаем бегунки в зависимости от направления.
        		rowIdx += rowIncrement
        		colIdx += colIncrement
        	}
        
        	return res
        }
        ```
        
    - Решение 3. Заполнение в зависимости от стороны в четырех циклах. TODO.
        
        **Сложность: время - O(n^2), память - O(1)**.
        
        ```go
        
        ```

- **Прочитать матрицу по спирали**

  [LeetCode: 54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix)

    - Условие

      Дана матрица `matrix` в виде двумерного массива. Вернуть массив элементов матрицы двигаясь по спирали от левого верхнего угла к центру по часовой стрелке.

    - Кейсы
        - `matrix = [[1,2,3],[4,5,6],[7,8,9]]; res = [1,2,3,6,9,8,7,4,5];`

          ![spiral1.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/spiral1.jpg)

        - `matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]; res = [1,2,3,4,8,12,11,10,9,5,6,7];`

          ![spiral.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/spiral.jpg)

    - Решение 1. Заполнение в зависимости от стороны в четырех циклах

      **Сложность: время - O(n^2), память - O(1)**.

        ```go
        
        ```

    - Решение 2. Вычисление направления. TODO.

      **Сложность: время - O(n^2), память - O(1)**.

        ```go
        
        ```


### Найти что-то в матрице по диагональному маршруту от одного угла до другого при возможных **движениях или вниз или вправо**.

- Подсчитать количество “**островов**” в **матрице**

  [LeetCode: 200. Number of Islands](https://leetcode.com/problems/number-of-islands)

    - Условие

      Дана матрица. Необходимо подсчитать количество “островов”, если считать, что область стоящих вместе `1` - это остров, а область с `0` - это вода.

      ![Красным подсвечены “острова”.](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/Screenshot_2023-07-11_at_18.39.30.png)

      Красным подсвечены “острова”.

    - Кейсы

        ```
        grid = [
          [**"1","1","1","1"**,"0"],
          [**"1","1"**,"0",**"1"**,"0"],
          [**"1","1"**,"0","0","0"],
          ["0","0","0","0","0"]
        ];
        res = 1;
        
        grid = [
          [**"1","1"**,"0","0","0"],
          [**"1","1"**,"0","0","0"],
          ["0","0",**"1"**,"0","0"],
          ["0","0","0",**"1","1"**]
        ];
        res = 3;
        ```

    - Решение 1 (оптимальное). [Поиск в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21).

      Если ячейка заполнена (`1`), то начинаем обход в глубину, считая корнем данную ячейку, т.е. считаем ее островом. При обходе в глубину помечаем все заполненные ячейки, до которых мы добрались, как незаполненные (`0`). Т.е. мы пометим все смежные заполненные ячейки данного острова как незаполненные и при следующей итерации не будем их учитывать.

      **Сложность: время - O(n*m), память - O(1)**.

        ```go
        func numIslands(grid [][]byte) int {
            // Результирующее количество островов.
            count := 0
            // Обходим все ячейки.
            for i := 0; i < len(grid); i++ {
                for j := 0; j < len(grid[i]); j++ {
                    // Если ячейка заполнена (=1), то начинаем обход в глубину,
                    // считая корнем данную ячейку, т.е. считаем ее островом.
                    // При обходе в глубину помечаем все заполненные ячейки,
                    // до которых мы добрались, как незаполненные (=0).
                    // Т.е. мы пометим все заполненные ячейки данного острова как незаполненные
                    // и при следующей итерации не будем их учитывать.
                    if grid[i][j] == '1' {
                        dfs(grid, i, j)
                        count++
                    }
                }
            }
        
            return count
        }
        
        // Обходим в глубину всех заполненных (=1) соседей ячейки.
        func dfs(grid [][]byte, i int, j int) {
            // Помечаем ячейку как незаполненную.
            grid[i][j] = '0'
            // Проверяем не выходим ли мы за рамки матрицы
            // Проверяем все соседние ячейки на заполненность, если соседняя ячейка заполнена -
            // начинаем рекурсивно обходить ее соседей.
            // Проверяем сверху.
            if j > 0 && grid[i][j - 1] == '1' {
                dfs(grid, i, j - 1)
            }
            // Проверяем слева.
            if i > 0 && grid[i - 1][j] == '1' {
                dfs(grid, i - 1, j)
            }
            // Проверяем снизу.
            if j + 1 < len(grid[i]) && grid[i][j + 1] == '1' {
                dfs(grid, i, j + 1)
            }
            // Проверяем справа.
            if i + 1 < len(grid) && grid[i + 1][j] == '1' {
                dfs(grid, i + 1, j)
            }
        }
        ```

    - Решение 2. [Поиск в ширину](https://www.notion.so/BFS-f8bbec2db02f4e988f8572172b320ee8?pvs=21). TODO.

      **Сложность: время - O(n*m), память - O(min(n, m))**.

        ```go
        
        ```

- **Повернуть матрицу по часовой стрелке**

  [TODO: написать решение самому]

  [LeetCode: 48. Rotate Image](https://leetcode.com/problems/rotate-image/)

    - Условие

      Дана квадратная матрица `matrix` в виде двумерного массива. Необходимо повернуть элементы матрицы по часовой стрелке. Элементы нужно менять местами в исходной матрице (inplace).

    - Кейсы
        - `matrix = [[1,2,3],[4,5,6],[7,8,9]]; res = [[7,4,1],[8,5,2],[9,6,3]];`

          ![mat1.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/mat1.jpg)

        - `matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]; res = [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]];`

          ![mat2.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/mat2.jpg)

    - Решение 1. Меняем столбцы со строками (транспонирование), затем зеркально меняем столбцы относительно вертикали.
        - Визуализация


            Изначальная матрица
            
            | 1 | 2 | 3 |
            | --- | --- | --- |
            | 4 | 5 | 6 |
            | 7 | 8 | 9 |
            
            Транспонированная матрица
            
            | 1 | 4 | 7 |
            | --- | --- | --- |
            | 2 | 5 | 8 |
            | 3 | 6 | 9 |
            
            Отзеркаленные столбцы
            
            | 7 | 4 | 1 |
            | --- | --- | --- |
            | 8 | 5 | 2 |
            | 9 | 6 | 3 |
            
        
        **Сложность: время - O(n^2), память - O(1)**.
        
        ```go
        // Меняем столбцы со строками, затем зеркально меняем столбцы относительно вертикали.
        func rotate(matrix [][]int) {
        	// Транспонирование матрицы.
        	// Столбцы становятся строками.
        	for row := 0; row < len(matrix); row++ {
        		for col := row; col < len(matrix[0]); col++ {
        			// Меняем два элемента местами атомарно.
        			matrix[row][col], matrix[col][row] = matrix[col][row], matrix[row][col]
        		}
        	}
        
        	// Меняем столбцы зеркально относительно вертикали.
        	// Первый столбец становится последним.
        	// Для этого в каждой строке меняем местами последние элементы двигаясь от краев к центру.
        	// Максималь
        	maxCol := len(matrix[0])
        	for row := 0; row < len(matrix); row++ {
        		// Бежим по строке от крайних столбцов к центру.
        		// Левый бегунок в строке.
        		for leftCol := 0; leftCol < maxCol/2; leftCol++ {
        			// Правый бегунок в строке.
        			rightCol := maxCol - leftCol - 1
        			// Меняем два элемента местами атомарно.
        			matrix[row][leftCol], matrix[row][rightCol] = matrix[row][rightCol], matrix[row][leftCol]
        		}
        	}
        }
        ```
        
    - Решение 2. Замена по четыре элемента. TODO.
        
        **Сложность: время - O(n^2), память - O(1)**.
        
        ```go
        
        ```


## Математика

### Прямоугольная система координат на плоскости

- Просчитать возможность **возврата** в **начало маршрута**, если один **маршрут** можно запускать в **бесконечном цикле** (про **робота**)

  [LeetCode: 1041. Robot Bounded In Circle](https://leetcode.com/problems/robot-bounded-in-circle/description/)

    - Условие

      Робот стоит лицом вверх в начале координат.

      На входе набор инструкций:

      `G` - двигаться на единицу вперед,

      `L` - повернуть против часовой стрелки на 90 градусов,

      `R` - повернуть по часовой стрелке на 90 градусов.

      Проверить, вернется ли когда-нибудь робот в начало маршрута с учетом циклического запуска инструкций бесконечное количество раз.

    - О чем речь

      Задача про [аттрактор](https://www.notion.so/6b5375240b8d462885dd4914edc2192a?pvs=21). Т.е. у нас есть траектория и нужно понять, стремится ли эта траектория к какой-то точке при бесконечном времени.

      Доказано что, если за 4 цикла робот не вернулся в начало координат, его траектория точно не циклична.

    - Решение 1. Проход по инструкциям 4 раза.

      Доказано что, если за 4 цикла робот не вернулся в начало координат, его траектория точно не циклична.

        - Визуализация

          ![pic6.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/pic6.png)

          ![pic6.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/pic6%201.png)


        ```go
        // Запускаем цикл 4 раза и смотрим вернется ли робот после любого цикла в начало координат.
        func isRobotBounded(instructions string) bool {
            // Словарь направлений с изменениями для каждого направления.
            // Используется как закольцованный массив.
            var directions [4][]int
            directions[0] = []int{0,1} // север (вверх)
            directions[1] = []int{1,0} // восток (влево)
            directions[2] = []int{0,-1} // юг (вниз)
            directions[3] = []int{-1,0} // запад (вправо)
            // Текущие координаты робота.
            x := 0
            y := 0
            // Индекс направления для словаря направлений.
            directionIdx := 0
            // Доказано, что если в течение 4 циклов робот не пришел в начало координат, то он траектория точно не циклическая.
            for cycle := 0; cycle < 4; cycle++ {
                // Разбираем инструкции.
                for _, instr := range instructions {
                    // Если против часовой, то поднимаемся на 1 элемент.
                    // Остаток от деления гарантирует закольцованность.
                    if instr == 'L' {
                        directionIdx = (directionIdx + 1) % 4
                    }
                    // Если против часовой, то поднимаемся на 3 элемента.
                    // Остаток от деления гарантирует закольцованность.
                    if instr == 'R' {
                        directionIdx = (directionIdx + 3) % 4
                    }
                    // Делаем шаг - изменяем координаты на текущие значения направления из словаря.
                    if instr == 'G' {
                        x += directions[directionIdx][0]
                        y += directions[directionIdx][1]
                    }
                }
                // Цикл закончен - вернулись в начало координат?
                if  x == 0 && y == 0 {
                    return true
                }
            }
        
            return false
        }
        ```
        
    - Решение 2 (оптимальный). Проход по инструкциям 1 раз. TODO.

- Вернемся ли мы в **начало маршрута** после его **окончания** (про **робота**)

  [LeetCode: 657. Robot Return to Origin](https://leetcode.com/problems/robot-return-to-origin)

    - Условие

      Робот стоит в начале координат.

      На входе набор инструкций: `'R'` - двигаться вправо на 1 клетку, `'L'` - влево, `'U'` - вверх, `'D'` - вниз.

      Проверить, вернется ли робот в начало маршрута.

    - Кейсы

      `moves = "UD"; res = true;`

      `moves = "LL"; res = false;`

    - Решение 1. Проходим по инструкциям и перезаписываем текущие координаты.

        ```go
        // Симуляция движений робота и расчет x,y точек.
        func judgeCircle(moves string) bool {
            // Если нечетное количество инструкций, то мы точно не попадем в начало.
            if len(moves) % 2 == 1 {
                return false
            }
            //  Проходим по инструкциям и перезаписываем текущие координаты.
            var x, y int
            for _, move := range moves {
                if move == 'L' {
                    x--
                } 
                if move == 'R' {
                    x++
                } 
                if move == 'U' {
                    y++
                }
                if move == 'D' {
                    y--
                }
            }
            return x == 0 && y == 0
        }
        ```


- **Симметричность** точек относительно **прямой**

  [LeetCode: 356. Line Reflection](https://leetcode.com/problems/line-reflection/)

    - Условие

      Дан массив точек `points`, найти есть ли такая вертикальная прямая, которая делит все точки вне прямой на симметричное множество.

      Могут быть дублирующееся точки.

    - Кейсы
        - `points = [[1,1],[-1,1]]; res = true;`

          ![356_example_1.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/356_example_1.png)

        - `points = [[1,1],[-1,-1]]; res = false;`

          ![356_example_2.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/356_example_2.png)

    - **Решение 1 (оптимальное). Хэш-таблица.**
        - Проходимся по точкам первый раз:
            - находим максимум и минимум точек по x;
            - составляем хэш-таблицу всех точек;
        - Находим вертикальную прямую как середину между минимальной и максимальной точкой по x. Учесть, что середина может быть дробным, т.е. преобразуем к `float`.
        - Для каждой точки ищем зеркальное отражение в хэш-таблице, если не нашли выходим с `false`.

      **Сложность: время - O(n), память - O(n).**

        ```go
        // Хэш-таблица
        func isReflected(points [][]int) bool {
            // Минимальное значение по X для всех точек.
            minX := points[0][0]
            // Максимальное значение по X для всех точек.
            maxX := points[0][0]
            // Хэш-таблица: ключ - точка, значение - пустая структура.
            pointsMap := make(map[[2]int]struct{})
            // Заполняем хэш-таблицу, вычисляем минимальное и максимальное значение X.
            for _, p := range points {
                pointsMap[[2]int{p[0],p[1]}] = struct{}{}
                if p[0] < minX {
                    minX = p[0]
                }
                if p[0] > maxX {
                    maxX = p[0]
                }
            }
        
            // На основе мин и макс X вычисляем ось симметрии
            // (параллельную ось Y, относительно которой все точки будут зеркальны)
            mid := (float64(maxX) + float64(minX)) / 2
        
            // Учитываем, что несколько одинаковых точек могут отражаться в одну точку.
            // Т.е. нам не нужно сопоставлять каждую пару точек
            // и не нужно считать количество одинаковых точек.
            // Для каждой точки из хэш-таблицы находим зеркальную точку,
            // если ее нет завершаемся.
            for p, _ := range pointsMap {
                // Искомая точка. Нам нужно вычислить X искомой точки, Y остается такой же.
                searchP := [2]int{int(2 * mid) - p[0], p[1]}
                // Если нет - выходим.
                if _, ok := pointsMap[searchP]; !ok {
                    return false
                }
            }
        
            return true
        }
        ```


### Random

- **Генерация рандомного** числа на основе **существующей функции рандомизации** для меньшего числа

  [LeetCode: 470. Implement Rand10() Using Rand7()](https://leetcode.com/problems/implement-rand10-using-rand7)

    - Условие

      Дана функция `rand7()` генерации рандомного числа в рамках `[1,7]`. Нужно написать функцию `rand10()`, которая будет использовать функцию rand7() и вернет рандомное число в диапазоне `[1,10]`.

    - Решение 1. [Выборка с отклонением](https://www.notion.so/draft-65606c6e34af4dfc9d50b623e81d91d9?pvs=21).

      Нам нужно с равной вероятностью выбирать числа. Если составить матрицу 7x7 (т.к. нам доступен `rand7()`) и заполнить матрицу числами от 1 до 49, то можно придумать формулу, по которой будет вычисляться элемент этой матрицы на основе двух вызовов `rand7()` (вызов для строки, вызов для столбца). Если из этой матрицы убрать последние 9 цифр, то мы получим равновероятностное распределение от 1 до 40. Если взять остаток от деления этого числа на 10, то получим равновероятностный `rand10()`.

      Последние 9 цифр нам не подойдут, т.к. мы на них не можем гарантировать равную вероятность. Поэтому, если выпадет число 41-49 нужно будет повторять операцию пока не получим число 1-40.

      Осталось только разобраться с формулой. Формула будет `7*(row-1)+col`.

        - Визуализация

          ![IMG_5432.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/IMG_5432.jpg)

          ![rejectionSamplingTable.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/rejectionSamplingTable.png)


        **Сложность: время - O(1)-O(∞), память - O(1)**
        
        ```go
        func rand10() int {
            idx := 41
            for idx > 40 {
                row := rand7()
                col := rand7()
                idx = 7 * (row - 1) + col
            }
        
            return (idx % 10) + 1
        }
        ```


- Реализовать работу с **множеством** для операций **insert, remove, getRandom**

  [LeetCode: 380. Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1)

    - Условие

      Реализовать следующие методы:

        - `RandomizedSet()` - конструктор.
        - `bool insert(int val)` - вставка числа `val` в множество. Вернуть флаг было ли такое число в множестве.
        - `bool remove(int val)` - удаление числа `val` из множества. Вернуть флаг было ли такое число в множестве.
        - `int getRandom()` - получение рандомного числа из множества. Каждый элемент множества должен иметь одинаковую вероятность на получение. **Можно использовать встроенные функции рандомизации**.

      Каждый метод должен в среднем занимать время O(1).

    - Кейсы

      `operations = ["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"],
      parameters = [[], [1], [2], [2], [], [1], [2], []];
      res = [null, true, false, true, 2, true, false, 2];`

    - **Решение 1 (оптимальное). [Хэш-таблица](https://www.notion.so/481a6a7110324437bc85675cd2323930?pvs=21) + множество (массив).**

      TODO: описать

      **Сложность: время - O(1), память - O(n).**

        - Визуализация

          Хранение:

          ![structure2.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/structure2.png)

          Вставка:

          ![isert.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/isert.png)

          Удаление:

          ![delete.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/delete.png)


        ```go
        type RandomizedSet struct {
            // Хэш-таблица (мапа) для быстрого доступа к вставке и удалению.
            // Ключ - элемент, значение - индекс в множестве s
            m map[int]int
            // Множество (слайс) для быстрого доступа к рандомному числу.
            // Индекс - значение элемента в мапе.
            s []int
        }
        
        func Constructor() RandomizedSet {
            return RandomizedSet{m: make(map[int]int)}
        }
        
        func (this *RandomizedSet) Insert(val int) bool {
            // Если элемент уже есть - выходим
            if _, isExist := this.m[val]; isExist {
                return false
            }
        
            // Вставляем элемент в хэш-таблицу и множество.
            this.m[val] = len(this.s)
            this.s = append(this.s, val)
        
            return true
        }
        
        func (this *RandomizedSet) Remove(val int) bool {
            // Если элемента нет - выходим.
            // Получаем из мапы индекс в множестве.
            sIdx, isExist := this.m[val]
            if !isExist {
                return false
            }
        
            // Перемещаем на место найденного в множестве элемента элемент с конца,
            // чтобы слайс не разрастался. Если элемент последний - операция бессмысленна.
            this.s[sIdx] = this.s[len(this.s) - 1]
            // Сужаем слайс.
            this.s = this.s[:len(this.s) - 1]
            // Удаляем элемент из мапы.
            delete(this.m, val)
            if sIdx < len(this.s) {
                // Меняем в мапе индекс переехавшего в множестве элемента. 
                this.m[this.s[sIdx]] = sIdx
            }
        
            return true
        }
        
        func (this *RandomizedSet) GetRandom() int {
            // Достаем рандомный индекс из множества и получаем по этому индексу элемент.
            //rand.Seed(time.Now().UnixNano())
            randIdx := rand.Intn(len(this.s))
        
            return this.s[randIdx]
        }
        
        /**
         * Your RandomizedSet object will be instantiated and called as such:
         * obj := Constructor();
         * param_1 := obj.Insert(val);
         * param_2 := obj.Remove(val);
         * param_3 := obj.GetRandom();
         */
        ```


### Примитивные математические операции (сложение, умножение)

- **Умножить два** числа представленных в виде **строк**

  [LeetCode: 43. Multiply Strings](https://leetcode.com/problems/multiply-strings/)

    - Условие

      Даны два числа представленные в строковом формате. Необходимо вернуть произведение этих чисел в строковом формате.

    - Кейсы

      `num1 = "2"; num2 = "3"; res = "6";`

      `num1 = "123"; num2 = "456"; res = "56088";`

    - Решение 1. Перемножение столбиком.
        - Перемножаем поразрядно формируя инвертированный массив чисел для каждого разряда.
        - Инвертируем массив в прямой порядок чисел и переносим десятки.

      **Сложность: время - O(m*(m+n)), память - O(n+m)**

        - Визуализация

          ![Slide4.jpeg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/Slide4.jpeg)


        ```go
        // Перемножаем столбиком.
        func multiply(num1 string, num2 string) string {
            // Инвертированный результат перемножения с возможным лидирующим нулем: 356x459=4043610.
            // Количество цифр в произведении может быть:
            // len(num1) + len(num2) либо len(num1) + len(num2) - 1
            // Для удобства обращения по индексу заложим максимальную длину.
            productInvert := make([]int, len(num1) + len(num2))
            // Сначала итерируемся по второму числу (с конца в начало строки).
            for i := len(num2) - 1; i >= 0; i-- {
                // Вычисляем цифру второго числа.
                digit1 := byteToDigit(num2[i])
                // "Два пишем, один в уме" - цифра, переходящая в старший разряд (переходящие десятки).
                highDigit := 0
                // Особенность цикла в go, j после цикла будет len(num1),
                // а нам как раз нужно добавить число в старший разряд.
                j := len(num1) - 1
                for ; j >= 0; j--  {
                    // Вычисляем цифру первого числа.
                    digit2 := byteToDigit(num1[j])
                    // Произведение цифр первого и второго чисел (может быть больше 10).
                    // Добавляем переходящие десятки с предыдущего разряда.
                    productNum := (digit1 * digit2) + highDigit
                    // Обнуляем переходящие десятки.
                    highDigit = 0
                    // Вычисляем текущую цифру
                    curDigit := productNum % 10
                    // Если текущее произведение больше девятки, то заносим десятки
                    // для следующего разряда.
                    if productNum >= 10 {
                        highDigit = (productNum - curDigit) / 10
                    }
                    // Записываем текущую цифру в инвертированный результат.
                    // Здесь текущая цифра может быть больше 9, т.к. она складывается
                    // с цифрой из прошлой итерации.
                    //         3 2 0 4
                    //       1 7 8 0 0
                    //     1 4 2 4 0 0
                    // = 1 5 12 14 0 4
                    // Десятки перенесем в нижнем цикле.
                    productInvert[len(num2) - i + len(num1) - j - 2] += curDigit
                }
                // Записываем оставшиеся переходящие десятки в инвертированный результат.
                productInvert[len(num2) - i + len(num1) - j - 2] += highDigit
            }
        
            // Для 356x459 получим инвертированный массив [4 0 14 12 5 1].
            // Для 123x456 получим инвертированный массив [8 8 10 15 4 0].
            // Теперь нам нужно из инвертированного массива цифр получить неинвертированный.
            // Так же нужно перенести десятки.
            // TODO: можно не делать инвертирование и учитывать переходящие десятки на лету
            // в первом цикле.
        
            // Цифра, переходящая в старший разряд (переходящие десятки).
            highDigit := 0
            // Количество лидирующих нулей, которые нужно будет убрать (0|1).
            leadingZeroCount := len(num1) + len(num2) - 1
            // Результирующий массив цифр.
            res := make([]byte, len(productInvert))
            for i := 0; i < len(productInvert); i++ {
                // Вычисляем текущую цифру с учетом переходящих десятков.
                sum := productInvert[i] + highDigit
                // Обнуляем переходящие десятки для следующей итерации.
                highDigit = 0
                // Текущая цифра без переходящих десятков (до 9).
                curDigit := sum % 10
                // Вычисляем переходящие десятки.
                if sum >= 10 {
                    highDigit = (sum - curDigit) / 10
                }
                // Добавляем цифру в результирующий массив.
                res[len(productInvert) - 1 - i] = digitToByte(curDigit)
                // Вычисляем количество лидирующих нулей.
                // Например, тут 123x456 = [8 8 10 15 4 0] нужно убрать один ноль.
                if curDigit > 0 {
                    leadingZeroCount = len(productInvert) - 1 - i
                }
            }
        
            return string(res[leadingZeroCount:])
        }
        
        func byteToDigit(char byte) int {
        	return int(char) - 48
        }
        
        func digitToByte(digit int) byte {
        	return byte(digit) + 48
        }
        ```
        
    - Решение 2 (оптимальное). Перемножение всех пар чисел. **TODO.**
        
        **Сложность: время - O(m*n), память - O(n+m)**
        
        - Визуализация
            
            ![Slide32.jpeg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/Slide32.jpeg)
            
        
        ```go
        
        ```


- **Сложить два** числа представленных в виде **строк**

  [LeetCode: 415. Add Strings](https://leetcode.com/problems/add-strings)

    - Условие

      Даны два числа `num1`, `num2` представленные в строковом формате. Необходимо вернуть сумму этих чисел в строковом формате.

    - Кейсы

      `num1 = "11", num2 = "123"; res = "134";`

      `num1 = "456", num2 = "77"; res = "533";`

      `num1 = "0", num2 = "0"; res = "0";`

    - **Решение 1 (оптимальное). Сложение столбиком.**

      Перемножаем поразрядно формируя массив поразрядной суммы.

      **Сложность: время - O(max(len(n),len(m)), память - O(max(len(n),len(m)).**

        ```go
        func addStrings(num1 string, num2 string) string {
            // Максимальная разрядность из двух чисел.
            maxLength := len(num1)
            if len(num2) > maxLength {
                maxLength = len(num2)
            }
            // Результирующий массив байт.
            // Добавляем один доп элемент на случай последнего переходящего десятка (9+9=18).
            res := make([]byte, maxLength + 1)
            // Переходящий десяток (9+9=18).
            transfer := 0
            // Сумма двух цифр, определяем тут, чтобы убрать лидирующий ноль.
            sum := 0
            // Бежим по байтам в обоих строках (по разрядам в числах) до максимального разряда.
            for i := 0; i <= maxLength; i++ {
                // Цифра из первого числа.
                n1 := 0
                // Цифра из второго числа.
                n2 := 0
                // Проверки на выход за рамки массивов.
                if i < len(num1) {
                    n1 = byteToDigit(num1[len(num1) - i - 1])  
                } 
                if i < len(num2) {
                    n2 = byteToDigit(num2[len(num2) - i - 1])
                }   
                // Сумма двух цифр с учетом переходящего десятка.
                sum = n1 + n2 + transfer
                // Высчитываем переходящий десяток с учетом округления.
                // Если число меньше 10, то будет 0, иначе 1.
                transfer = sum / 10
                // Записываем в результирующий массив сумму цифр (убирая переходящий десяток).
                res[len(res) - i - 1] = digitToByte(sum % 10)
            }
            // Обработка последнего переходящего десятка (9+9=18).
            // Если переходящего десятка нет - убираем лидирующий ноль.
            if sum == 0 {
                res = res[1:]
            }
            
            return string(res)
        }
        
        // Перевод символа в число.
        func byteToDigit(char byte) int {
        	return int(char) - '0'
        }
        // Перевод числоа в символ.
        func digitToByte(digit int) byte {
        	return byte(digit) + '0'
        }
        ```

- **Прибавить** к числу в виде **массива** **единицу**

  [TODO: решить более просто]

  [LeetCode: 66. Plus One](https://leetcode.com/problems/plus-one)

    - Условие

      Дан целочисленный массив представляющий из себя число (каждый элемент массива это одна цифра ≤9) с разрядами в прямом порядке (слева направо). Необходимо прибавить к числу единицу и вернуть массив-число.

    - Кейсы

      `digits = [1,2,3]; res = [1,2,4];`

      `digits = [4,3,2,1]; res = [4,3,2,2];`

      `digits = [999]; res = [1,0,0,0];`

    - Решение 1 (объемное). Складываем столбиком с переносом десятка.

      **Сложность: время - O(n), память - O(n).**

        ```go
        // Складываем столбиком.
        func plusOne(digits []int) []int {
            isTransfer := false
            for i := len(digits) - 1; i >= 0; i-- {
                if i == len(digits) - 1 || isTransfer {
                    digits[i]++
                    isTransfer = false
                } else {
                    break
                }
                if digits[i] == 10 {
                    isTransfer = true
                    digits[i] = 0
                }
            }
        
            if isTransfer {
                res := make([]int, 0, len(digits))
                res = append(res, 1)
                res = append(res, digits...)
                return res
            }
        
            return digits
        }
        ```


### Преобразования числа

- Конвертация **арабского** числа в **римское** число

  [LeetCode: 12. Integer to Roman](https://leetcode.com/problems/integer-to-roman)

    - Условие

      Дано целое число (арабское) не больше 3999. Нужно конвертировать число в римское.

      | Римская цифра | Арабская цифра |
              | --- | --- |
      | I | 1 |
      | V | 5 |
      | X | 10 |
      | L | 50 |
      | C | 100 |
      | D | 500 |
      | M | 1000 |
    - Кейсы

      `num = 3; res = "III"`

      `num = 58; res = "LVIII"` - `L = 50, V = 5, III = 3`

      `num = 1994; res = "MCMXCIV"` - `M = 1000, CM = 900, XC = 90 and IV = 4`

    - Решение 1 (сложное). Парсим по цифрам с конца.

      **Сложность: время - O(n), память - O(1).**

        ```go
        func intToRoman(num int) string {
            // Маппинг разряда к римским цифрам (на один разряд 2 римская цифры).
            digitsMap := [...]byte{'I', 'V', 'X', 'L', 'C', 'D', 'M'}
            // Число в строковом виде, эту строку будем парсить по цифрам.
            strNum := strconv.Itoa(num)
            // Инвертированный массив,
            // где каждый элемент это римская цифра представление цифры в разряде
            var digitsStrInverted [][]byte
            // Бегунок в маппинге digitsMap
            digitsMapIdx := 0
            // Бежим от малого разряда к большому (с конца строки к началу).
            for i := len(strNum) - 1; i >= 0; i-- {
                // Получаем цифру для текущего разряда.
                digit, _ := strconv.Atoi(string(strNum[i]))
                // Массив байт для текущей римской цифры.
                var digitStr []byte
        
                // Формируем римскую цифру в зависимости от арабской.
                // Ноль никак не интерпритируется в римскую цифру.
                if digit > 0 && digit < 4 {
                    repeat(&digitStr, digitsMap[digitsMapIdx], digit) // II
                }
                if digit == 4 {
                    digitStr = append(digitStr, digitsMap[digitsMapIdx]) // I
                    digitStr = append(digitStr, digitsMap[digitsMapIdx + 1]) // V
                }
                if digit >= 5 && digit < 9 {
                    digitStr = append(digitStr, digitsMap[digitsMapIdx + 1]) // V
                    if digit > 5 {
                        repeat(&digitStr, digitsMap[digitsMapIdx], (digit - 5)) // II
                    }
                }
                if digit == 9 {
                    digitStr = append(digitStr, digitsMap[digitsMapIdx]) // I
                    digitStr = append(digitStr, digitsMap[digitsMapIdx + 2]) // X
                }
                // Прыгаем через 2 элемента, т.к. второй элемент для пятерки.
                digitsMapIdx += 2
        
                // Добавляем сформированную римскую цифру в инвертированный результирующий массив.
                digitsStrInverted = append(digitsStrInverted, digitStr)
            }
        
            // Инвертируем римские цифры по обычному порядку.
            var digitsStr []byte
            for i := len(digitsStrInverted) - 1; i >= 0; i-- {
                digitsStr = append(digitsStr, digitsStrInverted[i]...)
            }
        
            return string(digitsStr)
        }
        
        // Ф-я для повторения римского символа в римской цифре, например, III
        func repeat(digitStr *[]byte, symbol byte, count int) {
            for i := 0; i < count; i++ {
                *digitStr = append(*digitStr, symbol)
            }
        }
        ```

    - Решение 2 (простое, большой маппинг). Маппинг каждого разряда + поразрядное деление.
        - Визуализация маппинга

          ![digit_roman_numeral_values.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/digit_roman_numeral_values.png)

        - Поразрядное деление

            ```go
            thousands_digit = num / 1000
            hundreds_digit = (num % 1000) / 100
            tens_digit = (num % 100) / 10
            ones_digit = num % 10
            ```


        **Сложность: время - O(1), память - O(1).**
        
        ```go
        // Поразрядный маппинг.
        func intToRoman(num int) string {
            // Поразрядный маппинг.
            thousands := [...]string{"", "M", "MM", "MMM"}
            hundreds := [...]string{"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"}
            tens := [...]string{"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"}
            ones := [...]string{"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"}
        
            // Маппим каждый разряд.
            // Например, число 1994.
            return thousands[num / 1000] + // thousands[1] = M
                hundreds[(num % 1000) / 100] + // hundreds[9] = CM
                tens[(num % 100) / 10] + // tens[9] = XC
                ones[(num % 10)] // ones[4] = IV
        }
        ```
        
    - Решение 3 (простое, маленький маппинг). Маппинг диапазонов.
        
        **Сложность: время - O(1), память - O(1).**
        
        ```go
        // Маппинг диапазонов.
        func intToRoman(num int) string {
            // Диапазоны маппятся между собой.
            // Маппинг диапазонов арабских чисел.
            arabicNums := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}
            // Маппинг диапазонов римских чисел.
            romanNums := []string{"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"}
        
            // Результат - римское число.
            var res strings.Builder
            // Возьмем, например, число 58.
            // Итерируемся по диапазонам.
            for i, arabicNum := range arabicNums {
                // Если входящее число больше чем текущее, то мы в нужном диапазоне.
                // Чтобы поддержать дублирование римских цифр (III), сделаем дублирующий цикл.
                // 1. 58 > 50 = "L"
                // 2. 58 - 50 > 5 = "V"
                // 3. 58 - 50 - 5 > 1 = "I"
                // 4. 58 - 50 - 5 - 1 > 1 = "I"
                // 5. 58 - 50 - 5 - 1 - 1 > 1 = "I"
                for num >= arabicNum {
                    // Можно подставить аналогичное римское число из диапазона.
                    res.WriteString(romanNums[i])
                    // Уменьшаем входящее число.
                    num -= arabicNum
                }
            }
        
            return res.String()
        }
        ```

- Развернуть (**отзеркалить**) **число**

  [LeetCode: 7. Reverse Integer](https://leetcode.com/problems/reverse-integer/)

    - Условие

      Дано целое 32-bit число `x`. Необходимо его развернуть поразрядно.

      Если развернутое число выйдет за пределы `[-231, 231 - 1]`, тогда вернуть `0`.

    - Кейсы

      `x = 123; res = 321;`

      `x = -123; res = -321;`

      `x = 120; res = 21;` - нужно убрать лидирующий ноль

    - Решение 1. Итерируемся по цифре в числе, начиная с конца, используем для этого остаток от деления на 10.

      **Сложность: время - O(n), память - O(1), где n - количество разрядов числа `x`.**

        ```go
        func reverse(x int) int {
            res := 0
            digit := 10 // разрядный делитель
            // если число отрицательное, то не меняем основной алгоритм в цикле
            // а переводим сначала в положительное, а результат в отрицательное
            isNegative := false
            if x < 0 {
                x = -x
                isNegative = true
            }
            for {
                if x < digit / 10 {
                    // разрядный делитель больше нашего числа - выходим
                    break
                }
                // остатком от деления отсекаем ненужные старшие разряды
                // а делением оставляем только цифру в разряде
                num := x % digit / (digit / 10)
                // умножаем, чтобы увеличить разряд на десяток и прибавляем разрядную цифру
                res = res * 10 + num
                // кейс для максимального результирующего числа
                if res > math.MaxInt32 {
                    return 0
                }
                // увеличиваем разряд (переходим к следующей цифре в числе)
                digit *= 10
            }
            // переводим результирующее число в отрицательное
            if isNegative == true {
                res = -res
            }
        
            return res
        }
        ```

- Конвертация **римского числа** в **арабское**

  [LeetCode: 13. Roman to Integer](https://leetcode.com/problems/roman-to-integer)

    - Условие

      Дано римское число не больше 3999. Нужно конвертировать число в арабское.

        ```
        Symbol        Value
        I             1
        V             5
        X             10
        L             50
        C             100
        D             500
        M             1000
        ```

    - Кейсы

      `s = "III"; res = 3;`

      `s = "LVIII"; res = 58;` - `L = 50, V= 5, III = 3`;

      `s = "MCMXCIV"; res = 1994;` - `M = 1000, CM = 900, XC = 90 and IV = 4`;

    - Решение 1 (простое). Маппинг + суммирование арабских цифр (справа налево).

      **Сложность: время - O(1), память - O(1).**

        ```go
        // Маппинг + суммирование арабских цифр.
        func romanToInt(s string) int {
            // Результирующее число.
            num := 0
            // Предыдущая вычисленная арабская цифра.
            prevDigit := 0
            // Маппинг римской цифры на арабскую.
            mapping := map[byte]int {
                'I': 1,
                'V': 5,
                'X': 10,
                'L': 50,
                'C': 100,
                'D': 500,
                'M': 1000,
            }
            // Идем в обратном порядке от меньшего разряда к большему (с конца строки в начало).
            // Просто суммируем арабские цифры.
            // Т.е. XVII - это сумма 1 + 1 + 5 + 10 = 17.
            // Единственный кейс в том, что цифры подобные IV нужно наоборот вычитать.
            // Т.е. запоминаем предыдущую арабскую цифру и вычитаем ее, если она меньше текущей.
            // Например, IX - это разность 10 - 1 = 9.
            for i := len(s) - 1; i >= 0; i-- {
                // Если текущая цифра не меньше предыдущей - суммируем.
                if mapping[s[i]] >= prevDigit {
                    num += mapping[s[i]]
                } else { // Если текущая цифра меньше предыдущей - вычитаем.
                    num -= mapping[s[i]]
                }
        
                // Переопределяем предыдущую цифру.
                prevDigit = mapping[s[i]]
            }
        
            return num
        }
        ```


- Вычислить результат математического выражения по **обратной польской нотации**

  [LeetCode: 150. Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation)

    - Условие

      Дано математическое выражение записанное с помощи [обратной польской записи](https://www.notion.so/draft-d719675ca2df497dadd9d0b5261c37b1?pvs=21). Вычислить результат математического выражения.

    - Кейсы

      `tokens = ["2","1","+","3","*"]; res = 9;` - [инфиксная запись](https://www.notion.so/af9c92f7433c4094ba07d4a84a0453f3?pvs=21): `((2 + 1) * 3) = 9`

      `tokens = ["4","13","5","/","+"]; res = 6;` - инфиксная запись: `(4 + (13 / 5)) = 6`

        - `tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]; res = 22;`

            ```
            ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
            = ((10 * (6 / (12 * -11))) + 17) + 5
            = ((10 * (6 / -132)) + 17) + 5
            = ((10 * 0) + 17) + 5
            = (0 + 17) + 5
            = 17 + 5
            = 22
            ```

    - Решение 1. Стэк + выбор операции по условию.

      **Сложность: время - O(n), память - O(n).**

        - Простой вариант

            ```go
            func evalRPN(tokens []string) int {
            	s := make([]int, 0, len(tokens))
            	for _, v := range tokens {
            		n := len(s) - 1
            		switch v {
            		case "+":
            			s = append(s[:n-1], s[n-1]+s[n])
            		case "-":
            			s = append(s[:n-1], s[n-1]-s[n])
            		case "*":
            			s = append(s[:n-1], s[n-1]*s[n])
            		case "/":
            			s = append(s[:n-1], s[n-1]/s[n])
            		default:
            			i, _ := strconv.Atoi(v)
            			s = append(s, i)
            		}
            	}
            	return s[len(s)-1]
            }
            ```


        ```go
        func evalRPN(tokens []string) int {
            // Стэк для чисел. Т.е. на операции мы останавливаемся и ее обрабатываем,
            // а число отправляем в стэк.
            var numStack []int
            for _, t := range tokens {
                // Пробуем получить число.
        				// Кажется, Atoi долгая операция, и можно определять оператор по операции.
                num, err := strconv.Atoi(t)
                // Если текущий токен - число, то добавляем в стэк и итерируемся.
                if err == nil {
                    numStack = append(numStack, num)
                    continue
                }
                // Если текущий токен - операция.
                // Достаем два числа из стэка над которыми нужно совершить операцию.
                num2 := numStack[len(numStack)-1]
                num1 := numStack[len(numStack)-2]
                // Это результат операции над парой чисел.
                res := 0
        
                // Применяем к паре чисел операцию.
                if t == "+" {
                    res = num1 + num2
                }
                if t == "-" {
                    res = num1 - num2
                }
                if t == "*" {
                    res = num1 * num2
                }
                if t == "/" {
                    res = num1 / num2
                }
        
                // Записываем в стэк результирующее число,
                // чтобы потом это число участвовало в следующей операции (с последующим числом).
                numStack[len(numStack)-2] = res
                // Мы забрали из стэка два числа, а положили одно - уменбшим стэк.
                numStack = numStack[:len(numStack)-1]
            }
        
            return numStack[len(numStack)-1]
        }
        ```
        
    - Решение 2. Стэк + выбор операции из мапы функций. TODO.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        type fn func(int, int) int
        m := map[string]fn{
        	"+": func(a int, b int) int { return a + b },
        	"-": func(a int, b int) int { return a - b },
        	"*": func(a int, b int) int { return a * b },
        	"/": func(a int, b int) int { return a / b },
        }
        ```


- Подсчитать **количество единиц** в **двоичном формате** десятичного числа.

  [LeetCode: 191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits)

    - Условие

      Дано десятичное положительное число. Подсчитать количество единиц в двоичном представлении этого числа.

    - Кейсы

      `num = 11 (00000000000000000000000000001011); res = 3;`

      `num = 128 (00000000000000000000000010000000); res = 1;`

      `num = 4294967293 (11111111111111111111111111111101); res = 32;`

    - Решение 1: Побитовый подсчет.

      Сложность: Время - O(1), память O(1).

        ```go
        func hammingWeight(num uint32) int {
            // Счетчик единичек.
            count := 0
            // Сдвигаем на 1 бит вправо пока число не будет равно нулю.
            for num > 0 {
                // Если правый бит равен 1, то инкрементируем счетчик.
                if num & 1 == 1 {
                    count++
                }
                // Сдвигаем вправо на один бит.
                num >>= 1
            }
        
            return count
        }
        ```

- **Минимальная стоимость подъема по лестнице** с учетом оплаты на каждой ступеньке

  [LeetCode: 746. Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs)

    - Условие

      Дан целочисленный массив `cost`. Индекс - номер ступеньки, значение - стоимость подъема на эту ступеньку. Подниматься можно либо на одну ступеньку, либо сразу на две. Найти минимально возможную стоимость подъема по лестнице с учетом множества вариантов подъема.

      Можно начать как с первой ступеньки (`cost[0]`), так и со второй (`cost[1]`).

    - Кейсы
        - `cost = [10,**15**,20]; res = 15;`

          ![746_1.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/746_1.png)


        `cost = [**1**,100,**1**,**1**,**1**,100,**1**,**1**,100,**1**]; res = 6;`
        
    - **Решение 1. [Динамическое программирование](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21) - поднимаемся вверх, учитывая прошлые две ступеньки.**
        
        Сумма, которую мальчик отдаст на N-ой ступеньке, есть сумма, которую он отдал до этого плюс стоимость самой ступеньки. «Сумма, которую он отдал до этого» зависит от того, с какой ступеньки мальчик шагает на N-ую — с (N-1)-й или с (N-2)-й. Выбирать нужно наименьшую.
        
        **Сложность: время - O(n), память - O(1).**
        
        ```go
        // Очевидно, что сумма, которую мальчик отдаст на N-ой ступеньке, есть сумма,
        // которую он отдал до этого плюс стоимость самой ступеньки.
        // «Сумма, которую он отдал до этого» зависит от того, с какой ступеньки мальчик шагает на N-ую —
        // с (N-1)-й или с (N-2)-й. Выбирать нужно наименьшую.
        func minCostClimbingStairs(cost []int) int {
        		// Начинаем со второй ступеньки беря минимальную суммы с прошлых двух ступенек.
            count := len(cost) - 1
            for i := 2; i <= count; i++ {
                cost[i] += int(math.Min(float64(cost[i-1]), float64(cost[i-2])))
            }
            return int(math.Min(float64(cost[count]), float64(cost[count - 1])))
        }
        ```
        
    - Решение 2. [Динамическое программирование](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21) - табуляция. TODO.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        
        ```
        
    - Решение 3. [Динамическое программирование](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21) - рекурсия + мемоизация. TODO.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        
        ```

- **Заполнить треугольник Паскаля** до `n`-го уровня

  [LeetCode: 118. Pascal's Triangle](https://leetcode.com/problems/pascals-triangle)

    - Условие

      Дано целочисленное положительное `numRows`. Необходимо сформировать треугольник Раскаля до уровня `numRows` и вернуть двумерный массив его элементов по уровням.

      ![mohit-pascals-triangle-04-1622524807.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/mohit-pascals-triangle-04-1622524807.png)

    - Кейсы

      `numRows = 5; res = [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]];`

      `numRows = 1; res = [[1]];`

    - **Решение 1. [Динамическое программирование](https://www.notion.so/75004f85740a4a6cb99b6a8a7d741039?pvs=21) - заполняем по уровням.**

      **Сложность: время - O(numRows^2), память - O(1).**

        ```go
        // Заполняем по уровням. 
        func generate(numRows int) [][]int {
            // Результирующий массив.
            res := make([][]int, numRows)
            // Добавляем вершину.
            res[0] = append(res[0], 1)
            // Идем со второй строки. rowIdx - индекс строки, начинается с нуля.
            for rowIdx := 1; rowIdx < numRows; rowIdx++ {
                // Получаем предыдущую строку.
                prevRow := res[rowIdx - 1]
                // Создаем текущуюю строку.
                curRow := make([]int, rowIdx + 1)
                // Заполняем единичками края строки.
                curRow[0] = 1
                curRow[rowIdx] = 1
                // Бегунки с краев к центру, крайние элементы уже заполнили.
                leftIdxCurRow := 1
                rightIdxCurRow := len(curRow) - 2
                // Пока бегунки не встретятся.
                for leftIdxCurRow <= rightIdxCurRow {
                    // Вычисляем элемент как сумму двух верхних элементов.
                    el := prevRow[leftIdxCurRow - 1] + prevRow[leftIdxCurRow]
                    curRow[leftIdxCurRow] = el
                    curRow[rightIdxCurRow] = el
                    // Сдвигаем бегунки.
                    leftIdxCurRow++
                    rightIdxCurRow--
                }
                res[rowIdx] = curRow
            }
        
            return res
        }
        ```


## Нули и единички

### Найти **максимальную последовательность единичек**

- Найти **максимальную последовательность единичек**

  [LeetCode: 485. Max Consecutive Ones](https://leetcode.com/problems/max-consecutive-ones)

    - Условие

      Дан массив нулей и единиц `nums`. Необходимо найти максимальную последовательность единичек в массиве и вернуть длину этой последовательности.

    - Кейсы

      `nums = [1,1,0,1,1,1]; res = 3;`

      `nums = [1,0,1,1,0,1]; res = 2;`

    - **Решение 1 (оптимальное). Счетчик.**
        - Итерируемся по массиву.
        - Если встречаем `0`, сбрасываем счетчик, если встречаем 1, то инкрементируем счетчик.
        - Визуализация

          ![485_Max_Consecutive_Ones_1.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/485_Max_Consecutive_Ones_1.png)


        **Сложность: время - O(n), память - O(1)**
        
        ```go
        func findMaxConsecutiveOnes(nums []int) int {
        		// Результирующий счетчик единичек.
            resCount := 0
        		// Счетчик единичек текущей последовательности.
            curCount := 0
            for _, n := range nums {
                // Если элемент =0, то при умножении 0 обнулим текущий счетчик.
                // Если элемент =1, то инкрементируем текущий счетчик (умножение на 1 ничего не изменит).
        				// Можно заменить это на обычный if-чик для простоты понимания.
                curCount = (curCount + 1) * n
                // Если текущий счетчик больше результирующего, то переопределим результат
                if curCount > resCount {
                    resCount = curCount
                }
            }
        
            return resCount
        }
        ```


- Найти **максимальную последовательность единичек**, если можно **заменить `k` нулей единицами**

  [LeetCode: 1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/)

    - Условие

      Дан массив нулей и единиц `nums`. Необходимо найти максимальную последовательность единичек в массиве и вернуть длину этой последовательности с учетом того, что можно заменить `k` нулей единицами.

    - Кейсы

      `nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2; res = 6;` - `[1,1,1,0,0,**1**,1,1,1,1,**1**]`

      `nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3; res = 10;` - `[0,0,1,1,**1**,**1**,1,1,1,**1**,1,1,0,0,0,1,1,1,1]`

    - Дополнительное условие. TODO.

      What if the input numbers come in one by one as an infinite stream? In other words, you can't store all numbers coming from the stream as it's too large to hold in memory. Could you solve it efficiently?

    - **Решение 1 (оптимальное). [Скользящее окно](https://www.notion.so/Sliding-window-draft-e553bdf67d21409eafa60b0b2030fea4?pvs=21).**

      Максимально раздвигаем окно на единицах с учетом запасных `k` единиц. Т.к. мы не сужаем окно, то в течение всего прохода мы получим максимальное окно.

      **Сложность: время - O(n), память - O(1)**

        ```go
        // Скользящее окно.
        func longestOnes(nums []int, k int) int {
            // k - запас для единиц
            // позиции начала и конца окна
            start, end := 0, 0
            for end < len(nums) {
                // если текущий элемент 0, то расходуем k
                if nums[end] == 0 {
                    k--
                }
                // если k закончились
                if k < 0 {
                    // если в начале окна ноль, то наполняем k
                    if nums[start] == 0 {
                        k++
                    }
                    // смещаем начало окна, т.к. мы израсходовали все запасные единицы
                    start++
                }
                // смещаем конец окна
                end++
            }
        
            // в итоге смысл в том, что мы максимально раздвигаем окно на единицах с учетом запасных единиц
            // т.к. мы не сужаем окно, то в течение всего прохода мы получим максимальное окно
            return end - start
        }
        ```


- Найти **максимальную последовательность единичек**, если можно **удалить одно число**

  [LeetCode: 1493. Longest Subarray of 1's After Deleting One Element](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/)

    - Условие

      Дан массив нулей и единиц `nums`. Необходимо найти максимальную последовательность единичек в массиве и вернуть длину этой последовательности с учетом того, что нужно удалить одно любое число.

    - Кейсы

      `nums = [1,1,0,1]; res = 3;` - `[1,1,**0**,1]`

      `nums = [0,1,1,1,0,1,1,0,1]; res = 5;` - `[0,1,1,1,**0**,1,1,0,1]`

      `nums = [1,1,1]; res = 2;` - нужно удалить один элемент`[1,1,**1**]`

    - **Решение 1 (оптимальное). [Скользящее окно](https://www.notion.so/Sliding-window-draft-e553bdf67d21409eafa60b0b2030fea4?pvs=21) и счетчики.**
        - Визуализация

          ![1493A.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/1493A.png)

        - Итеративно формируем скользящее окно.
        - Если ноликов в скользящем окне меньше двух:
            - Увеличиваем счетчик нулей, если под правым бегунком нуль
            - Увеличиваем счетчик единиц, если под правым бегунком единица
        - Если ноликов в скользящем окне больше 1:
            - Уменьшаем счетчики в зависимости от числа под левым бегуноком.
            - Увеличиваем левый бегунок.

      **Сложность: время - O(n), память - O(1)**

        ```go
        // Скользящее окно и счетчики.
        func longestSubarray(nums []int) int {
            // Счетчик нулей.
            zeroCount := 0
            // Счетчик единиц.
            onesCount := 0
            // Максимальный счетчик единиц.
            maxOnesCount := 0
            // Левый бегунок.
            leftIdx := 0
            // Правый бегунок.
            rightIdx := 0
            // Пока правый бегунок в рамках массива и левый бегунок не перегнал правый.
            for rightIdx < len(nums) && leftIdx <= rightIdx {
                // Ноликов в окне не больше лимита - можно считать единицы.
                if zeroCount <= 1 {
                    // Увеличиваем счетчики единиц.
                    if nums[rightIdx] == 1 {
                        onesCount++
                    }
                    // Увеличиваем максимальный счетчик
                    if onesCount > maxOnesCount {
                        maxOnesCount = onesCount + zeroCount - 1
                    }
                    // Увеличиваем счетчики нулей.
                    // Обязатльно после увеличения максимального иначе нулей может быть два.
                    if nums[rightIdx] == 0 {
                        zeroCount++
                    }
                    // Смещаем правый бегунок.
                    rightIdx++
                } else { // Ноликов больше лимита - двигаем бегунок слева.
                    // Уменьшаем счетчики в зависимости от числа под левым бегуноком.
                    if nums[leftIdx] == 0 {
                        zeroCount--
                    } else {
                        onesCount--
                    }
                    leftIdx++
                }
            }
        
            return maxOnesCount
        }
        ```


- Найти **максимальную последовательность единичек**, если можно **заменить один ноль единицей**

  [LeetCode: 487. Max Consecutive Ones II](https://leetcode.com/problems/max-consecutive-ones-ii/)

    - Условие

      Дан массив нулей и единиц `nums`. Необходимо найти максимальную последовательность единичек в массиве и вернуть длину этой последовательности с учетом того, что можно заменить один ноль единицей.

    - Кейсы

      `nums = [1,0,1,1,0]; res = 4;` - заменим первый ноль на единицу `[1,1,1,1,0]`

      `nums = [1,0,1,1,0,1]; res = 4;` - заменим первый ноль на единицу `[1,1,1,1,0,1]`

    - Дополнительное условие. TODO.

      What if the input numbers come in one by one as an infinite stream? In other words, you can't store all numbers coming from the stream as it's too large to hold in memory. Could you solve it efficiently?

    - **Решение 1 (оптимальное). [Скользящее окно](https://www.notion.so/Sliding-window-draft-e553bdf67d21409eafa60b0b2030fea4?pvs=21).**

      **Сложность: время - O(n), память - O(1)**

        ```go
        // Скользящее окно.
        func findMaxConsecutiveOnes(nums []int) int {
            // Счетчик нулей.
            zeroCount := 0
            // Максимальный (результирующий) счетчик единиц.
            onesMaxCount := 0
            // Левый бегунок.
            leftIdx := 0
            // Правый бегунок.
            rightIdx := 0
            // Пока не дойдем до конца правым бегунком.
            for rightIdx < len(nums) {
                // Количество нулей не больше одного - двигаем правый бегунок.
                if zeroCount <= 1 {
                    // Инкрементируем счетчик нулей.
                    if nums[rightIdx] == 0 {
                        zeroCount++
                    }
                    rightIdx++
                }
        
                // Количество нулей больше одного - двигаем левый бегунок.
                if zeroCount > 1 {
                    // Декрементируем счетчик нулей.
                    if nums[leftIdx] == 0 {
                        zeroCount--
                    }
        
                    leftIdx++
                }
        
                // Количество единиц - размер окна.
                count := rightIdx - leftIdx
                // Если есть один нолик, то он считается за единицу, счетчик никак не изментся.
                if zeroCount <= 1 && count > onesMaxCount {
                    // Увеличиваем результирующий счетчик единиц.
                    onesMaxCount = count
                }
            }
        
            return onesMaxCount
        }
        ```


- Находятся ли **единички** на **расстоянии не менее k** нулей друг от друга

  [LeetCode: 1437. Check If All 1's Are at Least Length K Places Away](https://leetcode.com/problems/check-if-all-1s-are-at-least-length-k-places-away)

    - Условие

      Дан массив нулей и единиц `nums` и целое `k`. Необходимо проверить, что между каждой парой единичек находятся не менее `k` нулей.

    - Кейсы
        - `nums = [1,0,0,0,1,0,0,1], k = 2; res = true;`

          ![sample_1_1791.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/sample_1_1791.png)

        - `nums = [1,0,0,1,0,1], k = 2; res = false;`

          ![sample_2_1791.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/sample_2_1791.png)

    - **Решение 1 (оптимальное). Перебор со проверкой индекса предыдущей единички.**

      **Сложность: время - O(n), память - O(1)**

        ```go
        func kLengthApart(nums []int, k int) bool {
            // Индекс предыдущей единички.
            // Установим его на достаточное расстояние для проверки первой единички.
            lastOnesIdx := -k - 1
            for i, num := range nums {
                // Если текущая цифра нолик, то пропускаем.
                if num == 0 {
                    continue
                }
                // Проверяем расстояние от текущей единички до предыдущей.
                if i - lastOnesIdx <= k {
                    return false
                }
                lastOnesIdx = i
            }
        
            return true
        }
        ```

    - Решение 2 (объемное). Битовые манипуляции. TODO.

      **Сложность: время - O(n), память - O(1)**

        ```go
        
        ```


- Найти **максимальную дистанцию** до ближайших **соседей** в ряду (**максимальная дистанция до единичек**)

  [LeetCode: 849. Maximize Distance to Closest Person](https://leetcode.com/problems/maximize-distance-to-closest-person)

    - Условие

      Дан массив нулей и единиц `seats`. Необходимо найти максимальную последовательность нулей и вернуть равноудаленную дистанцию до ближайших единичек.

      ![distance.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/distance.jpg)

    - Кейсы

      `seats = [1,0,**0**,0,1,0,1]; res = 2;`

      `seats = [1,0,0,**0**]; res = 3;`

      `seats = [**0**,1]; res = 1;`

      `seats = [**0**,0,1,0,**0**,0,0,1,0,**0**,0,1,0]; res = 2;` - здесь несколько равнозначных мест. Индексы 0, 4, 9.

    - Решение 1. Простой перебор с вычислением дистанции.

      В цикле вычисляем:

        - максимальное количество `0`
        - если нули в конце или начале - количество нулей и будет дистанцией
        - иначе дистанцией будет половина от количества нулей

      **Сложность: время - O(n), память - O(1)**

        ```go
        // Вычисляем максимальное количество подряд идущих пустых сидейний.
        func maxDistToClosest(seats []int) int {
            // Максимальная дистанция (результат).
            maxDistance := 0
            // Текущая дистанция (текущее количество подряд идущих пустых сидений).
            curDistance := 0
            // Текущая дистанция включает первое или последнее пустое место.
            isExtreme := false
            // Выходим за рамки массива, чтобы обработать последнюю дистанцию,
            // если последнее место пустое.
            for i := 0; i <= len(seats); i++ {
                // Если последнее место пустое или текущее место занято - обработаем дистанцию.
                if (i == len(seats) || seats[i] == 1) && curDistance > 0 {
                    // Если первое или последнее место пустое,
                    // нужно считать все пустые места в качестве дистанции.
                    // Иначе нужно считаем место по центру в качестве дистанции.
                    if isExtreme == false {
                        curDistance = int(math.Ceil(float64(curDistance) / float64(2)))
                    }
                    // Заменяем максимальную дистанцию, если необходимо.
                    if curDistance > maxDistance {
                        maxDistance = curDistance
                    }
                    // Сбросим текущую дистанцию (кол-во подряд идущих пустых мест).
                    curDistance = 0
                    // Сбросим флаг первого или последнего пустого места.
                    isExtreme = false
                    continue
                }
                // Если место пустое и мы в рамках массива.
                if i < len(seats) && seats[i] == 0 {
                    // Увеличим дистанцию.
                    curDistance++
                    // Установим флаг для наличия первого или последнего пустого места в дистанции.
                    if i == 0 || i == len(seats) - 1 {
                        isExtreme = true
                    }
                }
            }  
        
            return maxDistance  
        }
        ```


## Деревья (trees)

- Полезное
    - Визуализация порядка обхода узлов дерева

      ![145_transverse.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/145_transverse.png)


### Бинарное (двоичное) дерево

### Обход бинарного дерева

- Обход **бинарного** дерева в **зигзаг** порядке по **уровням**

  [LeetCode: 103. Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal)

    - Условие

      Дано [бинарное дерево](https://www.notion.so/325fbdebbd614bf8b78bcf91892c74b5?pvs=21) в виде [связного списка](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21). Необходимо обойти его по уровням каждый раз меняя порядок обхода (зигзагом: уровень слева направо, следующий уровень справо налево). Вернуть двумерный массив значений узлов во время обхода.

      ![103_BFS.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/103_BFS.png)

    - Кейсы
        - `root = [3,9,20,null,null,15,7]; res = [[3],[20,9],[15,7]];`

          ![tree1 (1).jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/tree1_(1).jpg)


        `root = [1]; res = [[1]];`
        
        `root = []; res = [];`
        
    - Решение 1 (сложное). [Обход в ширину](https://www.notion.so/BFS-f8bbec2db02f4e988f8572172b320ee8?pvs=21), слайсы для каждого уровня.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // Поиск в ширину (BFS) + слайсы для уровней.
        func zigzagLevelOrder(root *TreeNode) [][]int {
            // Результирующий слайс.
            var res [][]int
            // Направление: в какую сторону добавлять значения узлов
            // (слева направо или справа налево).
            isLeftFirst := true
            // Узлы на текущем уровне которые обходим.
            var curNodes []*TreeNode
            // Кейс: дерево пустое.
            if root != nil {
                curNodes = append(curNodes, root)
            }
            // Количество узлов на текущем уровне (для удобства).
            nodesCount := len(curNodes)
            // Пока есть узлы.
            for nodesCount > 0 {
                // Слайс для значений узлов на текущем уровне.
                levelVals := make([]int, nodesCount)
                // Слайс для узлов следующего уровня (будем обходить в следующей итерации).
                var nextNodes []*TreeNode
                // Обходим узлы на текущем уровне.
                for i := 0; i < nodesCount; i++ {
                    // Текущий узел (для удобства).
                    node := curNodes[i]
                    // Добавляем дочерние узлы следующего уровня для следующего обхода.
                    if node.Left != nil {
                        nextNodes = append(nextNodes, node.Left)
                    }
                    if node.Right != nil {
                        nextNodes = append(nextNodes, node.Right)
                    }
                    // В зависимости от направления
                    // добавляем значения узлов с начала или с конца.
                    if isLeftFirst {
                        levelVals[i] = node.Val
                    } else {
                        levelVals[nodesCount - i - 1] = node.Val
                    }
                }
                // Добавляем в результирующий слайс значения узлов на текущем уровне.
                res = append(res, levelVals)
                // Будем обрабатывать узлы со следующего уровня.
                curNodes = nextNodes
                // Количество узлов на следующем уровне.
                nodesCount = len(curNodes)
                // Инверсия направления.
                isLeftFirst = !isLeftFirst
            }
        
            return res
        }
        
        /**
         * Definition for a binary tree node.
         * type TreeNode struct {
         *     Val int
         *     Left *TreeNode
         *     Right *TreeNode
         * }
         */
        ```
        
    - Решение 2 (простое). [Обход в ширину](https://www.notion.so/BFS-f8bbec2db02f4e988f8572172b320ee8?pvs=21), общая очередь. TODO.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        
        ```
        
    - Решение 3 (простое). [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) через рекурсию. TODO.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        
        ```


- **Обойти бинарное дерево по уровням** слева направо

  [LeetCode: 102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)

    - Условие

      Дано [бинарное дерево](https://www.notion.so/325fbdebbd614bf8b78bcf91892c74b5?pvs=21) в виде [связного списка](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21). Необходимо обойти дерево в ширину по уровням слева направо и вернуть двумерный массив узлов на каждом уровне.

    - Кейсы
        - `root = [3,9,20,null,null,15,7]; res = [[3],[9,20],[15,7]];`

          ![tree1.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/tree1.jpg)


        `root = [1]; res = [[1]];`
        
        `root = []; res = [];`
        
    - Решение 1. [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) через рекурсию.
        - Обходим в глубину слева направо
        - Пробрасываем уровень и результирующий массив в рекурсию
        - Добавляем узел в результирующий массив для текущего уровня.
        - Визуализация
            
            ![145_transverse (2).png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/145_transverse_(2).png)
            
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // Рекурсия для обхода в глубину.
        // Обходим в глубину слева направо
        // Пробрасываем уровень и результирующий массив в рекурсию
        // Добавляем узел в результирующий массив для текущего уровня.
        func levelOrder(root *TreeNode) [][]int {
            // Результирующий массивс заполнением по уровням.
            var res [][]int
            dfs(root, &res, 0)
            return res
        }
        
        func dfs(node *TreeNode, res *[][]int, level int){
            // Дошли до листа
            if node == nil {
                return
            }
            // Если еще не заполняли текущий уровень - добавляем новый пустой уровень в массив.
            if len(*res) == level {
                *res = append(*res, []int{})
            }
            // Добавляем текущий узел в результирующий массив.
            (*res)[level] = append((*res)[level], node.Val)
            // Заполняем сначала левое, потом правое поддерево рекурсивно.
            dfs(node.Left, res, level + 1)
            dfs(node.Right, res, level + 1)
        }
        
        type TreeNode struct {
        		Val int
        		Left *TreeNode
        		Right *TreeNode
        }
        ```
        
    - Решение 2. Итеративно [обходим в ширину](https://www.notion.so/BFS-f8bbec2db02f4e988f8572172b320ee8?pvs=21) с помощью слайса для очереди.
        - Визуализация
            
            ![145_transverse (1).png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/145_transverse_(1).png)
            
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // Итеративно обходим в ширину с слайса для очереди. 
        func levelOrder(root *TreeNode) [][]int {
            // Результирующий массив с заполнением по уровням.
            var res [][]int
            // Отдельно обрабатываем пустое дерево.
            if root == nil {
                return res
            }
            // Очередь для обработки узлов.
            queue := []*TreeNode{root}
            // Цикл для обработки по уровням.
            for len(queue) > 0 {
                levelCount := len(queue)
                // Массив для значений узлов текущего уровня.
                levelVals := make([]int, 0, levelCount)
                // Обрабатываем узлы текущего уровня.
                for i := 0; i < levelCount; i++ {
                    node := queue[i]
                    // Добавляем дочерние узлы в слайс следующего уровня.
                    if node.Left != nil {
                        queue = append(queue, node.Left)
                    }
                    if node.Right != nil {
                        queue = append(queue, node.Right)
                    }
                    levelVals = append(levelVals, node.Val)
                }
                queue = queue[levelCount:]
                // Добавляем значения узлов на текущем уровне в результирующий массив.
                res = append(res, levelVals)
            }
        
            return res
        }
        
        type TreeNode struct {
        		Val int
        		Left *TreeNode
        		Right *TreeNode
        }
        ```
        
    - Решение 3. Итеративно [обходим в ширину](https://www.notion.so/BFS-f8bbec2db02f4e988f8572172b320ee8?pvs=21) с помощью [container/list](https://www.notion.so/container-list-draft-e0ddecc1fff94001b1cff3ea1dab5d31?pvs=21) для очереди.
        - Визуализация
            
            ![145_transverse (1).png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/145_transverse_(1).png)
            
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // Итеративно обходим в ширину с помощью container/list в качестве очереди. 
        func levelOrder(root *TreeNode) [][]int {
            // Результирующий массив с заполнением по уровням.
            var res [][]int
            // Отдельно обрабатываем пустое дерево.
            if root == nil {
                return res
            }
            // Очередь для обработки узлов.
            queue := list.New()
            queue.PushBack(root)
            // Цикл для обработки по уровням.
            for queue.Len() > 0 {
                levelCount := queue.Len()
                // Массив для значений узлов текущего уровня.
                levelVals := make([]int, 0, levelCount)
                // Обрабатываем узлы текущего уровня.
                for i := 0; i < levelCount; i++ {
                    // Элемент очереди (обертка над узлом).
                    elem := queue.Front()
                    // Получаем узел.
                    node := elem.Value.(*TreeNode)
                    // Удаляем элемент из очереди.
                    queue.Remove(elem)
                    // Добавляем дочерние узлы в слайс следующего уровня.
                    if node.Left != nil {
                        queue.PushBack(node.Left)
                    }
                    if node.Right != nil {
                        queue.PushBack(node.Right)
                    }
                    levelVals = append(levelVals, node.Val)
                }
                // Добавляем значения узлов на текущем уровне в результирующий массив.
                res = append(res, levelVals)
            }
        
            return res
        }
        
        type TreeNode struct {
        		Val int
        		Left *TreeNode
        		Right *TreeNode
        }
        ```

- Обход **бинарного** дерева в глубину inorder (left→current→right)

  [LeetCode: 94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal)

    - Условие

      Дано [бинарное дерево](https://www.notion.so/325fbdebbd614bf8b78bcf91892c74b5?pvs=21) в виде [связного списка](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21). Необходимо обойти его в глубину inorder. Сначала левое поддерево, потом текущий узел, потом правое поддерево.

    - Кейсы
        - `root = [1,null,2,3]; res =` `[1,3,2];`

          ![inorder_1.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/inorder_1.jpg)


        `root = [1]; res = [1];`
        
        `root = []; res = [];`
        
    - Решение 1 (простое). [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) через стек (используя слайс).
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        func inorderTraversal(root *TreeNode) []int {
            //return traversal(root)
            var res []int
            traversalSimple(root, &res)
            return res
        }
        
        // Обход через рекурсию.
        func traversal(node *TreeNode) []int {
            // Результирующий массив.
            var res []int
            // Дошли до листа.
            if node == nil {
                return res
            }
            // Если левый потомок не пуст идем в левое поддерево.
            if node.Left != nil {
                res = traversal(node.Left)
            }
            // Добавляем текущий узел после того, как обошли все левое поддерво.
            res = append(res, node.Val)
            // Если левый потомок не пуст идем в правое поддерево.
            if node.Right != nil {
                res = append(res, traversal(node.Right)...)
            }
        
            return res
        }
        
        // Упрощенный обход через рекурсию.
        func traversalSimple(node *TreeNode, res *[]int) {
            // Дошли до листа.
            if node == nil {
                return
            }
            // Идем в левое поддерево.
            traversalSimple(node.Left, res)
            // Добавляем текущий узел после того, как обошли все левое поддерво.
            *res = append(*res, node.Val)
            // Идем в правое поддерево.
            traversalSimple(node.Right, res)
        }
        
        /**
         * Definition for a binary tree node.
         * type TreeNode struct {
         *     Val int
         *     Left *TreeNode
         *     Right *TreeNode
         * }
         */
        ```
        
    - Решение 2 (простое). [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) через рекурсию.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // Обход в глубину inorder через стек.
        func inorderTraversal(root *TreeNode) []int {
            // Стек.
        	var stack []*TreeNode
            // Результирующий массив с узлами.
        	var res []int
            // Текущий узел.
        	node := root
            // Пока не дошли до листа или пока стек не пуст.
        	for node != nil || len(stack) > 0 {
                // Идем в глубину налево до листа.
        		for node != nil {
                    // Добавляем левого потомка на стек.
        			stack = append(stack, node) // push
        			node = node.Left
        		}
                // Берем со стека узел и уменьшаем стек.
        	    stack, node = stack[:len(stack)-1], stack[len(stack)-1] // pop
                // Добавляем в результирующий массив узел со стека.
        		res = append(res, node.Val)
                // Переходим к правому узлу.
        		node = node.Right
        	}
        
        	return res
        }
        
        type TreeNode struct {
            Val int
            Left *TreeNode
            Right *TreeNode
        }
        ```

- Проверка **идентичности бинарных** деревьев

  [LeetCode: 100. Same Tree](https://leetcode.com/problems/same-tree)

    - Условие

      Даны два [бинарных дерева](https://www.notion.so/325fbdebbd614bf8b78bcf91892c74b5?pvs=21) в виде [связных списков](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21). Необходимо проверить являются ли деревья идентичными. Т.е. должна совпадать структура и значения всех элементов.

    - Кейсы
        - `p = [1,2,3]; q = [1,2,3]; res = true;`

          ![ex1.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/ex1.jpg)

        - `p = [1,2]; q = [1,null,2]; res = false;`

          ![ex2.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/ex2.jpg)

        - `p = [1,2,1]; q = [1,1,2]; res = false;`

          ![ex3.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/ex3.jpg)

    - Решение 1 (сложное). [Обход в ширину](https://www.notion.so/BFS-f8bbec2db02f4e988f8572172b320ee8?pvs=21). [Очередь](https://www.notion.so/b7a57ab8681249f0942ed81fb62d9910?pvs=21) для складывания узлов для последующей обработки.

      Обходим по уровням и сравниваем элементы по уровням.

      **Сложность: время - O(n), память - O(n).**

        ```go
        func isSameTree(p *TreeNode, q *TreeNode) bool {
            // Очереди. Складываем в конец дочерние узлы для обработки.
            // Берем из начала узел для текущей обработки.
            // Лучше использовать связный список вместо слайсов. Слайсы будут разрастаться.
            pQueue := []*TreeNode{p}
            qQueue := []*TreeNode{q}
            // Указатель на индекс в очереди.
            queueIdx := -1
            for {
                // Если очереди не равны, значит в одном дереве больше узлов, чем в другом.
                if len(pQueue) != len(qQueue) {
                    return false
                }
                // Заканчиваем цикл, если очередь закончилась.
                if queueIdx == len(pQueue) - 1 {
                    break
                }
                // Текущие узлы для обработки.
                queueIdx++
                curP := pQueue[queueIdx]
                curQ := qQueue[queueIdx]
                // Оба узла нулевые (листы) - пропускаем.
                if curP == nil && curQ == nil {
                    continue
                }
                // Оба узла заполнены.
                if curP != nil && curQ != nil {
                    // Сравниваем значения в узлах.
                    if curP.Val != curQ.Val {
                        return false
                    }
                    // Добавляем дочерние узлы в очереди.
                    pQueue = append(pQueue, curP.Left, curP.Right)
                    qQueue = append(qQueue, curQ.Left, curQ.Right)
                    continue
                }
        
                // Сюда придем когда в одном дереве узел нулевой, в другом заполненный.
                return false
            }
        
            return true
        }
        
        /**
         * Definition for a binary tree node.
         * type TreeNode struct {
         *     Val int
         *     Left *TreeNode
         *     Right *TreeNode
         * }
         */
        ```

    - Решение 2 (простое). [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) с помощью рекурсии. TODO.

      **Сложность: время - O(n), память - O(n).**

        ```go
        
        ```


- Проверка **симметричности бинарных** деревьев

  [LeetCode: 101. Symmetric Tree](https://leetcode.com/problems/symmetric-tree)

    - Условие

      Дано [бинарное дерево](https://www.notion.so/325fbdebbd614bf8b78bcf91892c74b5?pvs=21) в виде [связного списка](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21). Необходимо проверить являются ли корневые поддеревья симметричными. Т.е. должна совпадать структура и значения всех элементов.

      ![symtree1.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/symtree1.jpg)

    - Кейсы
        - `root = [1,2,2,3,4,4,3]; res = true;`

          ![symtree1.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/symtree1%201.jpg)

        - `root = [1,2,2,null,3,null,3]; res = false;`

          ![symtree2.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/symtree2.jpg)

    - Решение 1 (простое). [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) с помощью рекурсии.

      **Сложность: время - O(n), память - O(n).**

        ```go
        func isSymmetric(root *TreeNode) bool {
            return isMirror(root, root)
        }
        
        func isMirror(t1 *TreeNode, t2 *TreeNode) bool {
        		// Если в обоих деревьях родительские узлы листы - симметрия сохраняется.
            if t1 == nil && t2 == nil {
                return true
            }
        		// Если один из родитеских узлов лист, а другой нет - симметрия нарушена.
            if t1 == nil || t2 == nil {
                return false
            }
        		// Проверяем значения узлов.
            if t1.Val != t2.Val {
                return false
            }
        
        		// Сравниваем поддеревья зеркально.
            return isMirror(t1.Right, t2.Left) && isMirror(t1.Left, t2.Right)
        }
        
        /**
         * Definition for a binary tree node.
         * type TreeNode struct {
         *     Val int
         *     Left *TreeNode
         *     Right *TreeNode
         * }
         */
        ```

    - Решение 2. [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) через стек.

      **Сложность: время - O(n), память - O(n).**

        ```go
        // Обход в глубину (DFS).
        func isSymmetric(root *TreeNode) bool {
        	// Пустое дерево легче сразу обработать.
        	if root == nil {
        		return true
        	}
        	// Стек для складывания поддеревьев. Сравниваем два поддерева (попарно).
        	// Пара может быть как левое-правое, так и правое-левое, это не принципиально.
        	// Добавим левое и правое поддерево для обработки.
        	stack := []*TreeNode{root.Left, root.Right}
        	for len(stack) > 0 {
        		// Первое поддерево для сравнения.
        		t1 := stack[len(stack) - 1]
        		// Второе поддерево для сравнения.
        		t2 := stack[len(stack) - 2]
        		// Уменьшим стек на два выбранных узла.
        		stack = stack[:len(stack) - 2]
        		// Если в обоих поддеревьях родительские узлы листы - пропускаем.
        		if t1 == nil && t2 == nil {
        			continue
        		}
        		// Если один из родитеских узлов лист, а другой нет - симметрия нарушена.
        		if t1 == nil || t2 == nil {
        			return false
        		}
        		// Проверяем значения узлов.
        		if t1.Val != t2.Val {
        			return false
        		}
        		// Сравниваем поддеревья текущих поддеревьев зеркально.
        		stack = append(stack, t1.Left, t2.Right, t1.Right, t2.Left)
        	}
        	return true
        }
        
        /**
         * Definition for a binary tree node.
         * type TreeNode struct {
         *     Val int
         *     Left *TreeNode
         *     Right *TreeNode
         * }
         */
        ```

    - Решение 3. [Обход в ширину](https://www.notion.so/BFS-f8bbec2db02f4e988f8572172b320ee8?pvs=21) через очередь. TODO:

      **Сложность: время - O(n), память - O(n).**

        ```go
        
        ```

- **Инвертировать бинарное** дерево зеркально по вертикали

  [LeetCode: 226. Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/)

    - Условие

      Дано [бинарное дерево](https://www.notion.so/325fbdebbd614bf8b78bcf91892c74b5?pvs=21) в виде [связного списка](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21). Необходимо его инвертировать, т.е. отразить зеркально.

      ![invert1-tree.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/invert1-tree.jpg)

    - Кейсы
        - `root = [4,2,7,1,3,6,9]; res = [4,7,2,9,6,3,1];`

          ![invert1-tree.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/invert1-tree%201.jpg)

        - `root = [2,1,3]; res = [2,3,1];`

          ![invert2-tree.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/invert2-tree.jpg)


        `root = []; res = [];`
        
    - Решение 1 (простое). [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) через рекурсию.
        
        Для каждого узла нужно поменять местами его поддеревья.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // DFS + рекурсия.
        func invertTree(root *TreeNode) *TreeNode {
            // Нечего обрабатывать.
            if root == nil {
                return root
            }
            // Меняем местами поддеревья.
            left := root.Left
            root.Left = root.Right
            root.Right = left
        
            // Обходим рекурсивно в глубину оба поддерева.
            invertTree(root.Left)
            invertTree(root.Right)
        
            return root
        }
        
        /**
         * Definition for a binary tree node.
         * type TreeNode struct {
         *     Val int
         *     Left *TreeNode
         *     Right *TreeNode
         * }
         */
        ```
        
    - Решение 2 (простое). [Обход в ширину](https://www.notion.so/BFS-f8bbec2db02f4e988f8572172b320ee8?pvs=21), общая очередь. TODO.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        
        ```

- Определить, является ли **бинарное** дерево **сбалансированным по высоте**

  [LeetCode: 110. Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)

    - Условие

      Дано [бинарное дерево](https://www.notion.so/325fbdebbd614bf8b78bcf91892c74b5?pvs=21) в виде [связного списка](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21). Необходимо определить является ли дерево сбалансированным по высоте. Т.е. поддеревья любого узла по высоте отличаются не больше чем на один уровень.

    - Кейсы
        - `root = [3,9,20,null,null,15,7]; res = true;`

          ![balance_1.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/balance_1.jpg)

        - `root = [1,2,2,3,3,null,null,4,4]; res = false;`

          ![balance_2.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/balance_2.jpg)


        `root = []; res = true;`
        
    - Решение 1 (сложное). [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) через рекурсию.
        
        **Сложность: время - O(n*log(n)), память - O(n).**
        
        ```go
        func isBalanced(root *TreeNode) bool {
            _, isBalanced := dst(root)
        
            return isBalanced
        }
        
        func dst(node *TreeNode) (int, bool) {
            // Дошли до листа.
            if node == nil {
                return 1, true
            }
            // Обрабатываем рекурсивно левое поддерево.
            depthLeft, isBalanced := dst(node.Left)
            depthLeft++
            // Если несбалансировано - выходим.
            if !isBalanced {
                return 0, false
            }
            // Обрабатываем рекурсивно левое поддерево.
            depthRight, isBalanced := dst(node.Right)
            depthRight++
            // Если несбалансировано - выходим.
            if !isBalanced {
                return 0, false
            }
            // Если несбалансированы поддеревья между собой - выходим.
            if math.Abs(float64(depthLeft - depthRight)) > 1 {
                return 0, false
            }
            // Вычисляем максимальную вложенность поддеревьев.
            maxDepth := depthLeft
            if depthRight > maxDepth {
                maxDepth = depthRight
            }
        
            return maxDepth, true
        }
        
        /**
         * Definition for a binary tree node.
         * type TreeNode struct {
         *     Val int
         *     Left *TreeNode
         *     Right *TreeNode
         * }
         */
        ```
        
    - Кажется, есть более простое решение.
- Найти **наименьшего общего предка** в **бинарном дереве**

  [LeetCode: 236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree)

    - Условие

      Дано [бинарное дерево](https://www.notion.so/325fbdebbd614bf8b78bcf91892c74b5?pvs=21) в виде [связного списка](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21) `root` и два узла этого дерева - `p`, `q`. Необходимо найти наименьшего (по удаленности от целевых узлов) общего предка узлов с входными значениями. Сам узел тоже может являться наименьшим общим предком.

      ![binarytree.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/binarytree.png)

    - Кейсы
        - `root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1; res = 3;`

          ![binarytree.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/binarytree%201.png)

        - `root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4; res = 5;`

          ![binarytree (1).png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/binarytree_(1).png)


        `root = [1,2], p = 1, q = 2; res = 1;`
        
    - Решение 1. [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) через рекурсию.
        
        Для каждой рекурсии:
        
        - Если текущий узел совпал с одним из искомых - возвращаем узел.
        - Если рекурсивные вызовы для обоих потомков вернули искомые узлы - мы нашли общего родителя.
        - В противном случае возвращаем nil.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // Если текущий узел совпал с одним из искомых - возвращаем узел.
        // Если рекурсивные вызовы для обоих потомков вернули искомые узлы - мы нашли общего родителя.
        // В противном случае возвращаем nil.
        func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
        	// Если дошли до рекурсивного вызова потомка листового узла.
        	if root == nil {
        		return nil
        	}
        	// Текущий узел совпадает с одним из искомых - возвращаем текущий узел.
        	if root.Val == p.Val || root.Val == q.Val {
        		return root
        	}
        	// Вызываем рекурсивный обход для левого поддерева.
        	var left *TreeNode
        	if root.Left != nil {
        		left = lowestCommonAncestor(root.Left, p, q)
        	}
        	// Вызываем рекурсивный обход для правого поддерева.
        	var right *TreeNode
        	if root.Right != nil {
        		right = lowestCommonAncestor(root.Right, p, q)
        	}
        	// Если оба поддерева вернули узлы - мы нашли общего предка искомых узлов (это текущий узел).
        	if left != nil && right != nil {
        		return root
        	}
        	// Если в левом поддереве нашелся искомый узел - возвращаем его.
        	if left != nil {
        		return left
        	}
        	// Если в правом поддереве нашелся искомый узел - возвращаем его.
        	if right != nil {
        		return right
        	}
        
        	// Если не нашли искомых узлов - возвращаемся ни с чем.
        	return nil
        }
        
        type TreeNode struct {
        	Val   int
        	Left  *TreeNode
        	Right *TreeNode
        }
        ```
        
        Более короткий вариант:
        
        ```go
        func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
        	if root == nil || root == p || root == q {
        		return root
        	}
        
        	left := lowestCommonAncestor(root.Left, p, q)
        	right := lowestCommonAncestor(root.Right, p, q)
        	if left != nil && right != nil {
        		return root
        	}
        	if left != nil {
        		return left
        	}
        	return right
        }
        ```
        
    - Решение 2. [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) итеративно. TODO.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        
        ```

- Найти **максимальную глубину бинарного дерева**

  [LeetCode: 104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree)

    - Условие

      Дано [бинарное дерево](https://www.notion.so/325fbdebbd614bf8b78bcf91892c74b5?pvs=21) в виде [связного списка](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21) `root`. Необходимо найти максимальную глубину дерева. Другими словами, максимальное количество ребер от корня до листьев или количество уровней.

    - Кейсы
        - `root = [3,9,20,null,null,15,7]; res = 3;`

          ![tmp-tree.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/tmp-tree.jpg)


        `root = [1,null,2]; res = 2;`
        
    - Решение 1 (простое). [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) через рекурсию.
        
        По факту нам нужно просто посчитать сколько раз будет вызываться рекурсия, т.к. рекурсию вызываем для каждого уровня.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        /**
         * Definition for a binary tree node.
         * type TreeNode struct {
         *     Val int
         *     Left *TreeNode
         *     Right *TreeNode
         * }
         */
        
         // обход в глубину
         // используем рекурсию
         // по факту нам нужно просто посчитать сколько раз будет вызываться рекурсия
         // т.к. рекурсию вызываем для каждого уровня
        func maxDepth(root *TreeNode) int {
            // дошли до листового узла либо у нас пустое дерево
            if root == nil {
                return 0
            }
        
            // на каждом уровне (вызове рекурсии) инкрементируем
            // вызываем рекурсию для левого поддерева
            leftDepth := maxDepth(root.Left) + 1
            // вызываем рекурсию для правого поддерева
            rightDepth := maxDepth(root.Right) + 1
        
            // вычисляем максимальный
            if leftDepth > rightDepth {
                return leftDepth
            }
        
            return rightDepth
        }
        ```
        
    - Решение 2 (объемное). [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) итеративно через связный список в роли стека.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        /**
         * Definition for a binary tree node.
         * type TreeNode struct {
         *     Val int
         *     Left *TreeNode
         *     Right *TreeNode
         * }
         */
        
        // связный список родительских узлов для возврата наверх (стек)
        // храним только правые узлы
         type stack struct {
             node *TreeNode
             next *stack
             depth int
         }
        
         // обход в глубину
         // обходим в первую очередь левых потомков
         // используем стэк для складывания правых потомков, которых обходим потом
         // как вариант можно в стэк отправлять и левых потомков, но тогда стэк будет больше
         // как вариант можно для стэка использовать слайс
        func maxDepth(root *TreeNode) int {
            if root == nil {
                return 0
            }
        
            // стэк для правых потомков
            var s *stack
            // текущий узел
            curNode := root
            // текущая глубина
            curDepth := 1
            // максимальная глубина
            maxDepth := 0
            for {
                // добавляем в стэк правого потомка, чтобы потом к нему вернуться
                if curNode.Right != nil {
                    s = &stack{node: curNode.Right, next: s, depth: curDepth + 1}
                }
        
                // если есть левый потомок, спускаемся в него
                if curNode.Left != nil {
                    curDepth++
                    curNode = curNode.Left
                } else if s != nil {
                    // если левого потомка нет и есть узел в стэке
                    // - берем узел (правый) из стэка
                    curNode = s.node
                    curDepth = s.depth
                    s = s.next
                }
        
                // достигли максимальной глубины?
                if curDepth > maxDepth {
                    maxDepth = curDepth
                }
        
                // если левого потомка нет и в стэке ничего нет
                // (необработанных правых потомков тоже нет) - мы закончили
                if curNode.Left == nil && curNode.Right == nil && s == nil {
                    break
                }
            }
            
            return maxDepth
        }
        ```

- Найти **диаметр бинарного дерева** (максимальный путь между двумя узлами)

  [LeetCode: 543. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/)

    - Условие

      Дано [бинарное дерево](https://www.notion.so/325fbdebbd614bf8b78bcf91892c74b5?pvs=21) в виде [связного списка](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21) `root`. Необходимо найти диаметр дерева. Другими словами максимальное количество ребер между любыми двумя узлами.

    - Кейсы
        - `root = [1,2,3,4,5]; res = 3;` - максимальный путь: `4=>2=>1=>3 || 5=>2=>1=>3`

          ![diamtree.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/diamtree.jpg)


        `root = [1,2]; res = 1;`
        
    - Решение 1 (простое). [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) через рекурсию.
        
        Считаем количество уровней и выбираем максимальный уровень из левого и правого поддерева.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // Обход в глубину через рекурсию.
        func diameterOfBinaryTree(root *TreeNode) int {
            // Результирующий максимальный путь (диаметр).
            res := 0
            // Рекурсивная функция для обхода в глубину.
            // Считаем количество уровней и выбираем максимальный уровень из левого и правого поддерева.
            var dfs func(node *TreeNode) (int) 
            dfs = func(node *TreeNode) (int) {
                // Максимальный путь в левом поддереве.
                leftCount := 0
                // Максимальный путь в правом поддереве. 
                rightCount := 0
                // Если слева не пусто идем рекурсивно в левое поддерево.
                if node.Left != nil {
                    // Инкрементим за каждый уровень.
                    leftCount = dfs(node.Left) + 1
                }
                // Если справа не пусто идем рекурсивно в правое поддерево.
                if node.Right != nil {
                    // Инкрементим за каждый уровень.
                    rightCount = dfs(node.Right) + 1
                }
                // Если нет обеих дочерних нод, то вернется 0.
        
                // Если сумма максимальных путей в поддеревьях больше результирующей -
                // обновляем результирующую.
                // Теоретически, в каждом узле у нас могут быть поддеревья с максимальными путями.
                if leftCount + rightCount > res {
                    res = leftCount + rightCount
                }
        
                // Выберем максимальную глубину из поддеревьев.
                if leftCount > rightCount {
                    return leftCount
                }
        
                return rightCount
            }
        
            dfs(root)
        
            return res
        }
        
        /**
         * Definition for a binary tree node.
         * type TreeNode struct {
         *     Val int
         *     Left *TreeNode
         *     Right *TreeNode
         * }
         */
        ```

- Найти **сумму** всех **левых листовых узлов** в **бинарном дереве**

  [LeetCode: 404. Sum of Left Leaves](https://leetcode.com/problems/sum-of-left-leaves)

    - Условие

      Дано [бинарное дерево](https://www.notion.so/325fbdebbd614bf8b78bcf91892c74b5?pvs=21) в виде [связного списка](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21) `root`. Необходимо найти сумму всех левых листовых узлов в дереве. Т.е. если у узла есть два листовых дочерних узла, то мы учитываем только левый листовой дочерний узел.

      ![intro_example.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/intro_example.png)

    - Кейсы
        - `root = [3,9,20,null,null,15,7]; res = 24;` - узлы: `9,15`

          ![leftsum-tree.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/leftsum-tree.jpg)


        `root = [1]; res = 0;`
        
    - **Решение 1 (простое). Итеративный [обход в ширину](https://www.notion.so/BFS-f8bbec2db02f4e988f8572172b320ee8?pvs=21) через слайс в качестве очереди.**
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // Итеративный обход в ширину через слайс в качестве очереди.
        func sumOfLeftLeaves(root *TreeNode) int {
        	// Обработаем отдельно пустое дерево.
        	if root == nil {
        		return 0
        	}
        	// Очередь, добавляем в конец дочерние узлы, берем из начала узлы на обработку.
        	var queue []*TreeNode
        	queue = append(queue, root)
        	// Результирующая сумма.
        	res := 0
        
        	for len(queue) > 0 {
        		// Количество узлов на текущем уровне для обработки.
        		// Т.к. мы внутри вложенного цикла добавляем в очередь, нужно вначале обозначить это количество.
        		nodesCount := len(queue)
        		for i := 0; i < nodesCount; i++ {
        			// Берем узел для обработки с начала очереди.
        			node := queue[0]
        			// Убираем обработанный узел из очереди.
        			queue = queue[1:]
        			// Если левый дочерний узел листовой - увеличиваем сумму.
        			if node.Left != nil && node.Left.Right == nil && node.Left.Left == nil {
        				res += node.Left.Val
        				// Кладем левый узел в конец очереди.
        			} else if node.Left != nil {
        				queue = append(queue, node.Left)
        			}
        			// Кладем правый узел в конец очереди.
        			if node.Right != nil {
        				queue = append(queue, node.Right)
        			}
        		}
        	}
        
        	return res
        }
        
        /**
         * Definition for a binary tree node.
         * type TreeNode struct {
         *     Val int
         *     Left *TreeNode
         *     Right *TreeNode
         * }
         */
        ```
        
    - **Решение 2 (простое). Рекурсивный [обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21).**
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // Рекурсивный обход в глубину.
        func sumOfLeftLeaves(root *TreeNode) int {
        	sum := 0
        	// Если дерево пустое или это листовой правый узел - выходим.
        	// Листовой левый узел обработаем ниже.
        	if root == nil {
        		return sum
        	}
        	// Если левый потомок листовой - увеличиваем сумму.
        	if root.Left != nil && root.Left.Left == nil && root.Left.Right == nil {
        		sum += root.Left.Val
        		// Если левый потомок не листовой - вызываем рекурсию.
        	} else {
        		sum += sumOfLeftLeaves(root.Left)
        	}
        	// Вызываем рекурсию для правого потомка.
        	sum += sumOfLeftLeaves(root.Right)
        
        	return sum
        }
        
        type TreeNode struct {
        	Val   int
        	Left  *TreeNode
        	Right *TreeNode
        }
        ```
        
    - Решение 3 (оптимальное). [Обход алгоритмом Морриса](https://www.notion.so/draft-23675aab0dd14c50a300383ccb159aaa?pvs=21). TODO.
        
        **Сложность: время - O(n), память - O(1).**
        
        ```go
        
        ```

- Найти **уровень с максимальной суммой узлов** в **бинарном дереве**

  [LeetCode: 1161. Maximum Level Sum of a Binary Tree](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree)

    - Условие

      Дано [бинарное дерево](https://www.notion.so/325fbdebbd614bf8b78bcf91892c74b5?pvs=21) в виде [связного списка](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21) `root`. Необходимо найти минимальный уровень, на котором сумма всех узлов будет максимальной в сравнении с другими уровнями в дереве.

      Значения узлов могут быть отрицательными.

    - Кейсы
        - `root = [1,7,0,7,-8,null,null]; res = 2;`

          Сумма значений узлов на 1 уровне = 1.
          Сумма значений узлов на 2 уровне = 7 + 0 = 7.
          Сумма значений узлов на 3 уровне = 7 + -8 = -1.

          ![capture.jpeg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/capture.jpeg)

        - `root = [-100,-200,-300,-20,-5,-10,null]; res = 2;`

          ![Screenshot 2023-08-02 at 20.14.22.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/Screenshot_2023-08-02_at_20.14.22.png)


        `root = [989,null,10250,98693,-89388,null,null,null,-32127]; res = 2;`
        
    - **Решение 1 (простое). Итеративный [обход в ширину](https://www.notion.so/BFS-f8bbec2db02f4e988f8572172b320ee8?pvs=21) по уровням через слайс в качестве очереди.**
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // Обход в ширину итеративно по уровням.
        func maxLevelSum(root *TreeNode) int {
            // Результирующий уровень.
            resLevel := 0
            // Текущий уровень при обходе.
            level := 0
            // Максимальная сумма узлов на уровне.
            maxLevelSum := math.MinInt
            // Очередь для обработки узлов.
            queue := []*TreeNode{root}
            // Цикл для обработки по уровням.
            for len(queue) > 0 {
                // Увеличиваем текущий уровень.
                level++
                // Сумма узлов на текущем уровне.
                levelSum := 0
                // Количество узлов на уровне для обработки.
                levelCount := len(queue)
                // Обрабатываем узлы текущего уровня.
                for i := 0; i < levelCount; i++ {
                    node := queue[i]
                    // Увеличиваем сумму на уровне.
                    levelSum += node.Val
                    // Добавляем дочерние узлы в слайс следующего уровня.
                    // Здесь мы можем регулировать порядок обхода - слева направо или справа налево.
                    // Добавляем сначала левый узел - обходим слева направо.
                    if node.Left != nil {
                        queue = append(queue, node.Left)
                    }
                    if node.Right != nil {
                        queue = append(queue, node.Right)
                    }
                }
                queue = queue[levelCount:]
                // Если сумма узлов на уровне больше максимальной.
                if levelSum > maxLevelSum {
                    // Переопределяем искомый уровень, переопределяем максимальную сумму.
                    resLevel = level
                    maxLevelSum = levelSum
                }
            }
        
            return resLevel
        }
        
        type TreeNode struct {
        	Val   int
        	Left  *TreeNode
        	Right *TreeNode
        }
        ```
        
    - Решение 2 (простое). Рекурсивный [обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21). TODO.
        - Визуализация
            
            ![547-dfs.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/547-dfs.png)
            
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        
        ```


- Найти **сумму узлов** для заданного **уровня** в **бинарном дереве**

  [TODO: найти в задачниках]

    - Условие

      Дано [бинарное дерево](https://www.notion.so/325fbdebbd614bf8b78bcf91892c74b5?pvs=21) в виде [связного списка](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21) `root` и целочисленный `level`. Необходимо найти сумму всех узлов на `level` уровне.

      Значения узлов могут быть отрицательными.

    - Кейсы

      [TODO: добавить кейсы.]

    - **Решение 1 (простое). Итеративный [обход в ширину](https://www.notion.so/BFS-f8bbec2db02f4e988f8572172b320ee8?pvs=21) по уровням через слайс в качестве очереди.**

      **Сложность: время - O(n), память - O(n).**

        ```go
        // Обход в ширину итеративно по уровням.
        func getBinaryTreeLevelSum(root *TreeNode, level int) int {
        	// TODO: добавить проверку на пустое дерево и невалидный уровень.
        	// Текущий уровень при обходе.
        	curLevel := 0
        	// Максимальная сумма узлов на уровне.
        	resSum := 0
        	// Очередь для обработки узлов.
        	queue := []*TreeNode{root}
        	// Цикл для обработки по уровням.
        	for len(queue) > 0 {
        		// Увеличиваем текущий уровень.
        		curLevel++
        		// Сумма узлов на текущем уровне.
        		levelSum := 0
        		// Количество узлов на уровне для обработки.
        		levelCount := len(queue)
        		// Обрабатываем узлы текущего уровня.
        		for i := 0; i < levelCount; i++ {
        			node := queue[i]
        			// Увеличиваем сумму на уровне.
        			levelSum += node.Val
        			// Добавляем дочерние узлы в слайс следующего уровня.
        			// Здесь мы можем регулировать порядок обхода - слева направо или справа налево.
        			// Добавляем сначала левый узел - обходим слева направо.
        			if node.Left != nil {
        				queue = append(queue, node.Left)
        			}
        			if node.Right != nil {
        				queue = append(queue, node.Right)
        			}
        		}
        		queue = queue[levelCount:]
        		// Если это искомый уровень.
        		if curLevel > level {
        			// Определяем результирующую сумму и выходим.
        			resSum = levelSum
        			break
        		}
        	}
        
        	return resSum
        }
        
        type TreeNode struct {
        	Val   int
        	Left  *TreeNode
        	Right *TreeNode
        }
        ```

    - Решение 2 (простое). Рекурсивный [обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21). TODO.

      **Сложность: время - O(n), память - O(n).**

        ```go
        
        ```

- Проверить, есть ли путь от **корня до листа** **бинарного дерева,** когда **сумма всех узлов** по пути будет равна заданному числу

  [LeetCode: 112. Path Sum](https://leetcode.com/problems/path-sum)

    - Условие

      Дано [бинарное дерево](https://www.notion.so/325fbdebbd614bf8b78bcf91892c74b5?pvs=21) в виде [связного списка](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21). Проверить, найдется ли такой путь от корня до листа дерева, когда сумма всех узлов по пути будет равна заданному числу.

    - Кейсы
        - `root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22; res = true;`

          ![pathsum1.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/pathsum1.jpg)

        - `root = [1,2,3], targetSum = 5; res = false;`

          ![pathsum2.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/pathsum2%201.jpg)


        `root = [], targetSum = 0; res = false;`
        
    - Решение 1 (объемное). [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) через стэк, реализованный связным списком.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // DFS + связный список.
        func hasPathSum(root *TreeNode, targetSum int) bool {
            // Этот кейс сложно обработать в основном алгоритме.
            if root == nil {
                return false
            }
        
            // Назначаем первый элемент связного списка.
            list := &nodesList{
                node: root,
                cumulativeVal: root.Val,
                prev: nil,
            }
        
            for {
                // Если текущий узел листовой.
                if list.node.Right == nil && list.node.Left == nil {
                    // Текущий узел искомый.
                    if list.cumulativeVal == targetSum {
                        return true
                    }
                    // Список (стэк) пустой, значит обошли все дерево - выходим.
                    if list.prev == nil {
                        break
                    }
                    // Переходим к прошлому необработанному узлу.
                    list = list.prev
                    continue
                }
                // Сохраняем текущий узел для обработки.
                curNode := list
                // Сохраняем предыдущий узел.
                prev := curNode.prev
                // Если правый дочерний узел заполнен.
                if curNode.node.Right != nil {
                    // Создаем обертку для правого узла и добавляем в список.
                    list = &nodesList{
                        node: curNode.node.Right,
                        cumulativeVal: curNode.cumulativeVal + curNode.node.Right.Val,
                        prev: prev,
                    }
                    prev = list
                }
                // Если левый дочерний узел заполнен.
                if curNode.node.Left != nil {
                    // Создаем обертку для левого узла и добавляем в список.
                    list = &nodesList{
                        node: curNode.node.Left,
                        cumulativeVal: curNode.cumulativeVal + curNode.node.Left.Val,
                        prev: prev,
                    }
                }
            }
        
            return false
        }
        
        // Связный список узлов для обработки. Работает как стэк.
        type nodesList struct {
            node *TreeNode // Узел.
            cumulativeVal int // Сумма значений узлов от текущего до корня.
            prev *nodesList // Ссылка на предыдущий узел для обработки.
        }
        
        /**
         * Definition for a binary tree node.
         * type TreeNode struct {
         *     Val int
         *     Left *TreeNode
         *     Right *TreeNode
         * }
         */
        ```
        
    - **Решение 2 (простое). Обход в глубину через рекурсию.**
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // Обход в глубину с помощью рекурсии.
        // Спускаемся к листам уменьшая искомую сумму.
        func hasPathSum(root *TreeNode, targetSum int) bool {
            // Отдельно обработаем пустое дерево и пустой узел.
            if root == nil {
                return false
            }
            // Текущий узел листовой - проверим оставшуюся сумму.
            if nil == root.Left && nil == root.Right{
                // Сумма совпала - мы нашли искомый путь.
                return root.Val == targetSum
            }
            // Идем влево, а потом в право уменьшая сумму.
            sumResidue := targetSum - root.Val
            return hasPathSum(root.Left, sumResidue) || hasPathSum(root.Right, sumResidue)
        }
        
        /**
         * Definition for a binary tree node.
         * type TreeNode struct {
         *     Val int
         *     Left *TreeNode
         *     Right *TreeNode
         * }
         */
        ```


### Бинарное (двоичное) дерево поиска (BST)

- **Валидация бинарного дерева поиска** (BST)

  [LeetCode: 98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree)

    - Условие

      Дано [бинарное дерево](https://www.notion.so/325fbdebbd614bf8b78bcf91892c74b5?pvs=21) в виде связного списка. Необходимо проверить является ли дерево [бинарным деревом поиска](https://www.notion.so/BST-80facf69e47545c8a6750bc43dcf710f?pvs=21).

      Дерево является бинарным деревом поиска если:

        - все элементы левого поддерева любого узла меньше чем родительский узел поддерева
        - все элементы правого поддерева любого узла больше чем родительский узел поддерева
    - Кейсы
        - `root = [2,1,3]; res = true;`

          ![tree1.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/tree1%201.jpg)

        - `root = [5,1,4,null,null,3,6]; res = false;`

          ![tree2.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/tree2.jpg)

        - `root = [5,4,6,null,null,3,7]; res = false;` - нужно проверять глобальные `min`, `max`. Не получится проверять, например, значение родительского узла в поддереве.

          ![Screenshot 2023-07-05 at 14.27.45.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/Screenshot_2023-07-05_at_14.27.45.png)

    - Решение 1 (объемное). [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) используя стэк.

      Обходим в глубину слева направо. Идем сначала налево, на стек кладем текущую ноду, чтобы вернуться к ней после обхода левого поддерева. Также нам нужно запоминать самую правую ноду каждого левого поддерева, когда мы возвращаемся к родителю этого левого поддерева. И то же самое с левой нодой правого поддерева.

      **Сложность: время - O(n), память - O(n).**

        ```go
        // Обход в глубину используя стэк.
        func isValidBST(root *TreeNode) bool {
            // записываем сразу корень, чтобы сравнить в конце правое поддерево
            stack := []*TreeNode{root}
            max := 0
            current := root
            var lastStackNode  *TreeNode
            isCurrentStackNode := false
            for {
                // сравниваем самую правую ноду левого поддерева с родителем. Исключаем корень дерева.
                if isCurrentStackNode && current.Val <= max && len(stack) > 0 {
                    return false
                }
                // Если есть левый потомок при обычном проходе (без стека), можно в него сходить на следующем шаге.
                // При этом кладем на стек текущую ноду.
                if current.Left != nil && !isCurrentStackNode {
                    stack = append(stack, current)
                    if current.Left.Val >= current.Val {
                        return false
                    }
                    current = current.Left
                    continue
                }
                // Проверяем, чтобы текущая левая нода правого поддерева была больше чем последняя нода из стека (родитель этого поддерева).
                if !isCurrentStackNode && lastStackNode != nil && lastStackNode.Val >= current.Val {
                    return false
                }
                // Правого потомка рассматриваем после левого.
                // Если есть правый потомок (и при обычном проходе и со стеком), можно в него сходить на следующем шаге.
                if current.Right != nil {
                    if current.Right.Val <= current.Val {
                        return false
                    }
                    current = current.Right
                    // если шли по стеку, сбрасываем
                    isCurrentStackNode = false
                    continue
                }
                // все обошли
                if len(stack) == 0 {
                    break
                }
                // нет ни правого ни левого потомка (дошли до листа) - можно идти в стек при следующем шаге.
                // т.к. мы идем сначала налево, потом направо, то текущий лист будет правым масксимальным для текущего поддерева.
                max = current.Val
                current = stack[len(stack) - 1]
                stack = stack[:len(stack) - 1]
                // ноду из стека (родительскую) надо будет сравнить с правым поддеревом
                lastStackNode = current
                isCurrentStackNode = true
            }
        
            return true
        }
        
        /**
         * Definition for a binary tree node.
         * type TreeNode struct {
         *     Val int
         *     Left *TreeNode
         *     Right *TreeNode
         * }
         */
        ```

    - **Решение 2 (короткое). [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) используя рекурсию.**

      Для каждого узла формируем `min` и `max` значения в рамках которых должно быть значение этого узла. Если спускаемся влево, то значение узла должно ограничиваться справа значением родительского узла (`max`).

        - Визуализация

          ![IMG_5417.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/IMG_5417.jpg)


        **Сложность: время - O(n), память - O(n).**
        
        ```go
        // DFS через рекурсию.
        // Каждое поддерево должно быть в рамках min и max значений.
        // min и max значения для поддерева определяются в зависимости от направления.
        func isValidBST(root *TreeNode) bool {
            return checkSubTree(root, math.MinInt, math.MaxInt)
        }
        
        func checkSubTree(node *TreeNode, min int, max int) bool {
            // Родительский узел листовой, если дошли до сюда, то точно поддерево валидно.
            if node == nil {
                return true
            }
        
            // Текущий узел должен быть в рамках минимального и максимального значений.
            if node.Val <= min || node.Val >= max {
                return false
            }
        
            // Рекурсивно спускаемся ниже.
            // Если идем влево, то максимальное значение поддерева
            // должно быть меньше чем значение текущего узла.
            // Для всех левых поддеревьев минимальное значение всегда MinInt
            // и не имеет значения.
            // Если идем вправо, то минимальное значение поддерева
            // должно быть больше чем значение текущего узла.
            // Для всех правых поддеревьев минимальное значение всегда MaxInt
            // и не имеет значения.
            return checkSubTree(node.Left, min, node.Val) &&
                checkSubTree(node.Right, node.Val, max)
        }
        
        /**
         * Definition for a binary tree node.
         * type TreeNode struct {
         *     Val int
         *     Left *TreeNode
         *     Right *TreeNode
         * }
         */
        ```
        
    - Решение 3(короткое). [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) используя стэк.
        
        [TODO: сложное для понимания, вникнуть]
        
        **Сложность: время - O(n), память - O(1).**
        
        ```go
        func isValidBST(root *TreeNode) bool {
            // Стек для хранения узлов (дочерних) на обработку.
            stack := []*TreeNode{}
            // Предыдущий узел для сравнения (может быть и левым и правым).
            var prev *TreeNode
            // Текущий узел для обработки.
            curNode := root
            // Пока в стеке что-то есть и текущий узел не пустой.
            for curNode != nil || len(stack)>0 {
                // Обойдем сначала левую сторону до листа и положим левые узлы на стек.
                for curNode != nil {
                    stack = append(stack, curNode)
                    curNode = curNode.Left
                }
                // Сюда пришли, когда положили все левые узлы на стек.
                // Вытаскиваем левый узел и уменьшаем стек.
                curNode = stack[len(stack)-1]
                stack = stack[:len(stack)-1]
                if prev != nil && prev.Val>= curNode.Val {
                    return false
                }
                prev = curNode
                curNode = curNode.Right
            }
            return true
        }
        
        /**
         * Definition for a binary tree node.
         * type TreeNode struct {
         *     Val int
         *     Left *TreeNode
         *     Right *TreeNode
         * }
         */
        ```

- Найти **сумму** значений узлов **бинарного  дерева поиска** (BST) в заданном **диапазоне**

  [LeetCode: 938. Range Sum of BST](https://leetcode.com/problems/range-sum-of-bst)

    - Условие

      Дано [бинарное дерево поиска](https://www.notion.so/BST-80facf69e47545c8a6750bc43dcf710f?pvs=21) в виде [связного списка](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21) `root` и два значения `low`, `high` определяющие начало и конец диапазона. Необходимо найти сумму значений узлов дерева, которые входят в диапазон `low`-`high`.

      ![bst2.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/bst2.jpg)

    - Кейсы
        - `root = [10,5,15,3,7,null,18], low = 7, high = 15; res = 32;`

          ![bst1.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/bst1.jpg)

        - `root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10; res = 23;`

          ![bst2.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/bst2%201.jpg)

    - Решение 1 (оптимальное). [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) через рекурсию.

      Обходим вглубь отсеивая поддеревья, которые точно не находятся в диапазоне.

      **Сложность: время - O(n), память - O(n).**

        ```go
        func rangeSumBST(root *TreeNode, low int, high int) int {
        	if root==nil {
        		return 0
        	}
        
            // Если текущее поддерево меньше чем входящий диапазон, то в левом поддереве точно нет нужных значений, поэтому идем в правое поддерево.
        	if root.Val < low {
        		return rangeSumBST(root.Right, low, high)
        	}
        
            // Если текущее поддерево больше чем входящий диапазон, то в правом поддереве точно нет нужных значений, поэтому идем в левое поддерево.
        	if root.Val > high {
        		return rangeSumBST(root.Left, low, high)
        	}
        	
            // Сюда пришли когда нужно идти в оба поддерева.
        	return root.Val + rangeSumBST(root.Right, low, high) + rangeSumBST(root.Left, low, high)
        }
        
        /**
         * Definition for a binary tree node.
         * type TreeNode struct {
         *     Val int
         *     Left *TreeNode
         *     Right *TreeNode
         * }
         */
        ```

    - Решение 2 (неоптимальное). [Обход в ширину](https://www.notion.so/BFS-f8bbec2db02f4e988f8572172b320ee8?pvs=21) через цикл без учета особенностей BST.

      Обходим по уровням, сохраняем узлы в слайс.

      **Сложность: время - O(n), память - O(n).**

        ```go
        func rangeSumBST(root *TreeNode, low int, high int) int {
            // Узлы текущего уровня.
            curNodes := []*TreeNode{root}
            // Результирующая сумма.
            sum := 0
            // Цикл для обработки по уровням.
            for len(curNodes) > 0 {
                // Узлы следующего уровня. Заполняются дочерними узлами текущего уровня.
                var nextNodes []*TreeNode
                // Обрабатываем узлы текщего уровня.
                for _, n := range curNodes {
                    // Добавляем дочерние узлы в слайс следующего уровня.
                    if n.Left != nil {
                        nextNodes = append(nextNodes, n.Left)
                    }
                    if n.Right != nil {
                        nextNodes = append(nextNodes, n.Right)
                    }
                    // Проверяем условия для добавления значения узла в результирующую сумму.
                    if n.Val >= low && n.Val <= high {
                        sum += n.Val
                    }
                }
                // Переходим на узлы следующего уровня.
                curNodes = nextNodes
                // Обнуляем слайс узлов следующего уровня.
                nextNodes = nil
            }
        
            return sum
        }
        
        /**
         * Definition for a binary tree node.
         * type TreeNode struct {
         *     Val int
         *     Left *TreeNode
         *     Right *TreeNode
         * }
         */
        ```

- Найти **наименьшего общего предка** в **бинарном дереве поиска** (BST)

  [LeetCode: 235. Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

    - Условие

      Дано [бинарное дерево поиска](https://www.notion.so/BST-80facf69e47545c8a6750bc43dcf710f?pvs=21) в виде [связного списка](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21) и два целевых значения. Необходимо найти наименьшего (по удаленности от целевых узлов) общего предка узлов с входными значениями. Сам узел тоже может являться наименьшим общим предком.

      ![binarysearchtree_improved.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/binarysearchtree_improved.png)

    - Кейсы
        - `root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8; res = 6;`

          ![binarysearchtree_improved.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/binarysearchtree_improved%201.png)

        - `root = [6,2,8,0,4,7,9,null,null,3,5], p = 0, q = 5; res = 2;`

          ![binarysearchtree_improved (1).png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/binarysearchtree_improved_(1).png)


        `root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4; res = 2;`
        
        `root = [2,1], p = 2, q = 1; res = 2;`
        
    - **Решение 1 (оптимальное). Итеративно выбираем в какое поддерево идти.**
        
        Т.к. это BST, мы можем смотреть в каком поддереве находятся искомые узлы и идти в это поддерево. Если узлы находятся в разных поддеревьях, то мы искомый родительский узел текущий.
        
        **Сложность: время - O(n), память - O(1).**
        
        ```go
        // Т.к. это BST, мы можем смотреть в каком поддереве находятся искомые узлы и идти в это поддерево. Если узлы находятся в разных поддеревьях, то мы искомый родительский узел текущий.
        func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
        	for root != nil {
                // Если оба искомых узла справа - идем в правое поддерево.
                if p.Val > root.Val && q.Val > root.Val {
                    root = root.Right
                    continue
                }
                // Если оба искомых узла слева - идем в левое поддерево.
                if p.Val < root.Val && q.Val < root.Val {
                    root = root.Left
                    continue
                }
                // Искомые узлы в разных поддеревьях - текущий узел является искомым родительским узлом.
                break
            }
        
            return root
        }
        
        type TreeNode struct {
           Val   int
           Left  *TreeNode
           Right *TreeNode
        }
        ```
        
    - Решение 2. [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) через рекурсию. TODO.
        
        **Сложность: время - O(n), память - O(n).**
        
        ```go
        
        ```

- Найти **`k`-тый наименьший узел** в **бинарном дереве поиска** (BST)

  [LeetCode: 230. Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)

    - Условие

      Дано [бинарное дерево поиска](https://www.notion.so/BST-80facf69e47545c8a6750bc43dcf710f?pvs=21) `root` в виде [связного списка](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21) и целое `k`. Необходимо найти `k`-ый наименьший узел (узел с `k`-тым наименьшим значением).

      ![kthtree2.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/kthtree2.jpg)

    - Кейсы
        - `root = [3,1,4,null,2], k = 1; res = 1;`

          ![kthtree1.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/kthtree1.jpg)

        - `root = [5,3,6,2,4,null,null,1], k = 3; res = 3;`

          ![kthtree2.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/kthtree2%201.jpg)

    - Усложнение

      If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?

    - **Решение 1. Обход в глубину через рекурсию (inorder).**

      **Сложность: время - O(n), память - O(1).**

        ```go
        // Обход в глубину через рекурсию.
        func kthSmallest(root *TreeNode, k int) int {
            // Результат - k-тый наименьший узел (точнее значение).
            var res int
            dfs(root, &k, &res)
            return res
        }
        // Рекурсия. Уменьшаем k при обходе и записываем результат, если k == 0.
        func dfs(node *TreeNode, k *int, res *int) {
            // Вышли за рамки дерева - возвращаемся.
            if node == nil {
                return
            }
            // Сначала идем в левое поддерево. Если слева пусто - сразу выйдем.
            dfs(node.Left, k, res)
            // Затем обрабатываем текущий узел.
            // Уменьнаем k.
            *k--
            // Если довели k до нуля - нашли искомое наименьшее значение.
            if *k == 0 {
                *res = node.Val
                return
            }
            // Затем идем в правый узел.
            dfs(node.Right, k, res)
        }
        
        type TreeNode struct {
           Val   int
           Left  *TreeNode
           Right *TreeNode
        }
        ```

    - **Решение 2. Обход в глубину итеративно (inorder).**

      **Сложность: время - O(n), память - O(1).**

        ```go
        // Обход в глубину итеративно.
        func kthSmallest(root *TreeNode, k int) int {
            // Стек для сохранения узлов для обхода.
            stack := []*TreeNode{root}
            node := root
            // Пока в стеке есть узлы.
            for len(stack) > 0 || node != nil {
                // Идем в глубину влево и добавляем текущий узел и все его левые узлы.
                // Если текщий узел =nil, то мы его пропустим и возьмем узел из стека.
                // Если текщий узел правый, то добавим сначала его, а потом все левые узлы,
                // чтобы обработать вначале самый левый узел.
                for node != nil {
                    stack = append(stack, node)
                    node = node.Left
                }
        		// Достаем узел на обработку и уменьшаем стек.
                node = stack[len(stack)-1]
                stack = stack[:len(stack)-1]
                // Уменьшаем k.
                k--
                if k == 0 {
                    // Нашли искомое наименьшее.
                    return node.Val
                }
        		// Когда обработали все узлы слева - идем вправо.
                node = node.Right
            }
        
            return -1
        }
        
        type TreeNode struct {
           Val   int
           Left  *TreeNode
           Right *TreeNode
        }
        ```


- Реализовать **префиксное дерево** (trie)

  [LeetCode: 208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree)

    - Условие

      Реализовать интерфейс префиксного дерева.

      Методы:

        - `Trie()` - инициализация.
        - `insert(word string)` - вставка слова.
        - `search(word string): boolean` - возвращает флаг, есть ли слово в дереве.
        - `startsWith(prefix string): boolean` - возвращает флаг, есть ли такой префикс в дереве.
    - Кейсы

      `operations = ["Trie", "insert", "search", "search", "startsWith", "insert", "search"];
      parameters = [[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]];
      res = [null, null, true, false, true, null, true];`

    - **Решение 1. Узел содержит массив дочерних узлов.**

        ```go
        // Узел дерева.
        type Trie struct {
        	// Ссылки на дочерние узлы.
        	// По факту это массив букв, т.е. каждый узел является буквой.
        	children [26]*Trie
        	// Флаг, является ли текущий узел окончанием ключа.
        	// Т.е. при вставке слова, мы помечаем последний узел для слова как true.
        	isEnd bool
        }
        
        func Constructor() Trie {
        	return Trie{}
        }
        
        // **Сложность: время - O(len(word)), память - O(1)-O(len(word)).**
        func (this *Trie) Insert(word string) {
        	// Нам нужно будет менять указатель, поэтому создаем новый.
        	node := this
        	for _, ch := range word {
        		// Вычисляем смещение для индекса.
        		idx := getIdx(ch)
        		// Если такого узла еще нет - вставляем.
        		if node.children[idx] == nil {
        			node.children[idx] = &Trie{}
        		}
        		// Сдвигаем указатель на дочерний узел.
        		node = node.children[idx]
        	}
        	// Помечаем, что узел, на котором остановились - является концом ключа.
        	node.isEnd = true
        }
        
        // **Сложность: время - O(len(word)), память - O(1).**
        func (this *Trie) Search(word string) bool {
        	// Нам нужно будет менять указатель, поэтому создаем новый.
        	curr := this
        	for _, ch := range word {
        		// Вычисляем смещение для индекса.
        		idx := getIdx(ch)
        		// Если такого узла еще нет - выходим.
        		if curr.children[idx] == nil {
        			return false
        		}
        		// Сдвигаем указатель на дочерний узел.
        		curr = curr.children[idx]
        	}
        	// Если текущий узел не является концом ключа, то мы не вставляли такого слова.
        	// Искомое слово в дереве это префикс.
        	return curr.isEnd
        }
        
        // **Сложность: время - O(len(word)), память - O(1).**
        func (this *Trie) StartsWith(prefix string) bool {
        	// Нам нужно будет менять указатель, поэтому создаем новый.
        	curr := this
        	for _, ch := range prefix {
        		// Вычисляем смещение для индекса.
        		idx := getIdx(ch)
        		// Если такого узла еще нет - выходим.
        		if curr.children[idx] == nil {
        			return false
        		}
        		// Сдвигаем указатель на дочерний узел.
        		curr = curr.children[idx]
        	}
        	return true
        }
        
        // Вычисляем смещение для индекса.
        func getIdx(ch rune) rune {
        	return ch - 'a'
        }
        ```


## Графы

- **Склонировать граф**

  [LeetCode: 133. Clone Graph](https://leetcode.com/problems/clone-graph)

    - Условие

      Дан связный ненаправленный [граф](https://www.notion.so/80ffa18a766e4ae5a45364d8843b1240?pvs=21) в виде [связного списка](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21) (списка смежности). Необходимо сделать глубокую копию графа.

    - Кейсы

      В списке смежности первый вложенный массив это соседи ущла со значением 1, второй вложенный массив - соседи узла с номером 2 и т.д.

        - `adjList = [[2,4],[1,3],[2,4],[1,3]]; res = [[2,4],[1,3],[2,4],[1,3]];`

          ![133_clone_graph_question.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/133_clone_graph_question.png)


        `adjList = [[]]; res = [[]];` - у узла со значением 1 нет соседей. 
        
        `adjList = []; res = [];`
        
    - Решение 1 (простое). [Обход в глубину](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) с помощью рекурсии.
        - Обходим в глубину.
        - Записываем в мапу старый узел и новый узел, склонированный от старого.
        - Если сосед есть в мапе, то не обходим его второй раз.
        
        **Сложность: время - O(m+n), память - O(n)**, где m - количество ребер, n - количество узлов.
        
        ```go
        // DFS через рекурсию с мемоизацией.
        func cloneGraph(node *Node) *Node {
            // Выходим если пустой граф.
            if node == nil {
                return nil
            }
            // Мапа с уже склонированными узлами. Ключ - старый узел, значение - новый узел.
            visitedNodes := make(map[*Node]*Node)
            var dfs func(node *Node)
            // Рекурсия.
            dfs = func(node *Node) {
                // Если пустой узел - выходим.
                if node == nil {
                    return
                }
                // Новый (склонированный) узел.
                newNode := new(Node)
                newNode.Val = node.Val
                // Добавляем новый узел в мапу, чтобы посещать старый узел только один раз.
                visitedNodes[node] = newNode
                // Пробегаемся по соседям.
                for _, neighbour := range node.Neighbors {
                    // Обходим одного соседа только один раз иначе будут циклы.
                    if _, isExist := visitedNodes[neighbour]; !isExist {
                        dfs(neighbour)
                    }
                    // Добавляем соседа в массив соседей нового узла.
                    newNode.Neighbors = append(newNode.Neighbors, visitedNodes[neighbour])
                }
            }
            dfs(node)
            
            return visitedNodes[node]
        }
        
        type Node struct {
        	Val int
        	Neighbors []*Node
        }
        ```
        
    - Решение 2 (оптимальное). [Обход в ширину](https://www.notion.so/BFS-f8bbec2db02f4e988f8572172b320ee8?pvs=21) итеративно.
        - Обходим в ширину.
        - Записываем в мапу старый узел и новый узел, склонированный от старого.
        - Если сосед есть в мапе, то не обходим его второй раз.
        
        **Сложность: время - O(m+n), память - O(n)**, где m - количество ребер, n - количество узлов.
        
        ```go
        // Обход в ширину итеративно.
        func cloneGraph(node *Node) *Node {
            // Пустой граф - выходим.
            if node == nil {
                return nil
            }
            // Очередь для обхода в ширину. Слайс для упрощения, по хорошему нужен список.
            queue := []*Node{node}
            // Мапа с уже склонированными узлами. Ключ - старый узел, значение - новый узел.
            visited := make(map[*Node]*Node)
            // Добавляем текущий узел.
            visited[node] = &Node{Val: node.Val}
            // Пока в очереди есть узлы.
            for len(queue) > 0 {
                // Берем из очереди первый узел и "удаляем" его.
                node := queue[0]
                queue = queue[1:]
                // Получаем склонированный узел для текущего старого узла.
                // Склонировали мы внизу в цикле (или сверху самый первый узел).
                newNode := visited[node]
                // Бежим по соседям.
                for _, neigbor := range node.Neighbors { 
                    // Если соседа мы не обходили, то добавляем в очередь и в мапу.
                    if _, isExist := visited[neigbor]; !isExist {
                        queue = append(queue, neigbor)
                        visited[neigbor] = &Node{Val: neigbor.Val}
                    }
                    // Добавляем соседа из мапы.
                    newNode.Neighbors = append(newNode.Neighbors, visited[neigbor])
                }
            }
        
            return visited[node]
        }
        
        type Node struct {
        	Val int
        	Neighbors []*Node
        }
        ```


- Расставить **курсы** в **порядке** их прохождения, если курсы **зависят** друг от друга (зависимости даны в виде пар)


    - Зависимости даны в виде пар
        
        [TODO: решить через рекурсию]
        
        [LeetCode: 210. Course Schedule II](https://leetcode.com/problems/course-schedule-ii)
        
        - Условие
            
            Дан двумерный массив пар чисел `prerequisites` в качестве определения зависимостей курсов и количество курсов `numCourses`. Пара `[a, b]` из `prerequisites` означает, что нужно пройти курс `b` перед курсом `a`, т.е. курс `a` зависит от курса `b`. Необходимо вернуть массив упорядоченных курсов. Если нельзя пройти все курсы, то вернуть пустой массив.
            
            Результирующий массив курсов может быть неуникальным.
            
        - Кейсы
            
            `numCourses = 2, prerequisites = [[1,0]]; res = [0,1];` - у нас 2 курса и нужно пройти сначала курс `0`, потом курс `1`
            
            `numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]; res = [0,2,1,3] || [0,1,2,3];` - курс `0` можно проходить первым, а курс `3` нужно проходить последним, т.к. он зависит от всех остальных курсов.
            
        - Решение 1 (оптимальное). [Топологическая сортировка](https://www.notion.so/ea017d3f20f648699f07aa5842093bd8?pvs=21) - [алгоритм Кана](https://www.notion.so/Kahn-55343373fa9949208822b1ad4fc4eba2?pvs=21) (используя [container/list](https://www.notion.so/container-list-draft-e0ddecc1fff94001b1cff3ea1dab5d31?pvs=21) для очереди) ([BFS](https://www.notion.so/BFS-f8bbec2db02f4e988f8572172b320ee8?pvs=21)).
            
            [TODO: добавить пошаговый разбор]
            
            - Визуализация
                
                Считаем, что когда A зависит от B, то ребро для A входящее, для B исходящее.
                
                ![123123.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/123123.jpg)
                
            - Находим узлы, у которых нет входящих ребер, записываем их в очередь в любом порядке.
            - В цикле начинаем обрабатывать узлы из очереди `queue`. Для каждого узла из очереди обходим соседей и добавляем в очередь, если у него нет входящих ребер.
            
            **Сложность: время - O(n + p), память - O(n + p).** n - количество узлов (курсов), p - количество зависимостей в `prerequisites` (ребер). **В Joom-е сказали, что тут будет квадратичная сложность.**
            
            ```go
            // Топологическая сортировка - алгоритм Кана.
            func findOrder(numCourses int, prerequisites [][]int) []int {
                // Маппинг зависящих узлов.
                // Индекс - курс, от которого зависят другие курсы.
                // Значение - курсы, которые зависят от индексного курса.
                depCourses := make([][]int, numCourses)
                // Количество курсов, от которых зависит индексный курс (количество входящих ребер) - счетчики курсов
                depCount := make([]int, numCourses)
                // Результирующий массив с курсами.
                var res []int
                // Очередь для курсов, которые не зависят от других курсов - независимые курсы.
                queue := list.New()
                // Заполняем маппинг и счетчики.
                for _, coursesPair := range prerequisites {
                    depCourses[coursesPair[1]] = append(depCourses[coursesPair[1]], coursesPair[0])
                    depCount[coursesPair[0]]++
                }
                // Заполняем очередь независимых курсов.
                for i:=0; i < numCourses; i++ {
                    if depCount[i] == 0 {
                        queue.PushBack(i)
                    }
                }
                for queue.Len() > 0 {
                    // Берем независимый курс с начала очереди.
                    // Кладем его в результирующий массив и удаляем из очереди.
                    indepCourse := queue.Front().Value.(int)
                    res = append(res, indepCourse)
                    queue.Remove(queue.Front())
                    // Обходим все зависящие курсы.
                    for _, course := range depCourses[indepCourse] {
                        // Уменьшаем счетчик зависимостей для курса.
                        // Если зависимостей больше нет, то добавляем его в очередь.
                        depCount[course]--
                        if depCount[course] == 0 {
                            queue.PushBack(course)
                        }
                    }
                }
                // Если остались зависимые узлы (которые мы не обработали), то курсы зацикленны.
                if len(res) == numCourses {
                    return res
                }
                return []int{}
            }
            ```
            
            - Если в качестве входного массива зависимости инвертированы:
                
                `[A: [B,C], C: [D], B: [], D: []]` - `A` зависит от `B`, `C`; `C` зависит от `D`.
                
                [TODO: протестировать решение].
                
                ```go
                // Если 
                func sort(deps map[string][]string) []string {
                    depCount := make(map[string]int, len(deps))
                    depPacks := make(map[string][]string, len(deps))
                    queue := list.New()
                    for pack1, packs := range deps {
                        for _, pack2 := range packs {
                            depPacks[pack2] = append(depPacks[pack2], pack1)
                            depCount[pack2]++
                        }
                        if len(packs) == 0 {
                            queue.PushBack(pack1)
                        }
                    }
                    res := []string
                    for queue.Len() > 0 {
                        indepPack := queue.Front().Value.(string)
                        res = append(res, indepPack)
                        queue.Remove(queue.Front())
                        for _, pack := range depPacks[indepPack] {
                            depCount[pack]--
                            if depCount[pack] == 0 {
                                queue.PushBack(pack)
                            }
                        }
                    }
                    if len(res) == len(deps) {
                        return res
                    }
                    
                    return []string
                }
                ```
                
        - Решение 2. [Топологическая сортировка](https://www.notion.so/ea017d3f20f648699f07aa5842093bd8?pvs=21) - [DFS](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) через рекурсию. TODO.
            
            **Сложность: время - O(n + p), память - O(n + p).** n - количество узлов (курсов), p - количество зависимостей в `prerequisites` (ребер)
            
            ```go
            
            ```


## Финансовые

- **Реализовать банкомат** (пополнение, снятие)

  [LeetCode: 2241. Design an ATM Machine](https://leetcode.com/problems/design-an-atm-machine)

    - Условие

      Нужно спроектировать банкомат, который реализует методы пополнения и снятия денег.

      В обращении доступны 5 купюр номиналами `20`, `50`, `100`, `200`, `500`.

      Метод для пополнения - `Deposit(banknotesCount []int)`. На входе массив с количеством купюр каждого номинала. Например, массив `[0,1,0,1,1]` означает, что были получены купюры: 20 - 0шт, 50 - 1шт, 100 - 0шт, 200 - 1шт, 500 - 1шт.

      Метод для снятия `Withdraw(amount int) []int`. На входе сумма для снятия, на выходе аналогичный методу `Deposit` массив с количеством каждой купюры. Выдавать купюры необходимо с наибольшим количеством максимальных купюр. Если невозможно выдать сумму, то возвращаем `[-1]`.

    - Кейсы

      `operations = ["ATM", "deposit", "withdraw", "deposit", "withdraw", "withdraw"]; values = [[], [[0,0,1,2,1]], [600], [[0,1,0,1,1]], [600], [550]]; res= [null, null, [0,0,1,0,1], null, [-1], [0,1,0,0,1]]`

    - Решение 1. Хэш-таблица.

      **Сложность: время - O(n), память - O(n).**

        ```go
        type ATM struct {
            // Мапа для хранения количества оставшизся купюр.
            // Ключ - купюра, значение - количество
            banknotesAvailable map[int]int
            // Маппинг индекс массива -> купюра
            mapping [5]int
        }
        
        func Constructor() ATM {
            return ATM{
                banknotesAvailable : make(map[int]int, 5),
                mapping : [5]int{0: 20, 1: 50, 2: 100, 3: 200, 4: 500},
            }
        }
        
        func (this *ATM) Deposit(banknotesCount []int)  {
            // С помощью маппинга сопоставляем индекс и купюру и увеличиваем количество нужных купюр.
            for banknoteIdx, count := range banknotesCount {
                this.banknotesAvailable[this.mapping[banknoteIdx]] += count
            }
        }
        
        func (this *ATM) Withdraw(amount int) []int {
            // Результирующий массив.
            banknotesWithdraw := make([]int, 5, 5)
            // Новая мапа для оставшихся купюр.
            // Нужна, т.к. в конце мы можем понять, что нам не хватило купюр, чтобы выдать деньги.
            // В этом случае нужно откатить транзакцию.
            banknotesNew := make(map[int]int, 5)
            // Идем с большой купюры к маленькой.
            for i := len(this.mapping) - 1; i >= 0; i-- {
                // Номинал банкноты.
                banknote := this.mapping[i]
                // Остаток по банкноте.
                availableCount := this.banknotesAvailable[banknote]
                // Заполняем новую мапу.
                banknotesNew[banknote] = availableCount
                // Банкнота должна быть меньше входящей суммы.
                if amount < banknote || availableCount == 0 {
                    continue
                }
                // Вычисляем необходимое количество для текущей банкноты.
                needCount := int(math.Floor(float64(amount) / float64(banknote)))
                // Если остаток по банкноте меньше чем необходимо берем весь доступный остаток.
                if availableCount < needCount {
                    needCount = availableCount
                }
                // Уменьшаем остаток по банкноте.
                banknotesNew[banknote] -= needCount
                // Уменьшаем сумму.
                amount -= needCount * banknote
                // Добавляем количество по банкноте в результирующий массив.
                banknotesWithdraw[i] = needCount
            }
        
            // Не смогли набрать сумму.
            if amount > 0 {
                return []int{-1}
            }
        
            // Актуализируем остатки по банкнотам.
            this.banknotesAvailable = banknotesNew
        
            return banknotesWithdraw
        }
        
        /**
         * Your ATM object will be instantiated and called as such:
         * obj := Constructor();
         * obj.Deposit(banknotesCount);
         * param_2 := obj.Withdraw(amount);
         */
        ```


## Технические

- Реализовать **LRU cache**

  [LeetCode: 146. LRU Cache](https://leetcode.com/problems/lru-cache)

    - Условие

      Необходимо реализовать LRU кэш.

      Методы:

        - `int get(int key)` - возвращает значение по ключу `key` или `1` если ключ не найден.
        - `void put(int key, int value)` - обновляет значение по ключу `key` если ключ найден. В случае, если ключа нет, добавляет значение. Если количество элементов превышено, удалить **самый неиспользуемый элемент**.
    - Решение 1. Map + container/list

        ```go
        type LRUCache struct {
            cache map[int]*list.Element
            linklist *list.List
            capacity int
        }
        
        func Constructor(capacity int) LRUCache {
            return LRUCache{
                cache: make(map[int]*list.Element, capacity),
                linklist: list.New(),
                capacity: capacity,
            }
        }
        
        // 0 is key and 1 is value
        func (this *LRUCache) Get(key int) int {
            if _, ok := this.cache[key]; !ok {
                return -1
            }
            elem := this.cache[key]
            this.linklist.MoveToFront(elem)
            return elem.Value.([]int)[1]
        }
        
        func (this *LRUCache) Put(key int, value int)  {
            // if capacity reached
            if elem, ok := this.cache[key]; ok {
                this.linklist.Remove(elem)
                newelem := this.linklist.PushFront([]int{key, value})
                this.cache[key] = newelem
                return
            }
            if len(this.cache) == this.capacity {
                elem := this.linklist.Back()
                v := this.linklist.Remove(elem)
                delete(this.cache, v.([]int)[0])
            }
            newelem := this.linklist.PushFront([]int{key, value})
            this.cache[key] = newelem
        }
        ```

    - Решение 2. Map + list
        - Визуализация

          ![d6c009_ec45720e27754cfe9f565f2bddbb9318~mv2.webp](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/d6c009_ec45720e27754cfe9f565f2bddbb9318mv2.webp)


        ```go
        // Элемент.
        type Element struct {
            // Указатель на предыдущий элемент, движение к tail.
            prev *Element
            // Указатель на следующий элемент, движение к head.
            next *Element
            // Ключ элемента.
            key int
            // Значение элемента.
            value int
        }
        
        // В основе двусвязный список и хэш-таблица.
        type LRUCache struct {
            // Самый частоиспользуемы элемент (первый).
            head *Element
            // Самый редкоиспользуемый элемент (последний).
            tail *Element
            // Вместимость.
            cap int
            // Мапа для поиска элемента по ключу за O(1). Без нее надо перебирать список.
            elements map[int]*Element
        }
        
        func Constructor(capacity int) LRUCache {
            return LRUCache{cap: capacity, elements: make(map[int]*Element, capacity)}
        }
        
        func (c *LRUCache) Get(key int) int {
            target, isExist := c.elements[key]
            // Элемента нет - выходим.
            if !isExist {
                return -1
            }
            // Если целевой элемент первый в списке, то не делаем перестановок.
            if target == c.head {
                return target.value
            }
            // Вынимаем целевой элемент из списка.
            if target.prev != nil {
                target.prev.next = target.next
            }
            if target.next != nil {
                target.next.prev = target.prev
                // Целевой элемент был последний,
                // нужно заменить хвостовой элемент.
                if target == c.tail {
                    c.tail = target.next
                }
            }
        
            // Ставим целевой элемент на первое место.
            if c.head != nil && len(c.elements) >= 2 {
                target.next = nil
                target.prev = c.head
                c.head.next = target
                c.head = target
            }
        
            return target.value
        }
        
        func (c *LRUCache) Put(key int, value int)  {
            target, isExist := c.elements[key]
            // Целевой элемент уже есть в кэше.
            if isExist {
                target.value = value
                // Если целевой элемент первый в списке, то не делаем перестановок.
                if target == c.head {
                    return
                }
                // вынимаем целевой элемент из списка
                if target.prev != nil {
                    target.prev.next = target.next
                }
                if target.next != nil {
                    target.next.prev = target.prev
                    // Целевой элемент был последний,
                    // нужно заменить хвостовой элемент.
                    if target == c.tail {
                        c.tail = target.next
                    }
                }
            } else { // Целевой элемент нужно добавить в кэш.
                target = &Element{key: key, value: value}
                // Добавляем новый элемент в мапу.
                c.elements[key] = target
                // Превышаем лимит по кол-ву элементов.
                if len(c.elements) > c.cap {
                    // Удаляем хвостовой элемент из мапы.
                    delete(c.elements, c.tail.key)
                    // Если больше одного элемента - переставим хвостовой.
                    if len(c.elements) >= 2 {
                        c.tail = c.tail.next
                        c.tail.prev = nil
                    }
                }
            }
        
            // Ставим целевой элемент на первое место.
            if c.head != nil && len(c.elements) >= 2 {
                target.next = nil
                target.prev = c.head
                c.head.next = target
                c.head = target
            } else {
                // Если вставился первый элемент - вставим головной и хвостовой.
                c.head = target
                c.tail = target
            }
        }
        
        /**
         * Your LRUCache object will be instantiated and called as such:
         * obj := Constructor(capacity);
         * param_1 := obj.Get(key);
         * obj.Put(key,value);
         */
        ```


- **Нормализация файлового пути**

  [LeetCode: 71. Simplify Path](https://leetcode.com/problems/simplify-path)

    - Условие

      На входе строка с абсолютным файловым путем (для Unix). Нужно преобразовать ее в нормализованный файловый путь. Нормализованный файловый путь - уникальный путь для каждого файла или папки. Такие пути можно сравнивать между собой.

      Формат нормализованного пути:

        - путь начинается с `/`
        - `/` является разделителем директорий
        - в конце пути не должно быть `/`
        - допустимые символы для директорий - буквы, цифры, `_`, больше двух точек

      Формат абсолютного пути:

        - `.` - текущая директория
        - `..` - возврат к родительской директории
        - `/` - разделитель директорий, дублирование `//` - так же разделитель
    - Кейсы

      `path = "/home/"; res = "/home"`

      `path = "/../"; res = "/"`

      `path = "/home//foo/"; res = "/home/foo"`

    - Решение 1. Полный разбор пути вручную.

      **Сложность: время - O(n), память - O(n).**

        ```go
        func simplifyPath(path string) string {
            // "."       => пропускаем;
            // ".."      => возвращаемся на уровень вверх;
            // дубли "/" => пропускаем
        
            // Массив директорий.
            var dirs [][]rune
            // Текущая операция (символы между двумя `/`).
            // Операция потому что не знаю как лучше назвать.
            var operation []rune
            // Выходим за рамки строки, чтобы обработать последнюю операцию.
            for i := 0; i <= len(path); i++ {
                // Если это последняя операция, то добавим заключительную косую,
                // чтобы точно обработать операцию.
                char := '/'
                if i < len(path) {
                    char = rune(path[i])
                }
        
                // Дубли '/' - пропускаем.
                if char == '/' && len(operation) == 0 {
                    continue
                }
                // Какая-то операция завершилась.
                if char == '/' {
                    // Поднимаемся на уровень вверх.
                    if len(operation) == 2 && operation[0] == '.' && operation[1] == '.' {
                        // Убираем последнюю директорию, если есть.
                        if len(dirs) > 0 {
                            dirs = dirs[:len(dirs)-1]
                        }
                        operation = nil
                        continue
                    }
                    // '.' - остаемся в текущей директории (пропускаем).
                    if len(operation) == 1 && operation[0] == '.' {
                        operation = nil
                        continue
                    }
                    // Завершилась директория - записываем ее.
                    dirs = append(dirs, operation)
                    operation = nil
                    continue
                }
                // Добавляем символ в операцию.
                operation = append(operation, char)
            }
        
            // Кейс когда не осталось ни одной директории - должна быть косая.
            if len(dirs) == 0 {
                return "/"
            }
        
            // Складываем директории в строку.
            var resPath []rune
            for _, d := range dirs {
                resPath = append(resPath, '/')
                resPath = append(resPath, d...)
            }
        
            return string(resPath)
        }
        ```

    - Решение 2. Разбиение и склеивание по слэшам + перебор.

      **Сложность: время - O(n), память - O(n).**

        ```go
        // strings.Split + strings.Join
        func simplifyPath(path string) string {
        		// "."       => пропускаем;
            // ".."      => возвращаемся на уровень вверх;
            // дубли "/" => пропускаем
        
            // Парсим строку в массив потенциальных директорий.
            objects := strings.Split(path, "/")
            // "Чистые" директории.
            var canonicalDirs []string
            // Очищаем директории.
            for _, object := range objects {
                // Если слэш дублируется объект будет пустой.
                // Если объект слэш или точка, пропускаем.
                if len(object) == 0 || object == "." {
                    continue
                }
                // Если объект не двоеточние, то это точно директория.
                if object != ".." {
                    canonicalDirs = append(canonicalDirs, object)
                // Если есть родительские директории, обрабатываем двоеточие.
                } else if len(canonicalDirs) > 0 {
                    // Переходим на директорию вверх.
                    canonicalDirs = canonicalDirs[:len(canonicalDirs) - 1]
                }
            }
        
            // Склеиваем директории в нормализованный путь
            return "/" + strings.Join(canonicalDirs, "/")
        }
        ```


- Реализовать общий **счетчик запросов**

  [LeetCode: 362. Design Hit Counter](https://leetcode.com/problems/design-hit-counter)

    - Условие

      Реализовать счетчик запросов, который считает запросы за последние 5 минут.

      Т.е. нужно заимлементить 3 метода:

        - `HitCounter()` - конструктор.
        - `void hit(int timestamp)` - записывает текущий запрос, с меткой времени `timestamp` (в секундах). Несколько запросов могут придти в одно время.
        - `int getHits(int timestamp)` - возвращает количество запросов за последние 5 минут (300 сек) начиная со времени `timestamp`.

      Вызовы методов `hit()` и `getHits()` происходят в хронологическом порядке.

    - Кейсы

      `methods = ["HitCounter", "hit", "hit", "hit", "getHits", "hit", "getHits", "getHits"],`
      `parameters = [[], [1], [2], [3], [4], [300], [300], [301]];`
      `res = [null, null, null, null, 3, null, 4, 3];`

    - Решение 1 (не самое оптимальное). [Односвязный список](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21).

      **Список в данном случае будет не намного эффективнее слайса по памяти, т.к. массив слайса при переполнении удаляется.**

      `hit()`

      Добавляем в связный список узел (время запроса, количество запросов).

      `getHits()`

      Бежим по списку либо до окончания списка либо по ограничению 300 сек и считаем количество запросов в узлах списка.

      **Сложность: время - hit(): O(1), getHits(): O(n), память - O(n).**

        ```go
        type HitCounter struct {
            last *node
        }
        
        func Constructor() HitCounter {
            return HitCounter{}
        }
        
        func (this *HitCounter) Hit(timestamp int)  {
            // Если последний узел с таким же временем, то добавим в него.
            if this.last != nil && this.last.timestamp == timestamp {
                this.last.count++
            } else { // Иначе создадим новый узел.
                this.last = &node{
                    timestamp: timestamp,
                    count: 1,
                    prev: this.last,
                }
            }
        }
        
        func (this *HitCounter) GetHits(timestamp int) int {
            // Текущий узел (бегунок).
            cur := this.last
            // Результирующее количество.
            count := 0
            // Пока список не кончится.
            for cur != nil {
                // Если мы вышли за рамки диапазона времени - выходим.
                if cur.timestamp <= timestamp - 300 {
                    // Вместо обнуления, затираем ссылку на прошлый узел, GC сам почистит.
                    cur.prev = nil
                    break
                }
                // Увеличиваем счетчик.
                count += cur.count
                // Смещаем бегунок на предыдущий узел.
                cur = cur.prev
            }
        
            return count
        }
        
        // Узел связного списка (очереди).
        // Связный список используется для хранения хитов.
        // TODO: более оптимально использовать кольцевой буфер.
        type node struct {
            // Время, сек
            timestamp int
            // Количество хитов за текущую секунду
            count int
            // Ссылка на прошлый узел.
            prev *node
        }
        
        /**
         * Your HitCounter object will be instantiated and called as such:
         * obj := Constructor();
         * obj.Hit(timestamp);
         * param_2 := obj.GetHits(timestamp);
         */
        ```

    - Решение 2 (оптимальное). Слайс в качестве двусторонней очереди.

      `hit()`

      `getHits()`

      **Сложность: время - hit(): O(1), getHits(): ?, память - O(n).**

        ```go
        
        ```


## Стек, очередь

- Реализовать **очередь** используя **стеки**

  [LeetCode: 232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks)

    - Условие

      Реализовать очередь используя два стека.

      Необходимые методы:

        - `void push(int x)` - помещает элемент в конец очереди.
        - `int pop()` - возвращает элемент с начала очереди и удаляет его.
        - `int peek()` возвращает элемент с начала очереди (без удаления).
        - `boolean empty()` - проверяет есть ли в очереди элементы.

      Можно использовать только стандартные методы стека.

      Вместо стека можно использовать список.

      **Необходимо, чтобы каждый метод выполнялся за O(1).**

    - Кейсы

      `operations = ["MyQueue", "push", "push", "peek", "pop", "empty"];`
      `parameters = [[], [1], [2], [], [], []];`
      `res = [null, null, null, 1, 1, false];`

    - Решение 1. [Односвязный список](https://www.notion.so/a9579c5261694028aee666369925d1dc?pvs=21).

      **Сложность: время любой операции - O(1), общая память - O(n).**

        ```go
        type (
            // Элемент односвязного списка.
            Node struct {
                val int
                next *Node
            }
            // Односвязный список.
            MyQueue struct {
                // Если список пустой - head, tail == nil
                head *Node
                tail *Node
            }
        )
        
        func Constructor() MyQueue {
            return MyQueue{}
        }
        // Добавляем элемент в конец. O(1).
        func (this *MyQueue) Push(x int)  {
            // Добавляем в конец списка.
            el := &Node{val: x}
            // Если список пустой - инициализируем начальный и хвостовой элементы.
            if this.Empty() {
                this.tail, this.head = el, el
            } else {
                // Если список не пустой - добавляем элемент в конец.
                // Переназначаем предпоследний элемент.
                this.tail.next = el
                // Переназначаем хвостовой элемент.
                this.tail = el
            }
        }
        // Берем элемент с начала и удалаяем его. O(1).
        func (this *MyQueue) Pop() int {
            // Список не пуст.
            if !this.Empty() {
                head := this.head
                // Переназначаем второй элемент как начальный.
                this.head = this.head.next
                // Если начальный элемент (бывший второй элемент) пустой -
                // хвостовой элемент тоже делаем пустым.
                if this.head == nil {
                    this.tail = nil
                }
                return head.val
            }
            // Список пуст.
            return 0
        }
        // Берем элемент с начала (без удаления). O(1).
        func (this *MyQueue) Peek() int {
            // Если начальный элемент не пустой - возвращаем.
            if !this.Empty() {
                return this.head.val
            }
            return 0
        }
        // Пустая ли очередь. O(1).
        func (this *MyQueue) Empty() bool {
            if this.head == nil {
                return true
            }
            return false
        }
        
        /**
         * Your MyQueue object will be instantiated and called as such:
         * obj := Constructor();
         * obj.Push(x);
         * param_2 := obj.Pop();
         * param_3 := obj.Peek();
         * param_4 := obj.Empty();
         */
        ```

    - Решение 2. Два [стека](https://www.notion.so/8c2aa09cb4994480a7b115d6eee03a49?pvs=21) (два [слайса](https://www.notion.so/Slice-55f37cf314514dfc849d08453f4e0a46?pvs=21)).

      **Сложность: время любой операции - O(1), общая память - O(n).**

        ```go
        // Два стека.
        type MyQueue struct {
            // Стек для добавления элементов (свежие элементы в начале).
            stackPush []int
            // Стек для получения элементов (свежие элементы в конце).
            stackPop []int
        }
        func Constructor() MyQueue {
            return MyQueue{}
        }
        // Добавляем элемент в конец. O(1).
        func (this *MyQueue) Push(x int)  {
            // Добавляем элемент в стек для добавления элементов.
            this.stackPush = append(this.stackPush, x)
        }
        // Берем элемент с начала и удалаяем его. O(1).
        func (this *MyQueue) Pop() int {
            // Достаем самый старый элемент.
            el := this.Peek()
            // Удаляем последний элемент из стека для получения.
            // TODO: если в очереди нет элементов - будет ошибка.
            this.stackPop = this.stackPop[:len(this.stackPop)-1]
            return el
        }
        // Берем элемент с начала (без удаления). O(1)-O(n).
        func (this *MyQueue) Peek() int {
            // Если стек для получения пуст - переместим все элементы из стека для добавления.
            if len(this.stackPop) == 0 {
                for len(this.stackPush) != 0 {
                    this.stackPop = append(
                        this.stackPop,
                        this.stackPush[len(this.stackPush)-1],
                    )
                    this.stackPush = this.stackPush[:len(this.stackPush)-1]
                }
            }
            // TODO: если в очереди нет элементов - будет ошибка.
            return this.stackPop[len(this.stackPop)-1]
        }
        /** Returns whether the queue is empty. */
        func (this *MyQueue) Empty() bool {
            return len(this.stackPush) == 0 && len(this.stackPop) == 0
        }
        /**
         * Your MyQueue object will be instantiated and called as such:
         * obj := Constructor();
         * obj.Push(x);
         * param_2 := obj.Pop();
         * param_3 := obj.Peek();
         * param_4 := obj.Empty();
         */
        ```


- Реализовать **минимальный стек**

  [LeetCode: 155. Min Stack](https://leetcode.com/problems/min-stack)

    - Условие

      Реализовать стек с получением минимального элемента в стеке.

      Необходимые методы:

        - `void push(int val)` - помещает элемент в конец стека.
        - `int pop()` - удаляет элемент с конца стека.
        - `int top()` возвращает элемент с конца стека (без удаления).
        - `int getMin()` - возвращает минимальный элемент стека.

      **Необходимо, чтобы каждый метод выполнялся за O(1).**

    - Кейсы

      `operations =` `["MinStack","push","push","push","getMin","pop","top","getMin"];`
      `parameters =` `[[],[-2],[0],[-3],[],[],[],[]];`
      `res =` `[null,null,null,null,-3,null,0,-2];`

    - **Решение 1 (оптимальное). Хранение минимального значения в элементе.**

      Для каждого элемента добавляем минимальное значение.

        - Пример

            ```
            push   min  compare       stack
            ----   ---  -------       -----
             12     12  **12 < 12**       [{12,**12**}]
             30     12  30 < 12       [{12,12},{30,12}]
              7      7   **7 < 12**       [{12,12},{30,12},{7,**7**}]
              6      6   **6 < 7**        [{12,12},{30,12},{7,7},{6,**6**}]
             45      6  45 < 6        [{12,12},{30,12},{7,7},{6,6},{45,6}]
              2      2   **2 < 6**        [{12,12},{30,12},{7,7},{6,6},{45,6},{2,**2**}]
             27      2  27 < 2        [{12,12},{30,12},{7,7},{6,6},{45,6},{2,2},{27,2}]
             15      2  15 < 2        [{12,12},{30,12},{7,7},{6,6},{45,6},{2,2},{27,2},{15,2}]
            ```

          ![stack_with_mins.png](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/stack_with_mins.png)


        **Сложность: время любой операции - O(1), общая память - O(n).**
        
        ```go
        // Смысл в том, что мы с каждым значением храним минимум для всех элементов
        // с начала стека до текущего элемента.
        // При добавлении элемента смотрим, если текущее значение меньше минимума,
        // то устанавливаем для текущего значения новый минимум (текущее значение).
        // Если текущее значение больше минимума, то минимум для текущего элемента остается.
        // Элемент стека.
        type stackVal struct {
            val int // значение
            min int // минимальное значение для текущего элемента
        }
        
        type MinStack struct {
            // Слайс в качестве стека.
            stack []stackVal
        }
        
        func Constructor() MinStack {
            return MinStack{}
        }
        
        // O(1)
        func (this *MinStack) Push(val int)  {
            // Минимальное значение, которое нужно установить в добавляемый элемент.
            min := val
            // Если стек не пуст.
            if len(this.stack) > 0 {
                // Берем минимальное значение последнего элемента.
                lastMin := this.GetMin()
                // Если добавляемое значение меньше прошлого минимального -
                // выставляем минимум для добавляемого элемента само значение.
                if lastMin < min {
                    min = lastMin
                }
            }
            // Добавляем элемент в конец.
            this.stack = append(this.stack, stackVal{val:val, min:min})
        }
        
        // O(1)
        func (this *MinStack) Pop()  {
            // Если стек не пуст удаляем последний элемент.
            if len(this.stack) > 0 {
                this.stack = this.stack[:len(this.stack) - 1]
            }
        }
        
        // O(1)
        func (this *MinStack) Top() int {
            // Если стек не пуст возвращаем последнее значение.
            if len(this.stack) > 0 {
                return this.stack[len(this.stack) - 1].val
            }
            return 0
        }
        
        // O(1)
        func (this *MinStack) GetMin() int {
            // Если стек не пуст возвращаем минимальное значение из последнего элемента.
            if len(this.stack) > 0 {
                return this.stack[len(this.stack) - 1].min
            }
            return 0
        }
        
        /**
         * Your MinStack object will be instantiated and called as such:
         * obj := Constructor();
         * obj.Push(val);
         * obj.Pop();
         * param_3 := obj.Top();
         * param_4 := obj.GetMin();
         */
        ```
        
    - Решение 2 (оптимальное). Два [стека](https://www.notion.so/8c2aa09cb4994480a7b115d6eee03a49?pvs=21). TODO.
        
        **Сложность: время любой операции - O(1), общая память - O(n).**
        
        ```go
        
        ```


## Жизненные

## Зависимости

- Полезное
    - Усложнение. TODO.

      Что если нам нужно дополнительно вывести циклические зависимости.

    - Отличия решений
        - Ссылки

          [Youtube: Techdose: Kahn's algorithm | Topological sort | Course schedule 2 | Leetcode #210](https://www.youtube.com/watch?v=tggiFvaxjrY)

- Проверить можно ли пройти все курсы, если курсы **зависят** друг от друга (зависимости даны в виде пар)

  [TODO: решить через рекурсию]

  [LeetCode: 207. Course Schedule](https://leetcode.com/problems/course-schedule/)

    - Условие

      Дан двумерный массив пар чисел `prerequisites` в качестве определения зависимостей прохождения курсов и количество курсов `numCourses`. Пара `[a, b]` из `prerequisites` означает, что нужно пройти курс `b` перед курсом `a`, т.е. курс `a` зависит от курса `b`. Необходимо проверить можно ли пройти все курсы. Т.е. нет ли циклических зависимостей между курсами.

    - Кейсы

      `numCourses = 2, prerequisites = [[1,0]]; res = true;` - у нас 2 курса и нужно пройти сначала курс `0`, потом курс `1`

      `numCourses = 2, prerequisites = [[1,0],[0,1]]; res = false;` - здесь циклическая зависимость между курсами

      `numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]; res = true;` - курс `0` можно проходить первым, а курс `3` нужно проходить последним, т.к. он зависит от всех остальных курсов.

    - Решение 1 (оптимальное). [Топологическая сортировка](https://www.notion.so/ea017d3f20f648699f07aa5842093bd8?pvs=21) - [алгоритм Кана](https://www.notion.so/Kahn-55343373fa9949208822b1ad4fc4eba2?pvs=21) (используя [container/list](https://www.notion.so/container-list-draft-e0ddecc1fff94001b1cff3ea1dab5d31?pvs=21) для очереди) ([BFS](https://www.notion.so/BFS-f8bbec2db02f4e988f8572172b320ee8?pvs=21)).

      [TODO: добавить пошаговый разбор]

        - Визуализация

          ![123123.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/123123.jpg)


        **Считаем, что когда A зависит от B, то ребро для A входящее, для B исходящее.**
        
        - Находим узлы, у которых нет входящих ребер, записываем их в очередь в любом порядке.
        - В цикле начинаем обрабатывать узлы из очереди `queue`. Для каждого узла из очереди обходим соседей и добавляем в очередь, если у него нет входящих ребер.
        
        **Сложность: время - O(n + p), память - O(n + p).** n - количество узлов (курсов), p - количество зависимостей в `prerequisites` (ребер)
        
        ```go
        // Топологическая сортировка - алгоритм Кана.
        func canFinish(numCourses int, prerequisites [][]int) bool {
            // Маппинг зависящих узлов.
            // Индекс - курс, от которого зависят другие курсы.
            // Значение - курсы, которые зависят от индексного курса.
            depCourses := make([][]int, numCourses)
            // Количество курсов, от которых зависит индексный курс (количество входящих ребер) - счетчики курсов
            depCount := make([]int, numCourses)
            // Счетчик зависимостей (узлы, которые мы посетили).
            visitedCount := 0
            // Очередь для курсов, которые не зависят от других курсов - независимые курсы.
            queue := list.New()
            // Заполняем маппинг и счетчики.
            for _, coursesPair := range prerequisites {
                depCourses[coursesPair[1]] = append(depCourses[coursesPair[1]], coursesPair[0])
                depCount[coursesPair[0]]++
            }
            // Заполняем очередь независимых курсов.
            for i:=0; i < numCourses; i++ {
                if depCount[i] == 0 {
                    queue.PushBack(i)
                }
            }
            for queue.Len() > 0 {
                // Берем независимый курс с начала очереди.
                // Кладем его в результирующий массив и удаляем из очереди.
                indepCourse := queue.Front().Value.(int)
                visitedCount++
                queue.Remove(queue.Front())
                // Обходим все зависящие курсы.
                for _, course := range depCourses[indepCourse] {
                    // Уменьшаем счетчик зависимостей для курса.
                    // Если зависимостей больше нет, то добавляем его в очередь.
                    depCount[course]--
                    if depCount[course] == 0 {
                        queue.PushBack(course)
                    }
                }
            }
            // Если остались зависимые узлы (которые мы не обработали), то курсы зацикленны.
            return visitedCount == numCourses
        }
        ```
        
    - Решение 2. [Топологическая сортировка](https://www.notion.so/ea017d3f20f648699f07aa5842093bd8?pvs=21) - [DFS](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) через рекурсию. TODO.
        
        **Сложность: время - O(n + p), память - O(n + p).** n - количество узлов (курсов), p - количество зависимостей в `prerequisites` (ребер)
        
        ```go
        
        ```


- Расставить программные **пакеты** в **порядке** их установки, если пакеты **зависят** друг от друга (зависимости даны в виде словаря)

  [TODO: решить через рекурсию]

  [TODO: найти в задачниках]

    - Условие

      Дан словарь в качестве определения зависимостей пакетов `deps`. Ключ словаря - пакет, значение - массив пакетов, от которых зависит пакет по ключу. Необходимо вернуть массив упорядоченных пакетов. Если нельзя установить все пакеты, то вернуть пустой массив.

      Результирующий массив пакетов может быть неуникальным.

    - Кейсы

      `[A: [B,C], C: [D], B: [], D: []]; res = [B,C,D,A]` - `A` зависит от `B`, `C`; `C` зависит от `D`.

    - Решение 1 (оптимальное). [Топологическая сортировка](https://www.notion.so/ea017d3f20f648699f07aa5842093bd8?pvs=21) - [алгоритм Кана](https://www.notion.so/Kahn-55343373fa9949208822b1ad4fc4eba2?pvs=21) (используя [container/list](https://www.notion.so/container-list-draft-e0ddecc1fff94001b1cff3ea1dab5d31?pvs=21) для очереди) ([BFS](https://www.notion.so/BFS-f8bbec2db02f4e988f8572172b320ee8?pvs=21)).

      [TODO: добавить пошаговый разбор]

      [TODO: протестировать и добавить комменты по коду.]

        - Находим узлы, у которых нет входящих ребер, записываем их в очередь в любом порядке.
        - В цикле начинаем обрабатывать узлы из очереди `queue`. Для каждого узла из очереди обходим соседей и добавляем в очередь, если у него нет входящих ребер.

      **Сложность: время - O(n + p), память - O(n + p).** n - количество узлов (курсов), p - количество зависимостей в `prerequisites` (ребер). **В Joom-е сказали, что тут будет квадратичная сложность.**

        ```go
        // TODO: протестировать и добавить комменты по коду.
        func sort(deps map[string][]string) []string {
            depCount := make(map[string]int, len(deps))
            depPacks := make(map[string][]string, len(deps))
            queue := list.New()
            for pack1, packs := range deps {
                for _, pack2 := range packs {
                    depPacks[pack2] = append(depPacks[pack2], pack1)
                    depCount[pack2]++
                }
                if len(packs) == 0 {
                    queue.PushBack(pack1)
                }
            }
            res := []string
            for queue.Len() > 0 {
                indepPack := queue.Front().Value.(string)
                res = append(res, indepPack)
                queue.Remove(queue.Front())
                for _, pack := range depPacks[indepPack] {
                    depCount[pack]--
                    if depCount[pack] == 0 {
                        queue.PushBack(pack)
                    }
                }
            }
            if len(res) == len(deps) {
                return res
            }
            
            return []string
        }
        ```

    - Решение 2. [Топологическая сортировка](https://www.notion.so/ea017d3f20f648699f07aa5842093bd8?pvs=21) - [DFS](https://www.notion.so/DFS-0aefbd3039ef4f12901497e6dac9f0b0?pvs=21) через рекурсию. TODO.

      **Сложность: время - O(n + p), память - O(n + p).** n - количество узлов (курсов), p - количество зависимостей в `prerequisites` (ребер)

        ```go
        
        ```


## Игровые

## Конкурентность

- Вычислить **общее время обработки** массива **задач** на `**k` обработчиках** учитывая **порядок** задач (**время в прачечной**)

  [Leetcode interview discuss: Tinkoff question](https://leetcode.com/discuss/interview-question/3352503)

    - Условие

      Дан целочисленный неотсортированный массив `jobs` и целочисленное `workers`. В `jobs` хранится время, необходимое для обработки каждой задачи. Количество воркеров задано в `workers`. Одна задача может обрабатываться одним воркером. Задачи должны обрабатываться по порядку, т.е. нельзя перескакивать с первой на последнюю задачу. Нужно найти минимальное время необходимое для обработки всех задач парралельно на воркерах.

        - Альтернативная формулировка

          Вы являетесь менеджером прачечной, в которой есть `k` стиральных машин. Верните общее время стирки для клиентов, если вы знаете время, затраченное каждым клиентом на одну стирку.

    - Кейсы

      `jobs = [1,1,1,1,1], workers = 1; res = 5;`

      `jobs = [2,2,1,2,1], workers = 2; res = 4;`

      `jobs = [7,6,5,4,3,2,1,1,2,3,4,5,6,7], workers = 5; res = 14;`

      `jobs = [5, 4, 2, 7, 8, 2, 6], workers = 3; res = 13;`

      `jobs = [1, 2, 4, 7, 8], workers = 2; res = 13;`

      `jobs = [5], workers = 2; res = 5;`

      `jobs = [], workers = 2; res = 0;`

    - Решение 1 (оптимальное и простое). [Минимальное куча](https://www.notion.so/heap-bbab5668199b473d957aca3403e85c2c?pvs=21) (приоритетная очередь).

      Для каждой джобы нам нужно находить воркер, который проработал минимальное количество времени и отдавать джобу этому воркеру.

        - Примеры:

          `q = [1, 2, 4, 7, 8], k = 2; res = 13;`

          `q = [5, 4, 2, 7, 8, 2, 6], k = 3; res = 13;`

          ![IMG_5455.jpg](%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%20dd650cdfec394840a4b21483998f5e07/IMG_5455.jpg)


        **Сложность: время - O(n*log(n)), память - O(n).**
        
        ```go
        func workersProcessTasks(jobs []int, workers int) int {
        	// Минимальная куча для хранения текущего затраченного времени по воркерам.
        	minHeap := make(minHeap, 0, len(jobs))
        	// Минимальное текущее время работы одного из воркеров.
        	workersMinTime := 0
        	// Результирующее максимальное количество времени.
        	res := 0
        	// Бежим по джобам.
        	for _, jobTime := range jobs {
        		// Нам нужно хранить элементов не больше чем воркеров,
        		// поэтому вынимаем минимально затраченное время одного из воркеров.
        		if minHeap.Len() == workers {
        			workersMinTime = heap.Pop(&minHeap).(int)
        		}
        		// Новое время воркера с учетом текущей джобы.
        		workerTime := jobTime + workersMinTime
        		heap.Push(&minHeap, workerTime)
        		// Если время воркера больше максимального - перезаписываем.
        		if workerTime > res {
        			res = workerTime
        		}
        	}
        
        	return res
        }
        
        // Реализация минимальной кучи для container/heap.
        type minHeap []int
        func (w minHeap) Len() int {
        	return len(w)
        }
        func (w minHeap) Less(i, j int) bool {
        	return w[i] < w[j]
        }
        func (w minHeap) Swap(i, j int) {
        	w[i], w[j] = w[j], w[i]
        }
        func (w *minHeap) Pop() interface{} {
        	a := *w
        	n := len(a) - 1
        	v := a[n]
        	*w = a[:n]
        	return v
        }
        func (w *minHeap) Push(x interface{}) {
        	*w = append(*w, x.(int))
        }
        ```


## Реализации API

- Реализовать **счетчик запросов с агрегацией по пользователям**
    - Условие

      > Есть последовательность запросов, упорядоченная по времени. Запросы бывают двух видов:
      Пользователь user_id сгенерировал событие (нажал на красную кнопку).
      Посчитать количество пользователей, которые за последние 5 минут (`window`) сгенерировали >= 1000 (`limit`) событий (нажали на красную кнопку >= 1000 раз).
      Необходимо реализовать структуру данных, умеющую эффективно обрабатывать данные запросы.
      >

      Т.е. нужно реализовать 3 метода:

        - `NewUserStatistics(window time.Duration, limit int) *UserStatistics` - конструктор, в который передается временное окно `window`, за которое необходимо посчитать события и лимит по количеству событий на одного пользователя.
        - `AddEvent(now time.Time, userID int)` - записывает текущее событие, с меткой времени `now` и id пользователя  `userID`. Несколько запросов могут придти в одно время.
        - `GetRobotCount(now time.Time) int` - возвращает количество запросов за последние 5 минут (300 сек) начиная со времени `timestamp`.

      Вызовы методов `hit()` и `getHits()` происходят в хронологическом порядке.

    - Кейсы

      `methods = ["HitCounter", "hit", "hit", "hit", "getHits", "hit", "getHits", "getHits"],`
      `parameters = [[], [1], [2], [3], [4], [300], [300], [301]];`
      `res = [null, null, null, null, 3, null, 4, 3];`

    - **Решение 1 (оптимальное). Слайс в качестве двусторонней очереди.**
        - Храним двустороннюю очередь для событий, мапу для счетчиков пользователей и счетчик нарушителей.
        - При каждой операции удаляем события из очереди, которые были раньше окна, актуализируем счетчики. Т.о. счетчики после каждого события актуализированы.

      **Сложность: время - ?, память - ?.**

        ```go
        // Событие.
        type event struct {
        	// Время события.
        	t time.Time
        	// id пользователя.
        	u int
        }
        
        type UserStatistics struct {
        	// Двусторонняя очередь событий.
        	events []event
        	// Счетчики пользователей. Ключ - id пользователя, значение - счетчик за window время.
        	userCounters map[int]int
        	// Общий счетчик пользователей, которые превысили количество запросов (счетчик нарушителей).
        	usersLimitCounter int
        	// Временное окно, в котором нужно считать счетчики.
        	window time.Duration
        	// Ограничение по количеству событий для каждого пользователя за время window.
        	eventsLimit int
        }
        
        func NewUserStatistics(window time.Duration, limit int) *UserStatistics {
        	return &UserStatistics{
        		userCounters: make(map[int]int),
        		window:       window,
        		eventsLimit:  limit,
        	}
        }
        
        func (u *UserStatistics) AddEvent(now time.Time, userID int) {
        	// Добавляем новое событие в конец очереди.
        	u.events = append(u.events, event{t: now, u: userID})
        	// Если счетчик пользователя на грани ограничения, то увеличиваем счетчик нарушителей.
        	// Т.о. не нужно использовать лишние переменные, чтобы считать до и после.
        	if u.userCounters[userID] == u.eventsLimit-1 {
        		u.usersLimitCounter++
        	}
        	// Увеличиваем счетчик пользователя.
        	u.userCounters[userID]++
        	// Удаляем все события с начала очереди, которые вышли за пределы окна window.
        	u.remove(now)
        }
        
        // GetRobotCount returns number of robots.
        // User is robot at given time now <=> they have >= eventsLimit clicks since (>=) now - window.
        func (u *UserStatistics) GetRobotCount(now time.Time) int {
        	// Удаляем события, не входящие в окно.
        	u.remove(now)
        	// Теперь имеем только события входящие в окно и счетчик актуализирован.
        	return u.usersLimitCounter
        }
        
        func (u *UserStatistics) remove(now time.Time) {
        	for _, event := range u.events {
        		if now.Sub(event.t) <= u.window {
        			break
        		}
        		u.events = u.events[1:]
        		// Если пользователь был нарушителем, но после удаления события перестанет быть нарушителем - декрементируем счетчик нарушителей.
        		// Т.о. не нужно использовать лишние переменные, чтобы считать до и после.
        		if u.userCounters[event.u] == u.eventsLimit {
        			u.usersLimitCounter--
        		}
        		// Декрементируем счетчик пользователя.
        		u.userCounters[event.u]--
        		// Удаляем счетчик из мапы, если необходимо.
        		if u.userCounters[event.u] == 0 {
        			delete(u.userCounters, event.u)
        		}
        	}
        }
        ```